{"meta":{"title":"漫漫白衣路，少年追光时","subtitle":"漫漫白衣路，少年追光时","description":"","author":"arthersun","url":"https://arthersun.github.io","root":"/"},"pages":[{"title":"","date":"2021-12-01T15:29:16.751Z","updated":"2021-12-01T15:29:16.751Z","comments":true,"path":"draft/开题的问题和内容.html","permalink":"https://arthersun.github.io/draft/%E5%BC%80%E9%A2%98%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E5%86%85%E5%AE%B9.html","excerpt":"","text":"两个主题 如何设计一种合并和拆分的数据结构 如何设计一种服务，①设计一个激励机制，②设计一个服务 进行一个拆分 研究一个进行批量动态审计的数据结构 研究一个激励机制 如何做一个支持批量动态审计的服务，基于链来做 现实生活中不一定都是有审计的，针对审计造假,所以需要设计一种互审计服务 面向非职业节点的激励机制 三篇论文： 2019_Guo 主要看批量更新 2021_Yang主要看激励链 2020_Guo主要看多副本审计 重点关注下两个方向 智能合约安全性检测 区块链的激励机制 区块链的激励机制 尽量能低交互，少走共识协议，少消耗gas，低消耗代价的功能完善的审计方案 问题：你如何能够涉及少交互的次数，降低交互次数，达到审计的目的 只有达到这个目的，才能在共识这个层面上减少交互"},{"title":"Repositories","date":"2021-11-18T17:52:51.080Z","updated":"2021-11-18T17:52:51.080Z","comments":false,"path":"repository/index.html","permalink":"https://arthersun.github.io/repository/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-18T18:13:07.553Z","updated":"2021-11-18T18:13:07.553Z","comments":true,"path":"links/links.json","permalink":"https://arthersun.github.io/links/links.json","excerpt":"","text":"{\"Name\":{\"link\":\"http://example.com\",\"avatar\":\"http://example.com/avatar.png\",\"desc\":\"这是一个描述\"}}"},{"title":"友情链接","date":"2021-11-18T18:12:20.067Z","updated":"2021-11-18T17:52:51.079Z","comments":true,"path":"links/index.html","permalink":"https://arthersun.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-18T17:52:51.077Z","updated":"2021-11-18T17:52:51.077Z","comments":false,"path":"about/index.html","permalink":"https://arthersun.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-11-18T17:52:51.078Z","updated":"2021-11-18T17:52:51.078Z","comments":false,"path":"books/index.html","permalink":"https://arthersun.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-18T17:52:51.078Z","updated":"2021-11-18T17:52:51.078Z","comments":false,"path":"categories/index.html","permalink":"https://arthersun.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-18T17:52:51.080Z","updated":"2021-11-18T17:52:51.080Z","comments":false,"path":"tags/index.html","permalink":"https://arthersun.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-11-18T17:52:51.075Z","updated":"2021-11-18T17:52:51.075Z","comments":false,"path":"/404.html","permalink":"https://arthersun.github.io/404.html","excerpt":"","text":""},{"title":"2011_Zhu","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-18T01:57:09.716Z","comments":true,"path":"draft/2011-Zhu.html","permalink":"https://arthersun.github.io/draft/2011-Zhu.html","excerpt":"","text":"关于动态审计中的IHT的作用。 标签生成阶段。客户端(DO)使用一个秘密密钥对一个文件进行预处理，该文件由n个块的集合组成，生成一组公共验证参数(PVPs)和IHT，存储在TPA中，将文件和一些验证标记（File+Flags）传输给CSP，并可以删除其本地副本(见图2a); 定期抽样审计。通过使用可检索的交互式证明协议，TPA(或其他应用程序)发出一个“随机抽样”挑战，以审核存储在TPA中的验证信息(涉及PVP和IHT)的外包数据的完整性和可用性(见图2b);和 审计动态操作。一个AA，谁持有一个DO的秘密钥匙sk，可以操纵外包数据并更新存储在TPA中的相关IHT。sk的私密性和检查算法保证了存储服务器不能欺骗AA，伪造有效的审计记录 1总结：这张表帮我看清楚了动态审计过程中的IHT表的位置，IHT表是一张维护在TPA中的，由序列号、区块号、版本号和随机整数组成。除了记录数据的变化，每个记录Xi表被用来生成一个唯一的哈希值，这反过来是用来构造一个在秘密的钥匙sk旁边的签名标签σi。 IHT与HDFS的结合 基于这些hash值，客户端或TPA可以通过审计服务实现验证协议。在现有的HDFS中，我们的异常检测方案可以很容易地替换普通的校验和算法，而无需下载数据。"},{"title":"2015_Ayad","date":"2021-11-17T13:48:01.000Z","updated":"2021-11-17T13:48:26.023Z","comments":true,"path":"draft/2015-Ayad.html","permalink":"https://arthersun.github.io/draft/2015-Ayad.html","excerpt":"","text":"外包数据的核心设计原则之一是为各种应用程序提供数据的动态行为。这意味着远程存储的数据不仅可以由授权用户访问，而且还可以由数据所有者更新和缩放(通过块级操作)。[1] -[9]中提出的PDP方案只关注静态存储的数据，其中外包数据在远程服务器上保持不变。处理动态数据的PDP结构的例子是[10]-[14]。后者是数据文件的单个副本。尽管PDP方案已经给出了静态数据的多个副本，参见[15]-[17]，据我们所知，这是第一个直接处理动态数据的多个副本的PDP方案。"},{"title":"2019_Xu","date":"2021-11-24T12:42:22.000Z","updated":"2021-11-24T15:01:56.761Z","comments":true,"path":"draft/2019-Xu.html","permalink":"https://arthersun.github.io/draft/2019-Xu.html","excerpt":"","text":"使用智能合约来自动进行区块链审计 这个区块链审计模型有三种实体： 用户 网络存储服务提供商 公证节点"},{"title":"2016_张玉清","date":"2021-11-17T13:27:36.000Z","updated":"2021-11-17T13:48:08.024Z","comments":true,"path":"draft/2016-张玉清.html","permalink":"https://arthersun.github.io/draft/2016-%E5%BC%A0%E7%8E%89%E6%B8%85.html","excerpt":"","text":"在这里摘录了一段数据所有权证明的定义和意义感觉很不错 数据所有权的证明(provable data possession,简称PDP)[75]同样可以公开验证云端数据的完整性.由于验证过程中服务器的数据量和通信量较小,因此PDP模型适用于大规模分布式存储系统.当数据以多副本的方式存储于CSP时,用户需要对副本的个数与一致性进行额外的判断.为此,Barsoum等人[76]提出了相应的解决方案MB-PMDDP ,同时能够抵御服务器合谋并支持动态的数据更新.类似地,基于身份的分布式数据完整性检测模型ID-DPDP[77]针对数据存储于不同云服务器的情况,实现了私有验证、委托验证和公开验证."},{"title":"2019_Guo","date":"2021-11-17T15:04:45.000Z","updated":"2021-11-30T02:55:29.024Z","comments":true,"path":"draft/2019-Guo.html","permalink":"https://arthersun.github.io/draft/2019-Guo.html","excerpt":"","text":"(1)客户将其数据外包给CSP; (2)客户将审计工作外包给审计师; (3)通过依赖比特币[22]的功能，审计员定期审计CSP，检查外包数据是否完整; (4)每次审核后，审核员创建一个日志条目，记录他在这一点上的审核工作; (5)客户可以随时审核日志文件，以检查审核员过去是否诚实履行其审计工作; (6)客户端将更新的哈希值发送给审计师;审核员对RBMT进行更新，并将更新证明发送给CSP进行验证; (7)客户端也验证从CSP接收到的更新证明，并将更新后的数据块发送给CSP。 贡献1 提出了一种RBMT的多叶认证(multi-leaf-authenticated, MLA)解决方案，该方案能够在不存储状态值和高度值的情况下对多个叶节点及其索引进行身份验证。在MLA解决方案的基础上，提出了一种可以同时执行和验证多个更新操作的批量更新算法。每次认证/更新的摊销价格从1+log n降低到1+log (n/c)，其中是n是数据块的总数量和c是质疑/更新的数据块的数量。 (1)提出了RBMT的多叶认证(multi-leaf-authenticated, MLA)解决方案，该方案能够在不存储状态值和高度值的情况下对多个叶节点及其索引进行认证。在MLA解决方案的基础上，提出了一种可以同时执行和验证多个更新操作的批量更新算法。每次认证/更新的摊销价格从1+登录降低到1+log (n/c)，其中是数据块的总数量和挑战/更新的数据块的数量。 (2)提出了一种基于BLS签名的高效同态可验证标签(EHVT)来满足[15]的要求，该标签可以减少客户端从mo (kl)1toO(1)到log验证的次数。我们进一步提出了一种日志审计机制，通过这种机制，客户可以检查产生的日志文件由审计师以较低的频率来验证其过去是否诚实地执行了审计工作。 （3）我们描述了一个具体的ODPDP方案，该方案在改进的威胁模型中是安全的(参见第2.2节)，并且可以通过将频繁的审计工作迁移到外部审计员来减轻客户端的验证开销。我们实现了ODPDP方案的原型，实验证明了该方案的高性能。"},{"title":"","date":"2021-12-03T15:45:01.059Z","updated":"2021-11-30T02:50:38.728Z","comments":true,"path":"draft/2020-Guo.html","permalink":"https://arthersun.github.io/draft/2020-Guo.html","excerpt":"","text":"（1）我们设计了一种新的标签结构，它使用原始文件块的一组哈希值和特定的副本标识符来计算多个副本的验证标签。因此，只有这组散列值需要组织到IBMT中，并且IBMT的复杂性与副本的数量无关，这为三个副本节省了近66%的树存储成本。尽管这组哈希值适用于所有副本，但是可以使用特定的副本标识符来保证完整性证明确实来自已检查的副本。 (2)我们提出了一种平衡的ADS称为IBMT，它可以保证在任何更新情况下的预期do (logn)性能。然后，我们提出了一个批处理叶子验证(BLV)解决方案，可以同时验证多个有问题叶子的值和索引，而不需要重复的传输和计算。当检查三个副本，每个副本使用460个块时，与单独验证多个叶子相比，这减少了近43%的带宽成本。 (3)利用同态性质将被检查副本的多个证明聚合为一个证明，从而只需要传输和验证聚合证明。与逐个检查多个副本相比，当检查三个副本且每个副本有460个块时，审计师的计算时间提高了近40%"},{"title":"2020_Xu","date":"2021-11-24T12:37:31.000Z","updated":"2021-11-24T15:35:56.030Z","comments":true,"path":"draft/2020-Xu.html","permalink":"https://arthersun.github.io/draft/2020-Xu.html","excerpt":"","text":"摘要 基于双线性对技术的客户端数据重复数据删除方案。"},{"title":"2020_Huang","date":"2021-11-28T07:25:46.000Z","updated":"2021-12-08T16:12:58.000Z","comments":true,"path":"draft/2020-Huang.html","permalink":"https://arthersun.github.io/draft/2020-Huang.html","excerpt":"","text":"系统架构： PKG由一个完全可信的权威机构管理，该机构负责为整个系统设置公共参数，并为GM生成密钥对。 假设DO具有有限的通信、计算和存储资源。它根据需要生成并发送审计挑战给CSP，同时维护ACT来跟踪数据块的变化。 作为DOs的成员，GM是由某一组DOs共同指定的。然而，它被认为拥有比普通DOs更多的资源。 GM负责维护管理DOs的区块链分类帐，并在分类帐更新时将结果返回给他们。 CSP为DOs提供了重要的存储空间和计算能力。它还负责存储区块链，在收到审计质疑时响应证明。在我们的假设中，CSP可能是不诚实的，不同CSP之间存在商业竞争。 激励算法： 区块链的另一个重要部分是激励机制，它可以鼓励共识节点诚实地重复某些任务并获得奖励，从而增强整个系统的分布式信任和结果的可靠性。在假设所有实体都是理性的基础上，我们大致提出了一种可行的激励机制，考虑到经济利益和不当行为： DO（数据拥有者）需要购买信用来支付GM和CSP的操作请求 在协商一致的过程中的每一次沟通将花费GM和CSP的一部分信用。 如果CSP（服务提供商）拒绝DO（数据拥有者）的申请，信用评分将大幅下降，而DO除了已经支付的申请费外，还将得到额外的补偿。 GM只有在被管理的DO请求通过后才能获得信用奖励，否则GM既不盈利也不亏损。 如果当前回合成功达成最终共识，一个代表将会变大但呈线性增长，而其他共识节点将会变小但也呈线性增长。 DO可以根据信用评分自由选择任何CSP来存储数据，或选择任何GM来传输消息。如果信用评分低于某个阈值，现有的消费者就会选择另一家CSP或GM。"},{"title":"2021_Nourah","date":"2021-11-24T11:09:28.000Z","updated":"2021-11-24T11:09:56.907Z","comments":true,"path":"draft/2021-Nourah.html","permalink":"https://arthersun.github.io/draft/2021-Nourah.html","excerpt":"","text":"这是一篇解决云存储上重复数据删除的文章，"},{"title":"2021_Yu","date":"2021-11-18T02:26:35.000Z","updated":"2021-12-01T16:32:40.621Z","comments":true,"path":"draft/2021-Yu.html","permalink":"https://arthersun.github.io/draft/2021-Yu.html","excerpt":"","text":"摘要 数据备份是云服务提供商(csp)为避免潜在的数据丢失风险而采取的普遍策略。因此，CSP通常在地理位置分布的服务器上为每个数据块维护多个副本，以提高可靠性。这种复制技术的一个关键问题是，存储的副本越多，用户需要支付的费用就越多。因此，需要一个审计服务来帮助用户验证不受信任的CSP是否将其所有副本存储在不同的地理位置。本文提出了一种动态多副本审计方案，该方案具有以下特点:(1)可同时验证云用户数据副本的完整性和地理位置;(2)该方案能够根据地理位置识别不同副本，降低了数据预处理、动态操作和备份恢复的复杂性;(3)通过引入索引默克尔哈希树(IMHT)，我们可以降低现有默克尔哈希树的总体成本。证明了该方案在随机oracle模型下的安全性，并与现有方案进行了全面比较。理论分析和实验评价表明，与现有方案相比，该方案降低了通信和计算成本。分析表明，该方案只需挑战90个数据块，就能实现99%的验证概率 相关工作 多副本云审计部分 Curtmola等人[22]首先提出了一种多副本可证明数据占有(MR-PDP)方案来验证云用户数据的多副本的完整性。他们的方案以及许多其他的多副本审计方案[7,23 - 25]采用对称加密方案生成不同的副本，然后为这些副本生成hvt。还有一些现有的方案[26-28]利用同态加密算法生成不同的副本。遗憾的是，所有这些方案都使用加密算法来区分多个副本，这导致在数据预处理、备份恢复和动态更新过程中加密副本的复杂性和效率低下。例如，云用户必须对其数据进行多次加密，才能生成所有加密的副本。同时，一个损坏的加密副本不能直接替换为一个完整的副本，否则将无法区分这些副本。 地理位置证明部分 Gondree和Peterson[31]提出了一个基于约束的数据地理定位方案，该方案利用地标来定位存储服务器。Fu等人[32]提出了[31]的补充方法，通过使用可信平台模块(TPM)来检测CSP伪造的假位置。然而，由于网络时延不稳定，这两种方案都产生了较大的测量误差。例如，Internet内的计时误差可能只有几毫秒，但即使是1毫秒的计时误差也会导致150km的距离误差[29]。 动态更新部分 Liu等人[7]提出了一种动态多副本云审计方案，其结构名为多副本MHT (MR-MHT)，将每个数据块的所有副本组织成一个副本子树。但是，为了防止替换攻击，他们的方案由于采用了映射到点的哈希函数，引入了MR-MHT计算叶子节点的额外开销。此外，由于提出的MHT结构的深度比普通MHT大得多，验证成本大大增加。 多副本审计 CSP通常在地理位置分布的服务器上为每个数据块维护多个副本，以提高可靠性。这种复制技术的一个关键问题是，存储的副本越多，用户需要支付的费用就越多。因此，需要一个审计服务来帮助用户验证不受信任的CSP是否将其所有副本存储在不同的地理位置。 总结：引入了地理位置来进行多副本的识别，从而降低了多副本审计数据结带来的消耗。 Wang的方案 Wang et al. [18]等人提出了一个基于以太坊(Common区块链)的自动化审计架构，使用智能合约执行审计任务和薪酬相关补偿。Common区块链由于其共识节点规模大、激励机制有效，虽然可以有效地避免共谋攻击，但在大规模审计验证下难以达到可接受的执行效率。尽管Common区块链的效率更高，但仍然存在“无攻击”[19]。 没有有效的激励机制，就无法很好地抵御共谋攻击。PMAB以Common区块链为基础，通过有效的信用激励机制实现相互监督，加强了对csp审计数据的监督。[18]采用可验证延迟函数(VDF)实现自动审计;即系统自动生成安全随机源，在DOs不参与的情况下生成审计挑战，进一步降低了DOs的成本。然而，随机源的安全性来自于连续的计算功耗，这是不够有效的。因此，由于缺乏定制的审计协议区块链设计，现有的方案仍然遭受过多的开销和勾结攻击。 然而，上述公共审计方案具有集中的特性，即可信的TPA被授权审计来自数据所有者的外包数据。在实践中，很难找到像TPA这样诚实的组织。因此，去中心化审计协议更加合理 每个数据块更新 每个数据块的更新将需要每个副本中相应的块的更新。如果所有副本都在各自独立的ADS中索引，客户机必须逐个验证这些更新以保持可验证性。 双线性映射 比如说矩阵乘法就是一种双线性映射。 IMHT的验证算法 ​ 本质上利用了树形的特点，第一步先计算叶节点的哈希值，第二步利用邻接矩阵计算非叶节点哈希值，最后将新树根的哈希值和原来的比较，将新树根的索引值进行比较。 ​ 也因此，IMHT的结构被设计成与MHT有一定差异化的样子。 与Liu的MR-MHT进行对比 提高了计算效率。 由于MR-MHT将所有副本存储在树中，而IMHT只需要存储一个副本的元组，因此大大减少了存储开销。 同时降低了通信成本。H(.)的大小吧h(.)大很多。(因为引入地理位置) MR_MHT的结构设计 Liu等人[7]提出了一种动态多副本云审计方案，其结构名为多副本MHT (MR-MHT)，将每个数据块的所有副本组织成一个副本子树。但是，为了防止替换攻击，他们的方案由于采用了映射到点的哈希函数，引入了MR-MHT计算叶子节点的额外开销。此外，由于提出的MHT结构的深度比普通MHT大得多，验证成本大大增加。 系统架构 整个框架包含六个算法，被描述为： 安装 由云用户运行，去设置整个系统，包括输出的参数、公钥Y，私钥x 标签获取 由云用户运行，它的输入为云用户的私钥x和文件F，输出为同态可验证标签集 质疑 算法由TPA运行，输入为文件Finf的信息，输出为包含质疑数据块chal的索引和系数 响应 该算法由CSP运行，将响应证明发送给验证者 ，输入为质疑集chal，文件F和同态可验证标签集 地理位置获取 该算法由验证者运行，将所有的证明传输给TPA，算法以响应证明Ps为输入，以Ps和地理证明Pv为输出 验证 算法由TPA运行，为了去验证被质疑数据块的完整性，它以响应证明Ps，地理证明Pv，质疑chal，公钥Y，文件信息Finf为输入，如果能通过验证则输出1，如果不能则输出0 动态操作的消耗成本比较 n是一个副本的数据块数量，k是副本数量。 h代表通用的哈希函数。|h|代表h的输出大小。 H代表映射到点的哈希函数，|H|表示H的响应哈希函数 Storage:MHT树的存储开销 Construction:MR-MH，其中knH是节点计算H，（2kn-1）H是树的计算开销 AAI per block: AAI代表Ω，表示为了得到根哈希值，某一数据块节点需要的其他节点的哈希值。 沟通开销 上传：因为每个副本的同样可验证加密器不同，所以需要上传k倍（k为副本数） 备份恢复：因为每个副本的同样可验证加密器不同，所以需要多一部先解码后编码的过程。 动态更新：只需上传一个新的数据块及其HVT，而不必上传所有副本的新数据块和HVT。 环境评估 执行更多昂贵的映射到点哈希函数，并比CSP执行更多的求幂操作 概率验证——为啥验证200个块就可以达到99%的验证率 定质疑时间的几个实验 首先测试校内的RTT（往返时延） 然后测试多个校外的RTT，发现增长没有保持稳定，因此不能用于位置计算 最后定下来在校内放置验证器，实验定为最大的RTT 同态可验证加密器 HVA可以基于数字签名生成，如基于rsa的签名和基于bls的签名。因此，这种HVAs可以认为是同态可验证签名，利用HVA，公共审计师可以在不下载原始数据的情况下验证外包数据的完整性。 为什么要引入验证器 验证器是一个可信设备和CSP相同服务器的本地网络中，它是一个能够GPS，帮助TPA来向CSP发送质疑，为什么把验证器放在本地网络中是因为本地网络比Internet产生更少的延迟。 基于位置信息的身份副本 该方案采用距离边界协议来识别不同位置的每个唯一副本。该方案中使用的距离边界协议是可信验证者和质疑CSP两参与方之间的认证协议，验证者可以同时检查CSP的身份和地理位置。 通常情况下，验证者和CSP首先要相互通信，共享ID和秘密信息。然后，验证者需要与CSP进行多次交互。验证者发送挑战，并在每一轮启动时钟，CSP将发送相应的响应回给验证者。验证者将计算每轮往返时间∆tmax，并检查所有往返时间是否在允许的时间范围∆t≤∆tmax。如果所有的响应都是有效的，并且满足时间限制，那么就可以验证地理位置。也就是说，不同的副本可以通过其不同的地理位置来识别。 ~~存疑问题：那么一个验证者是否只给一个CSP发送信息呢？ 是 动态更新中，为什么云用户只用更新一个副本，其他副本是如何同步的。 只用更新一个副本，其他通信即可 2015_Liu中的Hash函数是如何被解密的？ 对于分布式多副本公共审计的思考与探索 这篇论文引入了地理位置，由此带来的树形数据结构的精简带来了时间复杂度的降维打击。 思考1：当地理位置相同的时候怎么处理，比如我存储在同一台电脑上，导致域名一致，无法区分？ 判断一下。 If（地理位置相同） MR-MHT（2015_Liu）； else IMHT（本文） 思考2：引入地理位置对硬件要求较高，云服务商也不一定配合，能否不引入地理位置，优化之前的方案？ 提出一种改进的副本树的数据结构。不是我的研究重点。 思考3：从安全性的角度考量，能否基于区块链存储或者直接用区块链的公证节点替代TPA？ 我觉得可行。审计过程产生的信息保存在链上可以保证不可篡改。TPA在其他多副本论文（2020_Li）中已经被替代了。仔细琢磨琢磨还有改进空间。 思考4：既然能引入地理位置来“降维打击”，能不能引入一个其他量来继续降维。 暂时没有想到。 思考5：从审计效率的考量，能否提出一种批量审计或批量更新的方法。 这方面文章看得太少，还无法考虑。"},{"title":"","date":"2021-12-01T18:22:28.185Z","updated":"2021-12-01T18:22:28.185Z","comments":true,"path":"draft/Untitled 1.html","permalink":"https://arthersun.github.io/draft/Untitled%201.html","excerpt":"","text":""},{"title":"","date":"2021-12-01T16:09:24.519Z","updated":"2021-12-01T16:09:24.519Z","comments":true,"path":"draft/Untitled 2.html","permalink":"https://arthersun.github.io/draft/Untitled%202.html","excerpt":"","text":""},{"title":"","date":"2021-12-01T15:23:19.088Z","updated":"2021-12-01T15:23:19.088Z","comments":true,"path":"draft/Untitled.html","permalink":"https://arthersun.github.io/draft/Untitled.html","excerpt":"","text":"区块链违规交易的发现方法 挖掘 区块链数据的关联分析"},{"title":"","date":"2021-12-01T12:10:28.449Z","updated":"2021-12-01T12:10:28.449Z","comments":true,"path":"draft/java字符串常用操作.html","permalink":"https://arthersun.github.io/draft/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html","excerpt":"","text":"字符串查找 检索字符串 indexOf（String s） lastIndexOf(String str) 121 String str =&quot;We are students&quot;;2 int size = str.indexOf(&quot;a&quot;); // 变量size的值是3"},{"title":"","date":"2021-12-01T12:07:59.270Z","updated":"2021-12-01T12:07:59.270Z","comments":true,"path":"draft/java多线程.html","permalink":"https://arthersun.github.io/draft/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html","excerpt":"","text":"概述 java.thread 线程实现+线程同步 看起来是多个任务都在做，其实本质上我们的大脑同一时间只做了一件事 多线程的三种创建方式 继承Thread类 实现Runnable接口 实现Callable接口"},{"title":"激励机制","date":"2021-11-18T02:49:42.000Z","updated":"2021-12-03T15:46:49.902Z","comments":true,"path":"draft/激励机制.html","permalink":"https://arthersun.github.io/draft/%E6%BF%80%E5%8A%B1%E6%9C%BA%E5%88%B6.html","excerpt":"","text":"激励机制: 2021_Yang 激励机制是区块链制度的动力源泉和保障基石。信用价值信用是PMAB激励机制的核心，它主要来自于DOs支付给csp的初始信用、存款和审计报酬。分数越高的候选节点越有可能被选为代表性节点。而且，共谋造成的信用损失将大于信用获得，理性的csp将进行诚实的审计，以实现利益最大化。下面介绍一些与信贷有关的关键概念。 (1)initial Credit。当每个CSP加入PMAB时，它需要支付一定的deposits以换取initialCredit，当发现该CSP的恶意行为时，该initialCredit将被没收。只有当initialCredit达到阈值时，它才能成为候选节点。 (2)deposit。当审计合同被构建时，CSP需要抵押保证金，其中dataValue和penalty是deposit的一半。 (3)dataValue。作为CSP在审计失败时支付给DO的补偿，它代表了数据的价值。 (4)penalty。作为对恶意行为的CSP被审计时的罚款。 (5)bonusPool。所有被没收的initial Credit和penalty将被放入bonusPool，诚实的csp参与审计将均分bonusPool。 2021_Weng 构建DeepChain块 DeepChain由激励机制和共识协议两个主要构建模块组成 激励机制的引入对于协同深度学习至关重要，原因如下:首先，对于那些想要一个深度学习模型但又没有足够的数据来自己训练模型的各方，激励可以激励他们利用自己的本地数据加入协同训练。其次，通过奖惩激励机制，确保了 (1)各方在本地模式培训和梯度交易中表现诚实， (2)工人在加工方交易中表现诚实。 2020_Huang_When Blockchain Meets Distributed File Systems Swarm平台 带宽激励 在Swarm的上下文中，提供块的服务是收费的，节点可以用服务交换服务或服务交换令牌。为了激励节点在可靠的环境中提供稳定的服务，Swarm提出了Swarm Accounting Protocol (SW AP)[8]。首先，在握手协议中，节点在通信时协商区块价格。不同的价格意味着不同的带宽成本。块价确定后，采用支票簿合同保证付款。支票簿合同是一种智能合同，具有以太坊(Ethereum token)余额。另一种安全的支付方式叫做信道合同，后来由Swarm提出，可以在[8]中看到。这两种支付方式都支持安全的链下交易和延迟更新。所有的交易都以以太坊区块链的状态存储，不能被篡改。最后，节点建立网络连接，交换数据。 存储激励 集群鼓励节点保存已上传到网络的数据。通常，长期的数据保存是不现实的。不受欢迎的部分不能带来足够的利润，可能会被清理，为新的部分腾出空间。为了保证数据的长期可用性，每个块的所有者需要对节点的存储进行补偿。为了管理存储交易，Swarm采用了一套激励方案:SWAP,SWEARandSWINDLE，如下所述。 •SW AP[8]:节点与注册的对等节点建立连接，这些对等节点是它们想要补偿和签订合同的目标节点。然后他们可以交换信息，包括同步、收据、价格谈判和付款。 •SWEAR[8]:已注册的对等体负责他们的长期存储承诺，他们必须通过上传他们的存款，通过在以太坊上通过SWEAR (Secure Ways of确保存档或群执行和注册)[8]合同注册。如果他们违反规则，将会受到惩罚，并在链上诉讼过程中失去存款。 •SWINDLE[8]:节点提供已签名的存储块收据。当发生关于是否违反规则的争议时，丢失块的节点可以通过上传丢失块的收据向SWINDLE(有保险存款担保诉讼和托管)[8]合同提交挑战。节点也可以通过上传区块或托管证明来提出对achallenge的反驳。欺诈契约通过检查数据块的哈希值来决定哪一个是有罪的。当块被转发时，一个基于上述激励方案的契约链被创建，它优雅地解决了节点之间的纠纷 2015_IPANM 在消除组管理器的情况下，组用户在生成密钥和签名时具有相同的权限。但是，相同的组成员在生成密钥和签名时可能处于非活动状态，导致签名生成效率低下。这促使本文提出一种激励机制。由于其透明性和不变性，区块链在提议的激励机制中被用来记录公平奖励的信息。为了避免引入较大的开销，建议的激励机制只使用区块链来记录身份信息进行激励，并且只允许文件所有者部署智能合约。建议的激励机制如下。 服务器从头到尾搜索区块链，以便找到被选择为最终签名的最早有效签名。由于对最终签名做出贡献的签名者和生成有效密钥共享的用户的身份信息被记录在区块链中，因此很容易找到并奖励这些签名者和用户。服务器将奖励那些贡献最终签名和密钥的用户。在提出的激励机制中，用户获得的奖励会随着时间的增加而减少。换句话说，贡献者越早生成有效信息，他们得到的奖励就越多。文件所有者部署智能合约来执行激励操作，如下所示。 1)初始化。文件所有者uiof filems将总激励费设置为硬币，并设置所有者需要的贡献者数量。区块链块中的消息设置为{(ids, pka, N oa)}s∈[1,t]，其中它是文件块标识符，pkais为文件块标识符，N oais为序列号。当序列号n等于1时，具有公共密码匙的贡献者获得log2t的激励费用。当序号n在[2,3]范围内时，贡献者得到的激励费用为2 log2t。这样重复，直到序号n oa属于[t/2, t]的范围，在这种情况下，贡献者得到a (t/2+1) log2t的激励费用。由于其抗篡改的特性，区块链可以确保只有签名共享的真实签名者才能从服务器获得奖励。 2020-通信学报-CCF B"}],"posts":[{"title":"深夜碎碎念","slug":"深夜碎碎念","date":"2022-11-24T15:43:45.000Z","updated":"2022-11-24T15:56:09.954Z","comments":true,"path":"2022/11/24/深夜碎碎念/","link":"","permalink":"https://arthersun.github.io/2022/11/24/%E6%B7%B1%E5%A4%9C%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"","text":"深夜碎碎念 最难的几年莫过于读研 那种受挫后不断反思，不断揉碎自己重塑价值的过程，是煎熬啊 越长大越沉默，是看到很多事情后发现懒得解释，懒得沟通，就这样吧，说话也挺累的 好在善意的人还是挺多的 加油吧少年，为了自己的生活","categories":[],"tags":[]},{"title":"ConcurrentHashMap原理","slug":"ConcurrentHashMap原理","date":"2022-11-24T15:43:09.000Z","updated":"2022-11-24T15:43:33.774Z","comments":true,"path":"2022/11/24/ConcurrentHashMap原理/","link":"","permalink":"https://arthersun.github.io/2022/11/24/ConcurrentHashMap%E5%8E%9F%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"值传递和引用传递","slug":"值传递和引用传递","date":"2022-11-24T13:38:54.000Z","updated":"2022-11-24T13:38:54.148Z","comments":true,"path":"2022/11/24/值传递和引用传递/","link":"","permalink":"https://arthersun.github.io/2022/11/24/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"类加载子系统","slug":"类加载子系统","date":"2022-11-21T02:11:32.000Z","updated":"2022-11-21T02:33:25.468Z","comments":true,"path":"2022/11/21/类加载子系统/","link":"","permalink":"https://arthersun.github.io/2022/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"类加载子系统 类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。 ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。","categories":[],"tags":[]},{"title":"线程池相关","slug":"线程池相关","date":"2022-11-20T07:43:41.000Z","updated":"2022-11-20T08:18:30.771Z","comments":true,"path":"2022/11/20/线程池相关/","link":"","permalink":"https://arthersun.github.io/2022/11/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/","excerpt":"","text":"线程池相关 ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量。 | 状态名 | 接收新任务 | 处理阻塞队列任务 | 说明 | | Running | Y | Y | | Shutdown | N | N | 不会接收新任务，但会处理阻塞队列剩余任务 | | Stop | N | N | 会中断正在执行的任务，并抛弃阻塞队列任务 | | Tidying | - | - | 任务全执行完毕，活动线程为0即将进入终结 | | Terminated | - | - | 终结状态 |","categories":[],"tags":[]},{"title":"try-catch-finally执行顺序","slug":"try-catch-finally执行顺序","date":"2022-11-18T03:20:25.000Z","updated":"2022-11-19T01:42:28.954Z","comments":true,"path":"2022/11/18/try-catch-finally执行顺序/","link":"","permalink":"https://arthersun.github.io/2022/11/18/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"try-catch-finally执行顺序 1、不管有没有出现异常，finally块中的代码都会执行； 2、当try和catch中有return时，finally仍然会执行； 3、finally是在return后面的表达式运算后执行的。","categories":[],"tags":[]},{"title":"synchonized锁升级流程","slug":"synchonized锁升级流程","date":"2022-11-17T02:56:53.000Z","updated":"2022-11-17T03:01:00.919Z","comments":true,"path":"2022/11/17/synchonized锁升级流程/","link":"","permalink":"https://arthersun.github.io/2022/11/17/synchonized%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/","excerpt":"","text":"synchronized锁升级 根据上面内容可以知道，synchronized锁有四种状态：无锁，偏向锁、轻量级锁和重量级锁，下面介绍四种状态和其之间的转换。 2.1 无锁 当一个对象被创建之后，还没有线程进入，这个时候对象处于无锁状态，其Mark Word中的信息如上表所示。 2.2 偏向锁 当锁处于无锁状态时，有一个线程A访问同步块并获取锁时，会在对象头和栈帧中的锁记录记录线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来进行加锁和解锁，只需要简单的测试一下啊对象头中的线程ID和当前线程是否一致。 2.3 轻量级锁 在偏向锁的基础上，又有另外一个线程B进来，这时判断对象头中存储的线程A的ID和线程B不一致，就会使用CAS竞争锁，并且升级为轻量级锁，会在线程栈中创建一个锁记录(lock Record)，将Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头的Mark Word替换成指向锁记录的指针，如果成功，则当前线程获得锁；失败，表示其他线程竞争锁，当前线程便尝试CAS来获取锁。 2.4 重量级锁 当线程没有获得轻量级锁时，线程会CAS自旋来获取锁，当一个线程自旋10次之后，仍然未获得锁，那么就会升级成为重量级锁。 成为重量级锁之后，线程会进入阻塞队列(EntryList)，线程不再自旋获取锁，而是由CPU进行调度，线程串行执行。","categories":[],"tags":[]},{"title":"mybatis八股","slug":"mybatis八股","date":"2022-11-16T13:56:54.000Z","updated":"2022-11-17T02:49:05.572Z","comments":true,"path":"2022/11/16/mybatis八股/","link":"","permalink":"https://arthersun.github.io/2022/11/16/mybatis%E5%85%AB%E8%82%A1/","excerpt":"","text":"MyBatis编程步骤是什么样的? 1、创建SqlSessionFactory 2、通过SqlSessionFactory创建Sql Session 3、通过sqlsession执行数据库操作 4、调用session.commit()提交事务 5、调用session.close()关闭会话 JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？ 1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决：在SqlMapConfig。xml中配置数据链接池，使用连接池管理数据库链接。 2、Sql语句写在代码中造成代码不易维护，实际应用sq！变化的可能较大，sq！变动需要改变java代码。 解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。 解决：Mybatis自动将java对象映射至sql语句。 4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。 解决：Mybatis自动将Sql执行结果映射至java对象。","categories":[],"tags":[]},{"title":"PUT请求和POST请求的区别","slug":"PUT请求和POST请求的区别","date":"2022-11-15T07:47:10.000Z","updated":"2022-11-15T08:09:44.361Z","comments":true,"path":"2022/11/15/PUT请求和POST请求的区别/","link":"","permalink":"https://arthersun.github.io/2022/11/15/PUT%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。 在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。 幂等设计 分布式事务 vs 幂等设计 为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为： 1bool withdraw(account_id, amount) withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。 这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。 另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如： 12int create_ticket()bool idempotent_withdraw(ticket_id, account_id, amount) create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。 基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示： 和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。","categories":[],"tags":[]},{"title":"GET请求和POST请求的区别","slug":"GET请求和POST请求的区别","date":"2022-11-15T06:37:56.000Z","updated":"2022-11-15T06:38:52.948Z","comments":true,"path":"2022/11/15/GET请求和POST请求的区别/","link":"","permalink":"https://arthersun.github.io/2022/11/15/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"使用上的区别： GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。 GET方式提交的数据有长度限制，则POST的数据则可以非常大〞，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。 POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。 本质区别 GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。 幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。","categories":[],"tags":[]},{"title":"HTTP常用的请求方式","slug":"HTTP常用的请求方式","date":"2022-11-15T06:34:48.000Z","updated":"2022-11-15T07:43:03.779Z","comments":true,"path":"2022/11/15/HTTP常用的请求方式/","link":"","permalink":"https://arthersun.github.io/2022/11/15/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/","excerpt":"","text":"GET 获取资源 POST 传输实体主体 PUT 上传文件 DELETE 删除文件 HEAD 和GET方法类似，但只返回报文首部，不返回报文实体主体部分 PATCH 对资源进行部分修改 OPTIONS 查询指定的URL支持的方法 CONNECT 要求用隧道协议进行代理 TRACE 服务器会将通信路径返回给客户端","categories":[],"tags":[]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2022-11-15T06:28:48.000Z","updated":"2022-11-15T06:34:11.248Z","comments":true,"path":"2022/11/15/HTTP状态码/","link":"","permalink":"https://arthersun.github.io/2022/11/15/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"常见状态码： 200：服务器正确处理了请求。 301：（永久移动）请求的网页已永久移动到新位置。服务器返回该响应（对GET或HEAD请求的相应）时，会自动将请求者转到新位置。 302：（临时移动）服务器目前从不同位置的网页相应请求，但请求者应继续使用原有位置来进行以后的请求。 400：客户端请求有语法错误，不能被服务器所理解。 403：服务器收到请求，但是拒绝提供服务。 404：（未找到）服务器找不到请求的网页。 500：（服务器内部错误）服务器遇到错误，无法完成请求。","categories":[],"tags":[]},{"title":"AOP和拦截器","slug":"AOP和拦截器","date":"2022-11-14T13:45:17.000Z","updated":"2022-11-15T06:28:39.151Z","comments":true,"path":"2022/11/14/AOP和拦截器/","link":"","permalink":"https://arthersun.github.io/2022/11/14/AOP%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"AOP原理 创建代理对象阶段 在Spring中，创建Bean实例都是从getBean()方法开始的，在实例创建之后，Spring容器将根据AOP的配置去匹配目标类的类名，看目标类的类名是否满足切面规则。 如果满足切面规则，就会调用ProxyFactory创建代理Bean并缓存到IOC容器中。根据目标对象的自动选择不同的代理策略。如果目标类实现了接口，Spring会默认选择JDK Proxy，如果目标类没有实现接口，Spring会默认选择Cglib Proxy。 拦截目标对象阶段 当用户调用目标对象的某个方法时，将会被一个叫做AopProxy的对象拦截，Spring将所有的调用策略封装到了这个对象中，它默认实现了InvocationHandler接口，也就是调用代理对象的外层拦截器。在这个接口的invoke()方法中，会出发MethodInvocation的proceed()方法。在这个方法中会按顺序执行符合所有AOP拦截规则的拦截器链。 调用代理对象阶段 Spring AOP拦截器链中的每个元素被命名为MethodInterceptor，其实就是切面配置中的Advice通知。这个回调可以简单地理解为是新生成的代理Bean中的方法。也就是我们常说的被织入的代码片段，这些被织入的代码片段会在这个阶段执行。 调用目标对象阶段 MethodInterceptor接口也有一个invoke()方法，在MethodInterceptor的invoke()方法中会触发对目标对象方法的调用，也就是反射调用目标对象的方法。 总结 流程： 代理对象：就是由Spring代理策略生成的对象； 目标对象：就是我们自己写的业务代码； 织入代码：就是要在我们自己写的业务代码增加的代码片段； 切面通知：就是封装织入代码片段的回调方法； MethodInvocation：负责执行拦截器链，在proceed()方法中执行； MethodInterceptor：负责执行织入的代码片段，在invoke()方法中执行。","categories":[],"tags":[]},{"title":"死锁","slug":"死锁","date":"2022-11-14T10:57:35.000Z","updated":"2022-11-14T11:25:03.349Z","comments":true,"path":"2022/11/14/死锁/","link":"","permalink":"https://arthersun.github.io/2022/11/14/%E6%AD%BB%E9%94%81/","excerpt":"","text":"死锁 死锁，就是说两个或两个以上的线程在执行的过程中，去争夺同一个共享资源导致相互等待的现象。如果没有外部干预，线程会一直处于阻塞状态，无法往下执行。这样一直等待处于阻塞状态的线程，被称为死锁线程。 产生死锁的原因 产生死锁需要同时满足以下四个条件： 互斥条件，共享资源a和b只能被一个线程占用 请求和保持条件，线程T1已经获取共享资源a，在等待共享资源b的时候，不释放共享资源a 不可抢占条件，其他线程不能强行抢占线程T1占有的资源 循环等待条件，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，这形成了循环等待 如何避免死锁","categories":[],"tags":[]},{"title":"内存溢出和内存泄漏","slug":"内存溢出和内存泄漏","date":"2022-11-14T10:48:49.000Z","updated":"2022-11-14T10:57:27.044Z","comments":true,"path":"2022/11/14/内存溢出和内存泄漏/","link":"","permalink":"https://arthersun.github.io/2022/11/14/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"内存溢出 JVM中可用内存空间存不下了，比如只有3M，但现在要创建一个5M的对象，新创建的就放不进去了。 内存泄漏 在业务代码执行过程中，有些对象它应该被回收，但是又有其他对象引用它，因此，GC不能自动回收。最终会导致内存泄漏。 如何避免 特别是一些流对象，比如OutputStream，Reader，BitMap，Document，很容易忘掉close。最麻烦的是要顺序回收，顺序错了还会产生空指针。","categories":[],"tags":[]},{"title":"逐层排序二叉树所需的最少操作数目","slug":"逐层排序二叉树所需的最少操作数目","date":"2022-11-14T04:41:42.000Z","updated":"2022-11-14T05:45:02.185Z","comments":true,"path":"2022/11/14/逐层排序二叉树所需的最少操作数目/","link":"","permalink":"https://arthersun.github.io/2022/11/14/%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目： 给你一个 值互不相同 的二叉树的根节点 root 。 在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。 返回每一层按 严格递增顺序 排序所需的最少操作数目。 节点的 层数 是该节点和根节点之间的路径的边数。 12345678输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]输出：3解释：- 交换 4 和 3 。第 2 层变为 [3,4] 。- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。共计用了 3 步操作，所以返回 3 。可以证明 3 是需要的最少操作数目。 思路： 使用置换环算法得到数组排序需要的最小交换次数。 具体实现思想： 使用Map记录每个节点值及其应该放到的位置 从头到尾遍历初始数组，使用flag[]数组标记当前元素是否已经参与过（即已经被加入环中），对已经参与过的数组则不再需要遍历。每次成环结束，记录成环个数loop。 最终最小交换次数为：数组长度-成环个数 nums.size()-loop 代码： 12345678910111213141516171819202122232425262728 // 返回使得 nums 递增需要的最小交换元素次数 public int minChanges(int[] nums)&#123; int[] copy = Arrays.copyOf(nums, nums.length); Arrays.sort(copy); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;copy.length; i++)&#123; map.put(copy[i], i); &#125; boolean[] flag = new boolean[nums.length]; // 用于标记 nums[i] 是否已经被加入环中 int loop = 0; // 环的个数 for(int i=0; i&lt;nums.length; i++)&#123; if(!flag[i])&#123; int j = i; while(!flag[j])&#123; // 画环 int index = map.get(nums[j]); // 当前节点指向的位置，画环过程 flag[j] = true; // 将 j 加入环中 j = index; // 将当前节点移动到环上下个节点 &#125; loop++; // 环数递增 &#125; &#125; return nums.length - loop; // 最小交换次数为 ： 数组长度 - 环数 &#125;作者：晚晴🌤链接：https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/solutions/1965867/by-liu-wan-qing-zjlj/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[]},{"title":"最小公倍数为K的子数组数目","slug":"最小公倍数为K的子数组数目","date":"2022-11-14T04:11:37.000Z","updated":"2022-11-14T04:41:10.827Z","comments":true,"path":"2022/11/14/最小公倍数为K的子数组数目/","link":"","permalink":"https://arthersun.github.io/2022/11/14/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"辗转相除法： 用大数对小数求余，若余数为0，则除数为最大公约数。若余数不为0，将此余数作为除数，小数作为被除数，重新求余，直到余数为0为止。此时的最大公约数为余数。 例如：27和6. 27%6=3. 6%3=0. 所以最大公约数为3. 12345678public int gcd(int a, int b)&#123; while (b != 0)&#123; int tmp = a % b; a = b; b = tmp; &#125; return a; &#125; 最大公约数和最小公倍数的关系： 12两个数的乘积等于这两个数的最大公约数与最小公倍数的乘积。假设有两个数是a、b，它们的最大公约数是B，最小公倍数是q。那么存在这样的关系式：ab=pg。 于是代码为： 123456789101112131415161718192021222324252627class Solution &#123; public int subarrayLCM(int[] nums, int k) &#123; int num = 0; for(int i=0;i&lt;nums.length;i++)&#123; int cur = nums[i]; for(int j=i;j&lt;nums.length;j++)&#123; cur = cur*nums[j]/gcd(cur,nums[j]); if(cur==k)&#123; num++; &#125;else if(cur&gt;k)&#123; break; &#125; &#125; &#125; return num; &#125; //用辗转相除法写gcd public int gcd(int a, int b)&#123; while(b!=0)&#123; int temp = a%b; a = b; b = temp; &#125; return a; &#125;&#125;","categories":[],"tags":[]},{"title":"吾日三省吾身","slug":"吾日三省吾身","date":"2022-11-13T06:54:16.000Z","updated":"2022-11-13T06:54:39.014Z","comments":true,"path":"2022/11/13/吾日三省吾身/","link":"","permalink":"https://arthersun.github.io/2022/11/13/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/","excerpt":"","text":"越来越谦逊低调 不想说任何谎言 对别人也越来越宽容","categories":[],"tags":[]},{"title":"复习加密算法","slug":"复习加密算法","date":"2022-11-13T03:51:02.000Z","updated":"2022-11-13T06:54:03.157Z","comments":true,"path":"2022/11/13/复习加密算法/","link":"","permalink":"https://arthersun.github.io/2022/11/13/%E5%A4%8D%E4%B9%A0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"复习加密算法 ECC椭圆曲线加密算法 椭圆曲线加密算法是基于椭圆曲线数学理论实现的一种非对称加密算法。 相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。 160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。 比特币使用了secp256k1这条特殊的椭圆曲线。 1y^2 = x^3 + 7","categories":[],"tags":[]},{"title":"便捷版快排","slug":"便捷版快排","date":"2022-11-12T13:16:52.000Z","updated":"2022-11-12T13:17:39.952Z","comments":true,"path":"2022/11/12/便捷版快排/","link":"","permalink":"https://arthersun.github.io/2022/11/12/%E4%BE%BF%E6%8D%B7%E7%89%88%E5%BF%AB%E6%8E%92/","excerpt":"","text":"123456789101112131415161718192021222324252627282930public class QuickSort &#123; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public void quickSort(int[] arr, int start, int end) &#123; if (start &gt;= end) return; int k = arr[start]; int i = start, j = end; while (i != j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= k) --j; swap(arr, i, j); while (i &lt; j &amp;&amp; arr[i] &lt;= k) ++i; swap(arr, i, j); &#125; quickSort(arr, start, i - 1); quickSort(arr, i + 1, end); &#125; public static void main(String[] args) &#123; int[] arr = &#123;5, 2, 6, 9, 1, 3, 4, 8, 7, 10&#125;; new QuickSort().quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125;","categories":[],"tags":[]},{"title":"判断是不是二叉搜索树的后序遍历","slug":"判断是不是二叉搜索树的后序遍历","date":"2022-11-12T12:53:34.000Z","updated":"2022-11-12T13:05:31.749Z","comments":true,"path":"2022/11/12/判断是不是二叉搜索树的后序遍历/","link":"","permalink":"https://arthersun.github.io/2022/11/12/%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 输入: [1,6,3,2,5] 输出: false 输入: [1,3,2,6,5] 输出: true 单调栈解法 12345678910111213141516171819class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int root = Integer.MAX_VALUE; for(int i = postorder.length - 1; i &gt;= 0; i--) &#123; if(postorder[i] &gt; root) return false; while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i]) root = stack.pop(); stack.add(postorder[i]); &#125; return true; &#125;&#125;作者：Krahets链接：https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solutions/150225/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 递归+检查的写法:注意，检查指针最后能不能移动到最后面。 12345678910111213class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; return recur(postorder, 0, postorder.length - 1); &#125; boolean recur(int[] postorder, int i, int j) &#123; if(i &gt;= j) return true; int p = i; while(postorder[p] &lt; postorder[j]) p++; int m = p; while(postorder[p] &gt; postorder[j]) p++; return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1); &#125;&#125;","categories":[],"tags":[]},{"title":"mac配置vim","slug":"mac配置vim","date":"2022-11-12T02:06:48.000Z","updated":"2022-11-12T02:10:08.447Z","comments":true,"path":"2022/11/12/mac配置vim/","link":"","permalink":"https://arthersun.github.io/2022/11/12/mac%E9%85%8D%E7%BD%AEvim/","excerpt":"","text":"mac如何配置vim 由于/usr/share/vim没有权限修改，且chmod +w也显示无法操作，需要将其复制到用户主目录下，这样修改的就是一个用户的vim配置。 复制的命令行为： 12# 将全局版vimrc文件复制到用户主目录下做为用户版vimrc：cp /usr/share/vim/vimrc ~/.vimrc 打开~/.vimrc 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;********************************基本设置******************************&quot;set tabstop=4 &quot; 设置tab键的宽度set shiftwidth=4 &quot; 换行时行间交错使用4个空格set autoindent &quot; 自动对齐set backspace=2 &quot; 设置退格键可用set shiftwidth=4 &quot; 自动缩进4空格set smartindent &quot; 智能自动缩进set number &quot; 在每一行最前面显示行号set showmatch &quot; 高亮显示对应的括号set mouse=a &quot; 启用鼠标set ruler &quot; 在编辑过程中，在右下角显示光标位置的状态行set cursorline &quot; 突出显示当前行set noswapfile &quot; 设置无交换区文件&quot;set writebackup &quot; 设置无备份文件set nobackup &quot; 设置无备份文件set autochdir &quot; 设定文件浏览器目录为当前目录set foldmethod=syntax &quot; 选择代码折叠类型set laststatus=2 &quot; 开启状态栏信息set cmdheight=2 &quot; 命令行的高度，默认为1，这里设为2set autoread &quot; 当文件在外部被修改，自动更新该文件set autoread &quot; 自动检测并加载外部对文件的修改set autowrite &quot; 自动检测并加载外部对文件的修改set showcmd &quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来syntax enable &quot; 打开语法高亮if has(&quot;gui_running&quot;) set guioptions+=b &quot; 显示底部滚动条 set nowrap &quot; 设置不自动换行endif&quot;********************************设置编码*******************************&quot;&quot; 设置换行编码set fileformats=unix,dos,mac&quot; 设置Vim 内部使用的字符编码方式set encoding=utf-8&quot; 设置文件编码if has(&quot;win32&quot;) set fileencoding=chineseelse set fileencoding=utf-8endif&quot; 解决consle输出乱码language messages zh_CN.utf-8 重启item2或者terminal","categories":[],"tags":[]},{"title":"学习linux命令行","slug":"学习linux命令行","date":"2022-11-12T01:49:09.000Z","updated":"2022-11-12T10:00:21.173Z","comments":true,"path":"2022/11/12/学习linux命令行/","link":"","permalink":"https://arthersun.github.io/2022/11/12/%E5%AD%A6%E4%B9%A0linux%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"怎么创建一个文件（非目录）？ 号可以创建，如果同时创建多个文件，可以使用多个&gt;号。 复制文件：cp 本文件 新文件/路径 命令行可以用分号隔开写多条命令 mkdir text1;cd …;mkdir text2 移动文件：mv 文件 路径 删除文件：rm 文件 vim撤销和取消撤销：u Ctrl+r 创建硬链接:ln 文件名 链接名 优点：除非删掉所有硬链接和文件，不然不会删掉 缺点：不能跨磁盘链接 使用通配符查看文件：ls -l ???.???","categories":[],"tags":[]},{"title":"关于测开职业生涯规划的一些想法","slug":"关于测开职业生涯规划的一些想法","date":"2022-11-10T12:27:56.000Z","updated":"2022-11-10T12:31:00.268Z","comments":true,"path":"2022/11/10/关于测开职业生涯规划的一些想法/","link":"","permalink":"https://arthersun.github.io/2022/11/10/%E5%85%B3%E4%BA%8E%E6%B5%8B%E5%BC%80%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/","excerpt":"","text":"关于","categories":[],"tags":[]},{"title":"重学jvm","slug":"重学jvm","date":"2022-11-10T12:27:30.000Z","updated":"2022-11-17T05:05:39.405Z","comments":true,"path":"2022/11/10/重学jvm/","link":"","permalink":"https://arthersun.github.io/2022/11/10/%E9%87%8D%E5%AD%A6jvm/","excerpt":"","text":"重学jvm Java的类存在哪里？ 误区：常规认为基本数据类型存放在栈中，引用类型存放在堆中 123Class Text&#123; int a = 1;&#125; 这里面的a是存在堆里面的。 而方法： public void text(){ int b = 1; } 在text局部方法中基本数据类型的变量b是存储在栈中的 如果你将一个实例变量放在栈内，那么就不存在多个线程访问同一个对象资源了，这显然是不对的，所以实例变量要在堆上创建，但是对于局部变量，是在栈上创建的，调用一次方法创建一个帧，独享一份内存区域，其他的线程是不会访问到该线程的资源，在栈上创建也会减轻GC的压力，随着该方法的结束，帧出栈，相对应的内存消除，这种局部变量占用的内存自然就消失了。 java中静态方法的作用是什么？ 声明为static的变量实质上是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。 只会分配一块存储空间，所有此类的对象都可以操控此块存储空间。 没有创建对象时也可以利用类使用该方法。静态方法可以调用静态方法、静态成员，但不能调用成员方法。 java静态变量存放在堆还是方法区？ 静态变量是被对象共享的，随着类加载而产生（不用实例化即可访问） java8之前存放在方法区 java8及以后：存放在堆中反射的class对象的尾部 java栈空间包括哪些内容？ 由一个个栈帧组成 局部变量表：主要存放编译器可知的各种数据类型、对象引用（可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置） 操作数栈：主要是存放方法运行过程中产生的中间变量。 动态链接：主要服务一个方法需要调用其他方法的场景。 返回地址。 final、finally、finalize的区别？ 修饰变量： 修饰基本数据类型：这个数据的值在初始化后将不能被改变。 修饰引用数据类型：引用在初始化后将永远指向一个内存地址，不可修改。里面的值是可以修改的 final修饰的常量在编译阶段会被放入常量池中。 final类：被修饰的类不能被继承，所有方法不能被重写。 try-catch-finally finally里面的语句是否一定会被执行？ 如果在try或catch中停止了jvm，则finally不会执行，例如停电。或者使用System.exit(0)可以阻断finally执行。 finally中的代码会执行，流程为： 先计算返回值，并将返回值存储起来，等待返回 执行finally代码块 将存储的返回值，返回出去 注：返回值是在finally运算之前就确定了，并且缓存（副本）了，不管finally对该值做任何的改变，返回的值都不会改变(不在finally中return) finalize是在java.lang.Object里定义的方法，也就是说每一个对象都有这么一个方法，这个方法在gc启动，该对象被回收的时候被调用。 一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize了，进而产生问题，因此不推荐使用 finalize 方法。 java静态变量、代码块、和静态方法的执行顺序是什么？ 静态代码块-&gt;构造代码块-&gt;构造函数-&gt;普通代码块(构造代码块是每次执行构造函数之前执行) 父类-&gt;子类 java多态： 编译时多态：重载，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法 运行时多态：继承、重写和向上转型 继承：在多态中必须存在有继承关系的子类和父类 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能调用父类的方法，又能调用子类的方法。","categories":[],"tags":[]},{"title":"论文中期梳理","slug":"论文中期梳理","date":"2022-11-07T08:08:04.000Z","updated":"2022-11-09T13:40:43.642Z","comments":true,"path":"2022/11/07/论文中期梳理/","link":"","permalink":"https://arthersun.github.io/2022/11/07/%E8%AE%BA%E6%96%87%E4%B8%AD%E6%9C%9F%E6%A2%B3%E7%90%86/","excerpt":"","text":"中期的任务 弄出一个方案创新点，做一部分实验，论文第三章写完 完成PPT制作 准备答辩问题 ps：需要注意的： 由于论文和答辩的特殊性，需要导师指导，需要预留时间给导师，提前计划给老师 一定要实事求是，不能操之过急，做了多少说多少，瞎说容易露出马脚 一些进展的timeline 16:12 读一篇区块链云审计的中文论文，弄清楚云审计的过程，大约3小时 [1]谷天龙. 基于区块链的隐私保护云审计研究[D].天津大学,2020.DOI:10.27356/d.cnki.gtjdu.2020.003033. 涉及到的比较模糊的概念： 云计算、云审计 云计算 云计算分为IaaS、PaaS、SaaS IaaS:硬件、网络 PaaS:操作系统 Linux SaaS:一些软件服务 云审计 云审计是一种监控通过控制台进行的操作、通过OpenAPI触发的操作、事件下载及转储、事件分析、追踪、告警等的行为 ps:例如腾讯云的云审计：使用腾讯云云审计（CloudAudit），可以获取您腾讯云账号下 API 调用历史记录，包括通过腾讯云管理控制台，腾讯云 SDK，命令行工具和其他腾讯云服务进行的API调用，监控腾讯云中的任何部署行为。可以确定哪些子用户、协作者使用腾讯云 API 时，从哪个源 IP 地址进行调用，以及何时发生调用。您可以设置多个不同的跟踪集用以跟踪不同的日志，随时控制何时打开和关闭 CloudAudit 日志记录。 云存储审计和云审计果然不是一个东西，老师批评的对 读一篇云存储审计的论文 摸鱼了半天","categories":[],"tags":[]},{"title":"记一次惨痛的面试失败经历","slug":"记一次惨痛的面试失败经历","date":"2022-11-02T14:32:22.000Z","updated":"2022-11-02T14:37:32.069Z","comments":true,"path":"2022/11/02/记一次惨痛的面试失败经历/","link":"","permalink":"https://arthersun.github.io/2022/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%83%A8%E7%97%9B%E7%9A%84%E9%9D%A2%E8%AF%95%E5%A4%B1%E8%B4%A5%E7%BB%8F%E5%8E%86/","excerpt":"","text":"部门：阿里菜鸟 测开三面 面试官性别女 开头抽到简历上不熟的项目，然后我强答了一下，然后被怼 稍微解释了一下 第一印象估计极差 问另一个项目，我心情及其烦躁，脑子已经跟不上了，说得很乱 又被怼 “好了，我没有问题了” “你有什么想问我的嘛” “问问生涯规划” 拿自身举例，跟我说做人要实诚，做任何工作都要诚实、稳重 并直接挂了面试流程","categories":[],"tags":[]},{"title":"2020_Wang_PoRX:IIoT区块链共识的声誉激励方案","slug":"2020-Wang-工业互联网中基于区块链的激励方案","date":"2021-12-08T16:12:33.000Z","updated":"2021-12-09T15:11:20.000Z","comments":true,"path":"2021/12/09/2020-Wang-工业互联网中基于区块链的激励方案/","link":"","permalink":"https://arthersun.github.io/2021/12/09/2020-Wang-%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E6%A1%88/","excerpt":"","text":"PoRX:IIoT区块链共识的声誉激励方案 第一章 介绍 介绍： 工业物联网（IIoT）是指工业生产中的各种设备，无论是工厂中的机器设备还是汽车和飞机中的发动机，其上安装传感器并连接到无线网络终端以收集和共享数据。目前，由于IIoT系统是一个开放的、分布式的、异构的系统，在IIoT中实现可信通信是一个巨大的挑战。区块链技术已成为解决工业物联网合作信任问题的新途径。利用区块链，可以构建防篡改系统，作为工业物联网硬件产品从芯片到整个设备的审计工具。 在IIoT中应用区块链技术的主要问题之一是解决共识协议的安全性和效率问题。本文提出了一种信誉机制，以鼓励正常节点和异常节点以良好的方式参与网络协作。为了引导这种行为，提出了一种基于声誉的激励方法。在声誉的收益支付函数中设计了奖惩因子。其有效性在于合作行为得到奖励，而非合作行为受到惩罚。 我们方案的主要优点是，我们基于声誉的激励模块可以在最先进的PoX协议（称为PoRX）上实现，并且可以使PoX协议达到更好的一致状态。因此，它将有利于IIoT与区块链的应用。 工业物联网应用的例子 智能电表能在社区本地运行，如果出现电源故障，这些智能电表可以确定故障范围，通过基于区块链的智能合约技术直接与本地变电站通信，并重新规划输电线路。 IOTA 工业物联网系统的问题的复述 由于IIoT本身是一个开放系统，因此允许各种设备加入。一些恶意设备和不诚实设备在加入网络后可能会对IIoT系统的共识协议发起攻击，从而可能破坏IIoT的系统[8]。实际上，当前的最先进的共识协议没有考虑如何在共识协议中保证节点行为良好。在IIoT的实际应用中，解决IIoT系统中恶意节点的攻击一直是需要面对的现实问题[9,10]。为了将区块链成功应用于IIoT，构建一个可信、高效的区块链共识协议是一个亟待解决的关键问题。本文针对这些问题，提出了一种激励声誉方案，以激励节点在系统中保持稳定的良好行为。好的行为会得到奖励，坏的行为会受到惩罚。每个节点都有一个具有信誉值的标识。具有较高的信誉价值，会得到更多的合作。虽然声誉价值较低，但很少得到他人的合作。该方案的主要优点是基于声誉的激励模块可以建立在PoX协议的基础上，是一种实用的方法。 缺乏一种奖惩机制 第二章 相关工作 共识协议 PoW：核心思想是通过节点间计算能力的竞争来分配区块记账权。浪费大量电能 PoS：PoS的主要思想是，用户在系统中所占的比例与块生成的难度成反比。系统中节点持有的股份越大，他就越容易获胜。 现有共识协议的问题一——不确定性 几项协商一致的协议都有一个共同的问题，即协商一致的过程是不确定的。缺乏共识确定性导致交易确认延迟，这不适用于大多数需要实时确认的实时IIoT系统 比如说比特币（pow）虽说是平均10分钟出一个块，但有可能1分钟出块，也有可能半小时出块，造成不确定性。 现有共识协议的问题二——面向加密货币的共识协议不适用于物联网 IIoT系统的主要要求是，应根据以IIoT业务为中心的交易验证规则对交易进行验证。 这是一项基本要求，因为IIoT中的每个新事务基本上都独立于以前的事务，环境或事件的变化会影响设备读数的变化。因此，我们应该设计物联网交易的验证规则。 BTC：比特币会把未花费的币维护成一个（未花费的交易输出表）UTXO 例如，在智能家居中，只有当摄像头或任何其他传感器检测到房间中有人时，壁炉才会点亮。这意味着传感器读数是根据环境背景而不是孤立地进行验证的。 现有共识协议的问题三——分叉 共识协议还应具有共识的最终性，以避免出现分歧。此外，Huang[27]提出了一个分析模型来分析共识区块链中的分布式网络分叉概率。 IIOT系统的问题——Sybil攻击 此外，IIoT系统也容易受到物理或网络攻击。最近，一场名为“Mirai”（Sophos裸体安全，2016）[28]的网络攻击感染了大量IIoT设备，包括DVR和CCTV摄像机，并将它们变成僵尸。然后，通过启动数以百万计的DNS查找请求形式的巨大数据流量，这些受损设备用于发起针对DNS服务提供商“DYN”的DDOS攻击。如果使用PoX共识协议，它可以有效抵御此DDOS攻击，但它面临51%的攻击。如果攻击者拥有整个网络一半以上的证明能力，则他可以实施攻击，并且成功的概率非常高。PoX共识协议也应该对Sybil攻击有效。 分布式系统的信誉机制 Gupta等人[29]提出了第一个P2P网络信誉系统。这是一个有效的解决办法。其他研究也对声誉系统做出了贡献，但没有一项是真正的去中心化。 近年来，区块链技术被关注并用于声誉设计。 Tavakolifard[30]对分散多代理系统中的信任和声誉进行了建模。 Yi[31]提出了在比特币上构建不可链接的（Coin Mixing）硬币混合系统的方案。 作者解释说，网络上的声誉与数字货币具有相同的要求： （1）数字货币可以表示为一个数字变量； 也就是说声誉需要被定量。 （2）其价值由每一参与者商定，不可由第三方操纵。系统记录付款期间的交互反馈，将实际信誉的计算留给第三方应用程序。 BTC的币价一直在波动，没有人可以定义BTC的价格。也就是说信誉也不能被强行定价。 Khaqqi[32]提出了一个基于声誉的交易系统，其中声誉表示参与者对减排努力的表现和承诺。采用多准则分析方法对该方案与传统排污权交易方案模型进行比较。 Schaub等人[33]提出了一种基于区块链的无信任、分散和匿名的电子商务应用声誉系统。系统用Pos链保证声誉系统的共识，同时，它允许客户提交评级和文本审查。 此外，一些学者利用声誉机制改进区块链[34]。Gai Fangyu等人[35]提出了基于声誉证明的共识协议。该协议纯粹基于声誉激励，完全放弃代币激励。我们认为，其协议的激励机制不够完善，放弃代币激励会导致用户参与共识的动机显著降低。 第三章 方法 在共识层上面加了一层激励（声誉）层 输出函数是要满足的目标值，它由经常账户信誉估价师和当前信用度确定。该函数具有当前状态值state和随机nonce值nonce。一旦Hfunction输出小于目标值，则认为矿工获得了该区块记账权。矿工的声誉价值越大，区块产生的概率越大。 实际上就是在原有的难度设置上多加了一层F，原有的可能是H（State,nonce）&lt;D 该函数的设计标准是将当前矿工的帐户信誉值合并到D的难度中。其核心思想是，最大信誉值（上限）可以抵消20%-40%的难度，最小信誉值（下限）可以提高20%-40%的难度， 基于身份的方法 共识中使用了基于身份的方法。身份是IIoT系统中的一个重要属性。我们设计了共识活动的身份识别方法。其逻辑是建立一个全局注册表来存储参与协商一致的节点的标识声明。智能合约的陈述是一个身份所呈现的事实。这些声明由申报人签字，因此可以验证其真实性和完整性。节点调用合约可以在作为验证者参与协商一致之前成功注册。 注册合约 智能合约身份注册。在协商一致协议中，注册身份契约用于协助共识协议的运行。其主要任务是注册参与共识节点的身份，并与真实世界中的身份信息相关联（？）。登记合约应确保申报人账户的有效性、申报的有效性和申报的唯一性。因为只有一个注册合约，所以所有调用方都可以信任它的逻辑并使用它。身份登记合同的具体任务如下。 与真实世界中身份信息相关联不就失去了匿名性吗 有点像联盟链的做法 注册：将帐户注册为矿工。验证后，可获得区块生成权，并将账户存储在全局注册账户列表中，返回注册账户列表。 注销：当用户想要退出共识时，可以取消帐户。注销的帐户被视为无效帐户。它无法参与共识，该帐户将从注册帐户列表中删除。 与BTC、ETH不一样的是，他这里的注册首先需要告知各方，其次也不是匿名 注册时需要确保有一定保证金（用于罚款），注册后账户的声誉设置为初始声誉 注销时需要确保现有状态（什么状态？）是否小于初始值，如果是的话，将声誉设为0定为注销 基于身份的方法具体描述 基于身份的方法包括声誉构建、区块链启动过程、竞争周期、激励机制和协议参数更新规则，具体描述如下。 声誉构建 一个矿工只能有一个账户，这样声誉值的设定才有意义。 区块链启动过程 因为我们的计划涉及部署身份登记合同，这些合同由矿工操作。存在一个矛盾：矿工的注册需要合同，而合同的部署需要矿工。 设置一个零地址。零地址无需注册即可拥有区块记帐权限。当一个新的链（没有矿工，没有合同）需要启动时，开发者或负责人可以先使用零地址作为矿工，将身份注册合同部署到新的链上，然后用户可以正常使用该合同。应该注意的是，所有零地址的目的是处理这些相互矛盾的事情。所有零地址都没有私钥，因此使用此地址挖掘获得的奖励无法撤回。 竞争周期 在本文中，我们提出了一种竞争限制，称为竞争周期，它用C_duration表示。一般来说，竞争周期是现在时间之前一定数量的块。例如，当前块之前的100个块可以视为竞争周期。竞争周期根据系统中注册矿工的数量动态确定。建议使用矿工人数的两倍作为竞争周期的值，主要目的是： 计算指定矿工的采矿难度。确保高声誉采矿者不能始终主导区块生产的优先级，并增加低声誉和潜在采矿者的机会。 例如，指数基数为2，竞争周期为100，矿工的声誉值为1200，开采1000号区块。如果900号至999号区块之间没有属于矿工的区块，则矿工的可用声誉值为1200。如果其中一个区块是矿工的，则矿工的可用声誉值为1200/2=600 用于计算矿工的声誉奖惩。声誉激励根据预期产生的区块数量计算，预期产生的区块数量将由竞争周期确定。 激励机制 在原始协议中，矿工获得一定数量的代币和交易费，作为成功开采区块的奖励。在与声誉模块的新协议中，奖励还包括声誉奖励。 规则如下: 1.如果注册的节点竞争成功生成块，并且该块最终得到确认，则该节点将收到奖励，包括声誉和令牌。 2.声誉会下降。如果注册节点未能在一定时间内生成块，或未能达到自己生成的预期块数，则将对其进行处罚。 更新协议参数的规则 协议参数包括循环参数和其他参数。周期参数包括竞争周期、奖励周期和惩罚周期。其他参数包括最大预期块生成量、最小预期块生成量、可用声誉衰减基数和声誉难度转换率。 循环参数由矿工人数决定。由于矿工是动态的，因此需要一个更新周期来更新矿工。注意，在我们的模块中，惩罚周期是很难执行（每次区块链上的区块高度达到惩罚期），立即执行奖励周期（每个生成的区块必须按奖励周期进行奖励）。这里我们假设更新周期等于惩罚周期，即在每个惩罚周期之后，调用矿工注册合同以获得当前矿工编号并更新周期参数以进入下一轮惩罚周期。奖励周期和惩罚周期应根据竞争周期设置。如果竞争周期非常大（这是IIoT中的常见场景，系统中有许多矿工），则可以选择竞争周期的一部分作为奖励周期和惩罚周期。相反，如果竞争周期很小（例如在启动阶段），为了避免意外情况，我们可以选择几个竞争周期。 其他参数为静态设置。 为了使PoX共识协议在IIoT中得到广泛应用，必须提高PoX协议的安全性。我们提出了一个信誉模块来解决PoX的安全问题。声誉模块将在下一节中详细介绍。 第四章 实验 在以太坊上进行实验，在docker上运行节点 理想的声誉增长 首先，可以得到最理想条件下矿工的声誉增长曲线，即不包括声誉增长衰减和在一个竞争周期内产生过多区块而导致的声誉惩罚。为了便于观察，所有参数均设置为理想化，竞赛周期设置为0。 理想的声誉增长 正常的声誉增长包括声誉奖励衰减和在一个竞争周期内产生的过多区块造成的声誉惩罚。根据模型参数的不同，声誉增长的性能也不同。为了便于观察，参数设置不同。最大声誉的转换率设置为1。我们建立了三个计算能力相同的矿工。初始信誉值分别设置为500、1000和1500。所有三家矿商都能运营良好，并记录声誉价值的增长和产生区块的比例。为了进行比较，我们首先不考虑过多区块导致的声誉报酬和可用声誉的衰减。 信誉值为1500的节点出块率仍占较大比例，但信誉值增长不明显。因此，信誉值的差距将会缩小，这将导致信誉较低的节点能够参与共识，但大功率节点成功作恶的概率仍然很大。 实验参数设置的很杂，有种为了故意凸显实验设置的。 协议安全性分析 Sybil attack 非匿名：很少有具有POX共识的区块链能够真正抵御此类攻击，因为区块链的账户是完全匿名的，无法识别。我们提议的声誉模块有身份注册合约，只有注册的账户才有资格参与共识活动。合约保证一个人或一个节点只有一个注册帐户。因此，除非攻击者可以贿赂或窃取多人注册的信息，否则声誉模块可以很好地抵御Sybil攻击。 思考： 回到最开始的问题： 分叉：第3个问题通过不匿名解决了。 算法中也没有结合环境背景的设置 不确定性：第一个问题呢？以太坊出块仍然是不确定的。 Normal Reputation Growth并不能减少贫富差距？","categories":[],"tags":[{"name":"论文","slug":"论文","permalink":"https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"}]},{"title":"Leetcode错题本","slug":"Leetcode错题本","date":"2021-12-06T15:59:22.000Z","updated":"2021-12-06T16:15:15.286Z","comments":true,"path":"2021/12/06/Leetcode错题本/","link":"","permalink":"https://arthersun.github.io/2021/12/06/Leetcode%E9%94%99%E9%A2%98%E6%9C%AC/","excerpt":"","text":"438 滑动窗口题 在滑动窗口比较时，我把window[c]==need[c]和need.count©换了一个位置，导致了这样的悲剧。 c++ map对象先判断存不存在，再直接引用，否则会直接创建一个map[c]=0","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://arthersun.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"滑动窗口题总结","slug":"滑动窗口题总结","date":"2021-12-06T12:21:28.000Z","updated":"2021-12-06T15:59:37.532Z","comments":true,"path":"2021/12/06/滑动窗口题总结/","link":"","permalink":"https://arthersun.github.io/2021/12/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"滑动窗口算法 这个算法技巧的思路非常简单，就是维护一个窗口，然后不断的滑动，然后更新答案。 大概的思路模板 12345678910111213int left = 0, right = 0;while (right &lt; s.size()) &#123; // 增大窗口 window.add(s[right]); right++; while (window needs shrink) &#123; // 缩小窗口 window.remove(s[left]); left++; &#125;&#125; 算法的时间复杂度为O(N)，比字符串暴力算法高效很多。 通用的滑动窗口算法框架 1234567891011121314151617181920212223242526272829void slidingWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right &lt; s.size()) &#123; // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(&quot;window: [%d, %d)\\n&quot;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) &#123; // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 ... &#125; &#125;&#125; 滑动窗口的思路 我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left , right)称为一个窗口。 我们先不断地增加right指针扩大窗口[left , right)，直到窗口中的字符串符合要求（包含了T中的所有字符） 此时，我们停止增加right，转而不断增加left指针缩小窗口[left , right)，直到窗口中的字符串不再符合要求。同时，每次增加left，我们都要更新一轮结果。 重复第2和第3步，直到right到达字符串S的尽头。 主要思路：第2步相当于在寻找一个可行解，然后第3步在优化这个可行解，最终找到最优解。 needs和window相当于计数器，分别记录T中字符出现次数和窗口中字符出现次数。 可以清晰的看到这个过程： 初始状态： 增加right，直到窗口[left , right)包含了T的所有字符。 增加left，缩小窗口[left , right]: 直到窗口中的字符串不再符合要求，left不再继续移动： 之后重复上述过程，先移动right，再移动left… 直到right指针到达字符串S的末端，算法结束。","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://arthersun.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"再学区块链及其应用","slug":"再学区块链及其应用","date":"2021-12-06T08:50:09.000Z","updated":"2021-12-09T01:35:46.000Z","comments":true,"path":"2021/12/06/再学区块链及其应用/","link":"","permalink":"https://arthersun.github.io/2021/12/06/%E5%86%8D%E5%AD%A6%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","excerpt":"","text":"课程链接：区块链技术与应用 04-比特币协议 区块链结构 BitCoin Script把A的输入和A的输出连在一起，运行一下。 区块链结构 Block header Block Body version transaction list hash of previous block header Merkel root hash target nonce 整个块头的hash要小于目标阈值。H(header)≤target 系统中包括全节点和轻节点 full node = fully validating node light node = light with node(只保存区块头的信息，系统中大多数是轻节点) 轻节点没有参与区块链的构造和维护，它只是利用了区块链的一些信息，做一些查询。 分布式共识 分布式共识一个简单的例子是一个分布式hash表（distributed hash table） xiao-&gt;12345 关于分布式共识的不可能结论 FLP：在一个异步的系统里，网络传输时延没有上限，即使只有一个成员是有问题的，也没有办法达成共识。 CAP：任何一个分布式系统，一致性，可用性和分区容错性只能满足两个，不可能三个都满足 比特币中的共识协议 membership 联盟链(例如hyperledger fabric)可从成员进入来限制 女巫攻击（sybil attack）：产生账户非常多（没用的本地账户）,来投票 比特币采用工作量证明，寻找nonce值来 UTXO：未花费的交易输出（unspent transaction output） total inputs = total outputs transaction-based ledger-基于交易的账本 第二个激励机制：交易费（transaction fee） account-based ledger-基于账户的账本 将来还要挖多少时间和已经挖了多少时间是没有关系的 10-BTC分叉 分为硬分叉和软分叉 硬分叉，比如调大区块，旧节点不能认同大区块，只能认同原区块，新节点可以认同大区块和原区块，如果旧节点不升级软件，那么可以一直挖下去，造成出现两条链的情况。 软分叉，比如调小区块，或者重新赋予区块内某一没用过的值，旧节点可以认同，但新节点无法认同，于是旧节点挖出来的区块会一直被废弃，于是被迫升级软件。 15-以太坊账户 BTC系统没有显式的维护账户的概念，导致BTC系统转出一笔钱，必须全部转出，并且转回给自己账户的另一个地址。 基于账户的模型(account-based ledger) 双花攻击和重放攻击 基于UTXO的余额-双花攻击-发钱的人不诚实，想再花一遍 基于账户的余额-重放攻击-收钱的人不诚实，想再收一遍 以太坊为了避免重放攻击加了一个转账次数nonce，每转账一次Nonce+1 以太坊中有两类账户： 外部（普通）账户：balance nonce 合约账户：code storage 为什么不延用比特币的账户模型呢 用智能合约时的合同纠纷 交易驱动的状态机","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"https://arthersun.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"区块链","slug":"区块链","permalink":"https://arthersun.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"IPFS解读","slug":"IPFS解读","date":"2021-12-06T02:08:09.000Z","updated":"2021-12-06T02:46:18.537Z","comments":true,"path":"2021/12/06/IPFS解读/","link":"","permalink":"https://arthersun.github.io/2021/12/06/IPFS%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"IPFS解读 组件： BitTorrent Kademila DHT SFS Merkel DAG Git IPFS白皮书 IPFS能够将网站、应用、文件和各种数据建立在点对点分布式网络上，并建立高效的索引。 基于位置寻址(Location) 基于内容寻址(Content ) Distributed Hash Tables(DHTs) Key(CID) Value(PeerID) BitSwap IPFS Object Data “Hello World” Links [ ] IPFS使用Git的Commit进行版本更新 增加激励机制，主动分发文件 FileCoin","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"当区块链遇上分布式系统","slug":"当区块链遇上分布式系统","date":"2021-12-05T03:52:54.000Z","updated":"2021-12-06T08:48:42.354Z","comments":true,"path":"2021/12/05/当区块链遇上分布式系统/","link":"","permalink":"https://arthersun.github.io/2021/12/05/%E5%BD%93%E5%8C%BA%E5%9D%97%E9%93%BE%E9%81%87%E4%B8%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"2020-Huang-当区块链遇上分布式系统 几种分布式区块链系统 DFS-distributed file systems-分布式文件系统 P2P distributed file systems-点对点分布式网络 文件系统共享带宽，存储和计算资源，都存在不稳定，缺少审计，缺少激励算法的问题 Inter-Planetary File System（IPFS）星际文件系统 关于IPFS，IPFS是一种旨在创建持久且分布式存储和共享文件的网络传输协议 在IPFS网络中的节点将构成一个分布式文件系统 关于IPFS写了另一篇介绍IPFS IPFS和Swarm整合了区块链系统，提出了有效的激励和安全保证，但是其可扩展性和隐私性也限制了新一代DFS的发展。 集中式主网的分布式激励机制 BitTorrent可以共享带宽，存储和计算资源，天然缺少激励机制 现在的bt系统一般通过分享率、上传量、H&amp;R积分等来设计激励机制，例如 上述指标达到一定时，就可以升级然后获得更多权限。 这种激励机制有效，因为主网站中心化，也便于国家监管，但是正是因为中心化，所以容易被查封，一旦主网站被调查停止服务，用户将无法查找下载种子文件、上传文件；而且用户需要在网站上留存用户信息，并没有做到隐私保护。 基于区块链的分布式激励机制设计 区块链为什么适合被设计激励机制？ 区块链系统会设计一种虚拟货币，当参与人数够多这种虚拟货币就会被广泛认可，甚至可以兑换法币（比特币、以太坊）。 区块链系统会通过设计好的机制（比特币），或者提供透明的智能合约供人编写（以太坊）来分发或交易这些虚拟货币。 此外，区块链系统天然自带出块有奖励。 下面分布式系统通过集成相应的区块链来保证激励的进行。 IPFS Swarm Storj FileCoin 以太坊 Metadisk","categories":[],"tags":[{"name":"论文","slug":"论文","permalink":"https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"分布式","slug":"分布式","permalink":"https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"区块链","slug":"区块链","permalink":"https://arthersun.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"page","slug":"draft/Java项目谷粒商城","date":"2021-12-04T07:40:00.000Z","updated":"2021-12-04T08:03:51.776Z","comments":true,"path":"2021/12/04/draft/Java项目谷粒商城/","link":"","permalink":"https://arthersun.github.io/2021/12/04/draft/Java%E9%A1%B9%E7%9B%AE%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/","excerpt":"","text":"","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://arthersun.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"开发","slug":"开发","permalink":"https://arthersun.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"k8s学习","slug":"k8s学习","date":"2021-12-01T02:05:30.000Z","updated":"2021-12-04T08:03:21.798Z","comments":true,"path":"2021/12/01/k8s学习/","link":"","permalink":"https://arthersun.github.io/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"k8s前世今生 Google 10年容器化基础架构 特点： 轻量级：消耗资源少 开源 弹性伸缩 负载均衡：IPVS 适合人群：软件工程师 测试工程师 运维工程师 软件架构师 项目经理 知识图谱 介绍说明： 前世今生 Kubernetes框架 kubernetes关键字含义 基础概念：什么是Pod（最小管理单元） 控制器类型 k8s 网络通讯模式 kubernetes: 构建k8s集群 资源清单：资源 掌握资源清单的语法 编写Pod 掌握Pod的生命周期 Pod控制器：掌握各种控制器的特点以及使用定义方式 服务发现：掌握SVC原理及其构建方式 存储：掌握多种存储类型的特点，并且能够在不同环境中选择合适的存储方案 调度器：掌握调度器原理 能够根据要求把Pod定义到想要的节点运行 安全：集群的认证 鉴权 访问控制 原理及其流程 HELM：等于Linux中的Yum管理器 掌握HELM原理 HELM模板自定义 HELM部署一些常用插件 运维：修改Kubeadm达到证书可用期限为10年 能够构建高可用的Kubernetes集群 服务分类 ​ 有状态服务：DBMS ​ 无状态服务：LVS APACHE 高可用集群副本数据最好是&gt;=3 奇数个 主要组件 APISERVER：所有服务访问统一入口 ControllerManager：维持副本期望数目 Scheduler：负责介绍任务，选择合适的节点进行分配任务 ETCD：键值对数据库，存储k8s集群所有重要信息（持久化） Kubelet：直接跟容器引擎交互实现容器的声明周期管理 Kube-proxy：负责写入规则至IPTABLES 、IPVS实现服务 COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析 DASHBOARD：给k8s集群提供一个B/S结构访问体系 INGRESS CONTROLLER：官方只能实现四层代理，INGRESS可以实现七层代理 FEDETATION：提供一个可以跨集群中心多k8s统一管理功能 PROMETHEUS：提供k8s集群的监控能力 ELK：提供k8s集群日志统一分析接入平台 k8s基础功能 Pod概念 自主式Pod 控制器管理的Pod 网络通讯方式 在同一个Pod里，端口是一样的。既共享网络，又共享存储卷。 ReplicaSet与Deployment ReplicationController用来确保容器应用的副本数始终保持在用户定义的副本数。即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收。在新版本的Kubernetes中建议使用ReplicaSet来取代ReplicationController ReplicaSet，跟ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector 虽然ReplicaSet可以独立使用，但一般还是建议使用Deployment来自动管理ReplicaSet，这样就无需担心跟其他机制的不兼容问题（比如ReplicaSet不支持rolling-update 但Deployment支持） HPA: Horizontal Pod Autoscaling Horizontal Pod Autoscaling仅适用于Deployment和ReplicaSet，在v1版本中仅支持根据Pod的CPU利用率扩容，在v1alpha版本中，支持根据内存和用户自定义的metric扩缩容 StatefullSet StatefullSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括： 稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现 稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于headless Service(即没有Cluster IP的Service)来实现 有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序一次进行（即从0到N-1,在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现 有序收缩，有序删除（即从N-1到0） DeamonSet DeamonSet确保全部（或者一些）Node上运行一个Pod的副本，当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收。删除DaemonSet将会删除它创建的所有Pod。 使用DaemonSet的一些典型用法： 运行集群存储daemon，例如每个Node上运行glusterd、ceph 在每个Node上运行日志手机daemon，例如fluentd、logstash 在每个Node上运行监控daemon，例如Prometheus Node Exporter Job，Cronjob Job负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束 Cron Job管理基于时间的Job，即 在给定时间点只运行一次 周期性地在给定时间点运行 多服务之间的交互方式 网络通讯方式 Kubernetes的网络模型假定了所有Pod都在一个可以直接联通的扁平的网络空间中，这在GCE（Google Compute Engine）里面是现成的网络模型，Kubernetes假定这个网络已经存在。 而在私有云里搭建Kubernetes集群，就不能假定这个网络已经存在了，我们需要自己实现这个网络假设，将不同节点上的Docker容器之间的互相访问先打通，然后运行Kubernetes 同一个Pod内的多个容器之间：localhost 各Pod之间的通讯：Overlay Network Pod和Service之间的通讯，各节点的Iptables规则 Overlay Network怎么实现 Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。而且它还能在这些IP地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。 Flannel怎么运行 ETCD和Flannel的关系 ETCD给Flannel提供说明： 存储管理Flannel可分配的IP地址段资源 监控ETCD中每个Pod的实际地址，并在内存中建立维护Pod节点路由表","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"默克尔树","slug":"默克尔树","date":"2021-11-22T14:24:43.000Z","updated":"2021-12-04T07:58:11.530Z","comments":true,"path":"2021/11/22/默克尔树/","link":"","permalink":"https://arthersun.github.io/2021/11/22/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/","excerpt":"","text":"Merkle 树结构 默克尔树（又叫哈希树）是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。默克尔树最早由 Merkle Ralf 在 1980 年提出，曾广泛用于文件系统和 P2P 系统中。 其主要特点为： 最下面的叶节点包含存储数据或其哈希值。 非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。 进一步地，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点的内容的哈希值。 默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。 目前，默克尔树的典型应用场景包括如下几种。 证明某个集合中存在或不存在某个元素 通过构建集合的默克尔树，并提供该元素各级兄弟节点中的 Hash 值，可以不暴露集合完整内容而证明某元素存在。 另外，对于可以进行排序的集合，可以将不存在元素的位置用空值代替，以此构建稀疏默克尔树（Sparse Merkle Tree）。该结构可以证明某个集合中不包括指定元素。 快速比较大量数据 对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着所代表的两组数据必然相同。否则，必然不同。 由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。 快速定位修改 以下图为例，基于数据 D0……D3 构造默克尔树，如果 D1 中数据被修改，会影响到 N1，N4 和 Root。 Merkle 树示例 因此，一旦发现某个节点如 Root 的数值发生变化，沿着 Root --&gt; N4 --&gt; N1，最多通过 O(lgN) 时间即可快速定位到实际发生改变的数据块 D1。 零知识证明 仍以上图为例，如何向他人证明拥有某个数据 D0 而不暴露其它信息。挑战者提供随机数据 D1，D2 和 D3，或由证明人生成（需要加入特定信息避免被人复用证明过程）。 证明人构造如图所示的默克尔树，公布 N1，N5，Root。验证者自行计算 Root 值，验证是否跟提供值一致，即可很容易检测 D0 存在。整个过程中验证者无法获知与 D0 相关的额外信息。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://arthersun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"论文","slug":"论文","permalink":"https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"}]},{"title":"11_20_项目组log_包括后几个月参与的任务","slug":"项目组log","date":"2021-11-20T02:27:34.000Z","updated":"2021-12-04T08:02:02.341Z","comments":true,"path":"2021/11/20/项目组log/","link":"","permalink":"https://arthersun.github.io/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%BB%84log/","excerpt":"","text":"时间与实习时间 4月份中期，整个项目3个月内干完 参与的集成任务 2月20号在corda上集成多对多拍卖 1月10号在corda上集成条件隐私保护 12月11日之前给出基本的激励智能合约机制的实现，到1月15日之前设计一个高级版的区块链的激励机制","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"https://arthersun.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2021-11-19T13:40:08.000Z","updated":"2021-12-04T08:03:37.925Z","comments":true,"path":"2021/11/19/linux常用命令/","link":"","permalink":"https://arthersun.github.io/2021/11/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"linux怎么查询端口号 lsof -i:xxx (xxx是网络号) linux怎么杀死以PID为名的进程 kill -9 PID linux怎么输出全局变量名 echo $PATH","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://arthersun.github.io/tags/linux/"}]},{"title":"开题要点","slug":"开题要点","date":"2021-11-18T02:49:42.000Z","updated":"2021-12-04T08:01:21.102Z","comments":true,"path":"2021/11/18/开题要点/","link":"","permalink":"https://arthersun.github.io/2021/11/18/%E5%BC%80%E9%A2%98%E8%A6%81%E7%82%B9/","excerpt":"","text":"开题报告 题目：落实到方法， 解决问题 --&gt; 说人家的方法有问题 用人家的方法-&gt;说人家的方法好-&gt;可以为本文在xx场景下提供选择。 问题 干的事和问题不是同一个东西 设计算法的难点在哪 3.1研究方法 理论研究 实验 数据 3.2技术路线 针对本文的三个研究内容，分别阐述技术路线，具体如下。 3.3可行性分析 1.研究经验可借鉴 2.数据条件具备 3.实验环境具备 4.理论研究能力具备 5.实验能力具备 6.技术路线可行 PPT 参考文献不用写全名，写是哪个期刊上就行 研究现状能说清楚就不要贴图 从别人的论文中找现状的证据贴在PPT中 做case分析 根据产出主要实现哪两个难点，PPT有图放图，文档不用画。","categories":[],"tags":[{"name":"论文","slug":"论文","permalink":"https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"}]},{"title":"论文的摘录","slug":"论文的摘录","date":"2021-11-17T04:01:32.000Z","updated":"2021-12-04T08:01:25.704Z","comments":true,"path":"2021/11/17/论文的摘录/","link":"","permalink":"https://arthersun.github.io/2021/11/17/%E8%AE%BA%E6%96%87%E7%9A%84%E6%91%98%E5%BD%95/","excerpt":"","text":"历史 Ateniese等[36]首次提出了一种可扩展、高效的PDP，支持除数据插入外的所有动态数据操作。 Erway等[37]首次提出了一种支持所有动态数据操作的完全动态可证明数据持有(DPDP)方案。 他们的方案采用基于秩的认证跳跃表来管理数据块的动态信息。 然而，他们的方案不能支持公开审计。 Wang等[38]提出了一种全动态审计方案，通过引入MHT来存储数据块的动态信息。他们利用Boneh-Lynn-Shacham (BLS)短签名代替RSA签名构造同态可验证标签(HVTs)，以减少通信开销。 Mukundan等人[39]提出了一种动态的多副本云审计方案，通过去除hvt中的索引信息。但是[38]和[39]都不验证数据块的索引，这意味着云存储服务器可以在任何位置使用数据块通过验证。 Zhu等人[8]提出了一个与索引哈希表相关的动态审计方案。他们将BLS签名与数据片段技术相结合，以减少存储开销。 Barsoum和Hasan[25]通过引入映射版本表(MVT)提出了一种基于映射的多副本数据持有方案。MVT由序号、块号和块版本三列数据组成，用来记录每个数据块的逻辑位置和物理位置的映射关系。该方案只需要存储一个文件副本的动态信息，消除了辅助认证信息(AAI)，减少了存储和通信开销。但是，MVT必须存储在TPA中。与CSP相比，TPA并不是一个存储密集型实体。因此，为无数云用户存储mvt将消耗TPA的大量存储资源。而且方案不安全，可能会出现[8]和[40]提出的HVT伪造问题。 Zhang等[24]提出了一种动态复制数据审计方案，采用改进的MHT (mMHT)来验证数据块及其指标的完整性。Liu等人[7]提出了一种动态多副本云审计方案，其结构为多副本MHT (MR-MHT)，将每个数据块的所有副本组织成一个副本子树。但是，为了防止替换攻击，他们的方案由于采用了map-to-point hash函数，引入了额外的计算MR-MHT叶节点的成本。此外，由于提出的MHT结构的深度比普通MHT大得多，验证成本大大增加。","categories":[],"tags":[{"name":"论文","slug":"论文","permalink":"https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"}]},{"title":"node与java版本的问题实录","slug":"nvs与node版本的问题实录","date":"2021-11-15T11:00:13.000Z","updated":"2021-12-04T08:03:44.328Z","comments":true,"path":"2021/11/15/nvs与node版本的问题实录/","link":"","permalink":"https://arthersun.github.io/2021/11/15/nvs%E4%B8%8Enode%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98%E5%AE%9E%E5%BD%95/","excerpt":"","text":"今天使用nvs时候遇到了node版本的问题 原因大概是有些node包（node-sass）不支持高版本的node包，这个可以到node包的官网去查看。 解决方法 使用nvs安装其他node版本 指令集 123nvs add 14nvs use 14nvs list 此外，也遇到java版本的问题 java版本 1UnsupportedClassVersionError: run/halo/app/Application has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 查询原因为使用了java11进行编译，但是运行时使用的是java8 45 = Java 1.1 46 = Java 1.2 47 = Java 1.3 48 = Java 1.4 49 = Java 5 50 = Java 6 51 = Java 7 52 = Java 8 53 = Java 9 54 = Java 10 55 = Java 11 56 = Java 12 57 = Java 13 解决方案：下载java11，然后修改系统环境变量","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://arthersun.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"docker学习","slug":"docker学习","date":"2021-11-15T09:24:05.000Z","updated":"2021-12-04T08:02:13.557Z","comments":true,"path":"2021/11/15/docker学习/","link":"","permalink":"https://arthersun.github.io/2021/11/15/docker%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"docker学习 docker概述 docker安装 docker命令 镜像命令 容器命令 操作命令 … docker镜像 容器数据卷 dockerFile docker网络原理 IDEA 整合docker docker compose docker swarm CI\\CD Jenkins 知道的越多，不知道的越多！","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://arthersun.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"k8s文档","slug":"k8s文档学习","date":"2021-11-15T09:24:05.000Z","updated":"2021-12-04T08:02:26.272Z","comments":true,"path":"2021/11/15/k8s文档学习/","link":"","permalink":"https://arthersun.github.io/2021/11/15/k8s%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"传统部署时代： 早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。 虚拟化部署时代： 作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。 虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。 每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。 容器部署时代： 容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。 容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处： 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。 关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。 可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。 跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。 资源隔离：可预测的应用程序性能。 资源利用：高效率和高密度。","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://arthersun.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"分布式","slug":"分布式","permalink":"https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"最新想看的一些新技术","slug":"最新想看的一些新技术","date":"2021-11-14T17:42:50.000Z","updated":"2021-12-04T08:01:58.568Z","comments":true,"path":"2021/11/15/最新想看的一些新技术/","link":"","permalink":"https://arthersun.github.io/2021/11/15/%E6%9C%80%E6%96%B0%E6%83%B3%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%8A%80%E6%9C%AF/","excerpt":"","text":"[x] js关于同步异步的一些知识 [ ] yarn和大数据的知识 [ ] go语法和框架学习 [ ] 内网多人共享gitea的学习 [ ] typescript [ ] docker: 尝试将区块链后端和代码打包成docker [ ] mongodb [ ] 如何内网穿透 [ ] 如何不用springboot，只用node框架实现现有的后端（Modway.js） [ ] 数据结构和算法的学习 [ ] Redis 和 如何用Lua解释器实现Redis脚本功能","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://arthersun.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"如何使用git进行多人协作","slug":"如何使用git进行多人协作","date":"2021-11-14T07:02:32.000Z","updated":"2021-12-04T08:01:33.350Z","comments":true,"path":"2021/11/14/如何使用git进行多人协作/","link":"","permalink":"https://arthersun.github.io/2021/11/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E8%BF%9B%E8%A1%8C%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/","excerpt":"","text":"起子 github可以建立免费快速的私有云，在github上进行项目工程的团队合作是非常高效的 善用github的分支功能 github的分支功能初识时十分鸡肋，但是用多了之后设计的非常成功。 对于多人合作，我们需要共有一个主分支(master or dev) 我们在主分支上进行代码合并，并作为最终版本展示。 而其他分支作为每个人个人临时的代码池，用于最后的代码合并，合并完进行删除。 流程 1234567891011121314151. 新的开发需求下达2. 对主分支进行pull（设这里的主分支为dev）3. 切换到自己的分支`git checkout -b sun`(-b是新建分支的意思)4. `git rebase dev`5. 进行开发工作6. `git add .`7. `git commit &quot;update:xxx功能&quot;`8. `git push`（远程push）`git push origin master`使用--force可以强制覆盖远程仓库9. 审核员进行审核，审核完成后进行合并10. 然后删除该分支11. 删除本地分支：`git branch -D sun`12. 删除远程分支：`git push origin --delete sun `finished","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://arthersun.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"关于npm和git源和设置代理的一些问题","slug":"关于npm的一些问题","date":"2021-11-14T06:35:45.000Z","updated":"2021-12-04T08:01:14.898Z","comments":true,"path":"2021/11/14/关于npm的一些问题/","link":"","permalink":"https://arthersun.github.io/2021/11/14/%E5%85%B3%E4%BA%8Enpm%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述 在进行npm install时，我电脑上挂了科学上网，导致需要切换代理。而国内的淘宝源也没有办法提速，甚至会导致卡顿，这致使我一直被折磨。 git的情况 这个情况曾经出现在git上，因为当时我的socks5代理为:127.0.0.1:10808，http代理为127.0.0.1:10809 我进行git设置 git设置代理 git config --global http.proxy http://127.0.0.1:10808 git config --global https.proxy http://127.0.0.1:10808 导致无法顺利访问git，错误代码443. 解决方案：我将http代理改为了10809就可以了。 npm的情况 npm更换淘宝源，没有用 npm config set registry https://registry.npm.taobao.org 需要更换代理，和git一样 npm config set proxy http://127.0.0.1:10809","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://arthersun.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"开发","permalink":"https://arthersun.github.io/tags/%E5%BC%80%E5%8F%91/"}]}],"categories":[],"tags":[{"name":"论文","slug":"论文","permalink":"https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"刷题","slug":"刷题","permalink":"https://arthersun.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"项目","slug":"项目","permalink":"https://arthersun.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"区块链","slug":"区块链","permalink":"https://arthersun.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"分布式","slug":"分布式","permalink":"https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"后端","slug":"后端","permalink":"https://arthersun.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"开发","slug":"开发","permalink":"https://arthersun.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://arthersun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"linux","slug":"linux","permalink":"https://arthersun.github.io/tags/linux/"},{"name":"前端","slug":"前端","permalink":"https://arthersun.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}