<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2022-11-12T13:17:39.952Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>便捷版快排</title>
    <link href="https://arthersun.github.io/2022/11/12/%E4%BE%BF%E6%8D%B7%E7%89%88%E5%BF%AB%E6%8E%92/"/>
    <id>https://arthersun.github.io/2022/11/12/%E4%BE%BF%E6%8D%B7%E7%89%88%E5%BF%AB%E6%8E%92/</id>
    <published>2022-11-12T13:16:52.000Z</published>
    <updated>2022-11-12T13:17:39.952Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line">private void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">int temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line">if (start &gt;= end)</span><br><span class="line">return;</span><br><span class="line">int k = arr[start];</span><br><span class="line">int i = start, j = end;</span><br><span class="line">while (i != j) &#123;</span><br><span class="line">while (i &lt; j &amp;&amp; arr[j] &gt;= k)</span><br><span class="line">--j;</span><br><span class="line">swap(arr, i, j);</span><br><span class="line">while (i &lt; j &amp;&amp; arr[i] &lt;= k)</span><br><span class="line">++i;</span><br><span class="line">swap(arr, i, j);</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr, start, i - 1);</span><br><span class="line">quickSort(arr, i + 1, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;5, 2, 6, 9, 1, 3, 4, 8, 7, 10&#125;;</span><br><span class="line">new QuickSort().quickSort(arr, 0, arr.length - 1);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>判断是不是二叉搜索树的后序遍历</title>
    <link href="https://arthersun.github.io/2022/11/12/%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://arthersun.github.io/2022/11/12/%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-11-12T12:53:34.000Z</published>
    <updated>2022-11-12T13:05:31.749Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>输入: [1,6,3,2,5]<br>输出: false</p><p>输入: [1,3,2,6,5]<br>输出: true</p><p>单调栈解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean verifyPostorder(int[] postorder) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int root = Integer.MAX_VALUE;</span><br><span class="line">        for(int i = postorder.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(postorder[i] &gt; root) return false;</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            stack.add(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Krahets</span><br><span class="line">链接：https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solutions/150225/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归+检查的写法:注意，检查指针最后能不能移动到最后面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean verifyPostorder(int[] postorder) &#123;</span><br><span class="line">        return recur(postorder, 0, postorder.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean recur(int[] postorder, int i, int j) &#123;</span><br><span class="line">        if(i &gt;= j) return true;</span><br><span class="line">        int p = i;</span><br><span class="line">        while(postorder[p] &lt; postorder[j]) p++;</span><br><span class="line">        int m = p;</span><br><span class="line">        while(postorder[p] &gt; postorder[j]) p++;</span><br><span class="line">        return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。&lt;/p&gt;
&lt;p&gt;输入: [1,6,3,2,5]&lt;br&gt;
输出: false&lt;/p&gt;
&lt;p&gt;输入: [1,3,2,6,5]&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mac配置vim</title>
    <link href="https://arthersun.github.io/2022/11/12/mac%E9%85%8D%E7%BD%AEvim/"/>
    <id>https://arthersun.github.io/2022/11/12/mac%E9%85%8D%E7%BD%AEvim/</id>
    <published>2022-11-12T02:06:48.000Z</published>
    <updated>2022-11-12T02:10:08.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac如何配置vim"><a class="markdownIt-Anchor" href="#mac如何配置vim"></a> mac如何配置vim</h1><ol><li>由于/usr/share/vim没有权限修改，且chmod +w也显示无法操作，需要将其复制到用户主目录下，这样修改的就是一个用户的vim配置。</li></ol><p>复制的命令行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将全局版vimrc文件复制到用户主目录下做为用户版vimrc：</span><br><span class="line">cp /usr/share/vim/vimrc ~/.vimrc</span><br></pre></td></tr></table></figure><ol start="2"><li>打开~/.vimrc</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&quot;********************************基本设置******************************&quot;</span><br><span class="line">set tabstop=4                &quot; 设置tab键的宽度</span><br><span class="line">set shiftwidth=4             &quot; 换行时行间交错使用4个空格</span><br><span class="line">set autoindent               &quot; 自动对齐</span><br><span class="line">set backspace=2              &quot; 设置退格键可用</span><br><span class="line">set shiftwidth=4      &quot; 自动缩进4空格</span><br><span class="line">set smartindent              &quot; 智能自动缩进</span><br><span class="line">set number                   &quot; 在每一行最前面显示行号</span><br><span class="line">set showmatch                &quot; 高亮显示对应的括号</span><br><span class="line">set mouse=a                  &quot; 启用鼠标</span><br><span class="line">set ruler                    &quot; 在编辑过程中，在右下角显示光标位置的状态行</span><br><span class="line">set cursorline               &quot; 突出显示当前行</span><br><span class="line">set noswapfile               &quot; 设置无交换区文件&quot;</span><br><span class="line">set writebackup              &quot; 设置无备份文件</span><br><span class="line">set nobackup                 &quot; 设置无备份文件</span><br><span class="line">set autochdir                &quot; 设定文件浏览器目录为当前目录</span><br><span class="line">set foldmethod=syntax        &quot; 选择代码折叠类型</span><br><span class="line">set laststatus=2             &quot; 开启状态栏信息</span><br><span class="line">set cmdheight=2              &quot; 命令行的高度，默认为1，这里设为2</span><br><span class="line">set autoread                 &quot; 当文件在外部被修改，自动更新该文件</span><br><span class="line">set autoread                 &quot; 自动检测并加载外部对文件的修改</span><br><span class="line">set autowrite                &quot; 自动检测并加载外部对文件的修改</span><br><span class="line">set showcmd                  &quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来</span><br><span class="line">syntax enable                &quot; 打开语法高亮</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if has(&quot;gui_running&quot;)</span><br><span class="line">    set guioptions+=b        &quot; 显示底部滚动条</span><br><span class="line">    set nowrap               &quot; 设置不自动换行</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot;********************************设置编码*******************************&quot;</span><br><span class="line">&quot; 设置换行编码</span><br><span class="line">set fileformats=unix,dos,mac</span><br><span class="line">&quot; 设置Vim 内部使用的字符编码方式</span><br><span class="line">set encoding=utf-8</span><br><span class="line">&quot; 设置文件编码</span><br><span class="line">if has(&quot;win32&quot;)</span><br><span class="line">set fileencoding=chinese</span><br><span class="line">else</span><br><span class="line">set fileencoding=utf-8</span><br><span class="line">endif</span><br><span class="line">&quot; 解决consle输出乱码</span><br><span class="line">language messages zh_CN.utf-8</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>重启item2或者terminal</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mac如何配置vim&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mac如何配置vim&quot;&gt;&lt;/a&gt; mac如何配置vim&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;由于/usr/share/vim没有权限修改，且chmod +w也显示无法操作，需要</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习linux命令行</title>
    <link href="https://arthersun.github.io/2022/11/12/%E5%AD%A6%E4%B9%A0linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://arthersun.github.io/2022/11/12/%E5%AD%A6%E4%B9%A0linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2022-11-12T01:49:09.000Z</published>
    <updated>2022-11-12T10:00:21.173Z</updated>
    
    <content type="html"><![CDATA[<p>怎么创建一个文件（非目录）？</p><blockquote><p>号可以创建，如果同时创建多个文件，可以使用多个&gt;号。</p></blockquote><hr><p>复制文件：cp 本文件 新文件/路径</p><hr><p>命令行可以用分号隔开写多条命令</p><p>mkdir text1;cd …;mkdir text2</p><hr><p>移动文件：mv 文件 路径</p><hr><p>删除文件：rm 文件</p><hr><p>vim撤销和取消撤销：u Ctrl+r</p><hr><p>创建硬链接:ln 文件名 链接名</p><p>优点：除非删掉所有硬链接和文件，不然不会删掉</p><p>缺点：不能跨磁盘链接</p><hr><p>使用通配符查看文件：ls -l ???.???</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;怎么创建一个文件（非目录）？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;号可以创建，如果同时创建多个文件，可以使用多个&amp;gt;号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;复制文件：cp 本文件 新文件/路径&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;命令行可以用分号隔开写多条命令</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于测开职业生涯规划的一些想法</title>
    <link href="https://arthersun.github.io/2022/11/10/%E5%85%B3%E4%BA%8E%E6%B5%8B%E5%BC%80%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>https://arthersun.github.io/2022/11/10/%E5%85%B3%E4%BA%8E%E6%B5%8B%E5%BC%80%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2022-11-10T12:27:56.000Z</published>
    <updated>2022-11-10T12:31:00.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a class="markdownIt-Anchor" href="#关于"></a> 关于</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于&quot;&gt;&lt;/a&gt; 关于&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重学jvm</title>
    <link href="https://arthersun.github.io/2022/11/10/%E9%87%8D%E5%AD%A6jvm/"/>
    <id>https://arthersun.github.io/2022/11/10/%E9%87%8D%E5%AD%A6jvm/</id>
    <published>2022-11-10T12:27:30.000Z</published>
    <updated>2022-11-13T03:46:35.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重学jvm"><a class="markdownIt-Anchor" href="#重学jvm"></a> 重学jvm</h1><p>Java的类存在哪里？</p><p>误区：常规认为基本数据类型存放在栈中，引用类型存放在堆中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Text&#123;</span><br><span class="line">  int a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的a是存在堆里面的。</p><p>而方法：<br>public void text(){<br>int b = 1;<br>}</p><p>在text局部方法中基本数据类型的变量b是存储在栈中的</p><p>如果你将一个实例变量放在栈内，那么就不存在多个线程访问同一个对象资源了，这显然是不对的，所以实例变量要在堆上创建，但是对于局部变量，是在栈上创建的，调用一次方法创建一个帧，独享一份内存区域，其他的线程是不会访问到该线程的资源，在栈上创建也会减轻GC的压力，随着该方法的结束，帧出栈，相对应的内存消除，这种局部变量占用的内存自然就消失了。</p><hr><p>java中静态方法的作用是什么？</p><ol><li>声明为static的变量实质上是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。</li><li>只会分配一块存储空间，所有此类的对象都可以操控此块存储空间。</li><li>没有创建对象时也可以利用类使用该方法。静态方法可以调用静态方法、静态成员，但不能调用成员方法。</li></ol><hr><p>java静态变量存放在堆还是方法区？</p><ol><li>静态变量是被对象共享的，随着类加载而产生（不用实例化即可访问）</li><li>java8之前存放在方法区</li><li>java8及以后：存放在堆中反射的class对象的尾部</li></ol><hr><p>java栈空间包括哪些内容？</p><p>由一个个栈帧组成</p><ol><li><p>局部变量表：主要存放编译器可知的各种数据类型、对象引用（可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</p></li><li><p>操作数栈：主要是存放方法运行过程中产生的中间变量。</p></li><li><p>动态链接：主要服务一个方法需要调用其他方法的场景。</p></li><li><p>返回地址。</p></li></ol><hr><p>final、finally、finalize的区别？</p><ol><li>修饰变量：</li></ol><p>修饰基本数据类型：这个数据的值在初始化后将不能被改变。</p><p>修饰引用数据类型：引用在初始化后将永远指向一个内存地址，不可修改。里面的值是可以修改的</p><ol start="2"><li><p>final修饰的常量在编译阶段会被放入常量池中。</p></li><li><p>final类：被修饰的类不能被继承，所有方法不能被重写。</p></li></ol><p>try-catch-finally</p><p>finally里面的语句是否一定会被执行？</p><p>如果在try或catch中停止了jvm，则finally不会执行，例如停电。或者使用System.exit(0)可以阻断finally执行。</p><p>finally中的代码会执行，流程为：</p><ol><li><p>先计算返回值，并将返回值存储起来，等待返回</p></li><li><p>执行finally代码块</p></li><li><p>将存储的返回值，返回出去</p></li></ol><p>注：返回值是在finally运算之前就确定了，并且缓存（副本）了，不管finally对该值做任何的改变，返回的值都不会改变(不在finally中return)</p><p>finalize是在java.lang.Object里定义的方法，也就是说每一个对象都有这么一个方法，这个方法在gc启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize了，进而产生问题，因此不推荐使用 finalize 方法。</p><hr><p>java静态变量、代码块、和静态方法的执行顺序是什么？</p><ol><li><p>静态代码块-&gt;构造代码块-&gt;构造函数-&gt;普通代码块</p></li><li><p>父类-&gt;子类</p></li></ol><hr><p>java多态：</p><p>编译时多态：重载，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法</p><p>运行时多态：继承、重写和向上转型</p><p>继承：在多态中必须存在有继承关系的子类和父类</p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能调用父类的方法，又能调用子类的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重学jvm&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重学jvm&quot;&gt;&lt;/a&gt; 重学jvm&lt;/h1&gt;
&lt;p&gt;Java的类存在哪里？&lt;/p&gt;
&lt;p&gt;误区：常规认为基本数据类型存放在栈中，引用类型存放在堆中&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文中期梳理</title>
    <link href="https://arthersun.github.io/2022/11/07/%E8%AE%BA%E6%96%87%E4%B8%AD%E6%9C%9F%E6%A2%B3%E7%90%86/"/>
    <id>https://arthersun.github.io/2022/11/07/%E8%AE%BA%E6%96%87%E4%B8%AD%E6%9C%9F%E6%A2%B3%E7%90%86/</id>
    <published>2022-11-07T08:08:04.000Z</published>
    <updated>2022-11-09T13:40:43.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中期的任务"><a class="markdownIt-Anchor" href="#中期的任务"></a> 中期的任务</h1><ol><li>弄出一个方案创新点，做一部分实验，论文第三章写完</li><li>完成PPT制作</li><li>准备答辩问题</li></ol><p>ps：需要注意的：</p><ol><li>由于论文和答辩的特殊性，需要导师指导，需要预留时间给导师，提前计划给老师</li><li>一定要实事求是，不能操之过急，做了多少说多少，瞎说容易露出马脚</li></ol><h1 id="一些进展的timeline"><a class="markdownIt-Anchor" href="#一些进展的timeline"></a> 一些进展的timeline</h1><p>16:12<br>读一篇区块链云审计的中文论文，弄清楚云审计的过程，大约3小时</p><p>[1]谷天龙. 基于区块链的隐私保护云审计研究[D].天津大学,2020.DOI:10.27356/d.cnki.gtjdu.2020.003033.</p><p>涉及到的比较模糊的概念：<br>云计算、云审计</p><p>云计算</p><p>云计算分为IaaS、PaaS、SaaS<br><img src="/2022/11/07/%E8%AE%BA%E6%96%87%E4%B8%AD%E6%9C%9F%E6%A2%B3%E7%90%86/yun.png" alt="云计算"></p><p>IaaS:硬件、网络<br>PaaS:操作系统 Linux<br>SaaS:一些软件服务</p><p>云审计</p><p>云审计是一种监控通过控制台进行的操作、通过OpenAPI触发的操作、事件下载及转储、事件分析、追踪、告警等的行为</p><p>ps:例如腾讯云的云审计：使用腾讯云云审计（CloudAudit），可以获取您腾讯云账号下 API 调用历史记录，包括通过腾讯云管理控制台，腾讯云 SDK，命令行工具和其他腾讯云服务进行的API调用，监控腾讯云中的任何部署行为。可以确定哪些子用户、协作者使用腾讯云 API 时，从哪个源 IP 地址进行调用，以及何时发生调用。您可以设置多个不同的跟踪集用以跟踪不同的日志，随时控制何时打开和关闭 CloudAudit 日志记录。</p><h4 id="云存储审计和云审计果然不是一个东西老师批评的对"><a class="markdownIt-Anchor" href="#云存储审计和云审计果然不是一个东西老师批评的对"></a> 云存储审计和云审计果然不是一个东西，老师批评的对</h4><hr><p>读一篇云存储审计的论文</p><p>摸鱼了半天</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中期的任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#中期的任务&quot;&gt;&lt;/a&gt; 中期的任务&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;弄出一个方案创新点，做一部分实验，论文第三章写完&lt;/li&gt;
&lt;li&gt;完成PPT制作&lt;/li&gt;
&lt;li&gt;准备答辩问题</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记一次惨痛的面试失败经历</title>
    <link href="https://arthersun.github.io/2022/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%83%A8%E7%97%9B%E7%9A%84%E9%9D%A2%E8%AF%95%E5%A4%B1%E8%B4%A5%E7%BB%8F%E5%8E%86/"/>
    <id>https://arthersun.github.io/2022/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%83%A8%E7%97%9B%E7%9A%84%E9%9D%A2%E8%AF%95%E5%A4%B1%E8%B4%A5%E7%BB%8F%E5%8E%86/</id>
    <published>2022-11-02T14:32:22.000Z</published>
    <updated>2022-11-02T14:37:32.069Z</updated>
    
    <content type="html"><![CDATA[<p>部门：阿里菜鸟</p><p>测开三面</p><p>面试官性别女</p><p>开头抽到简历上不熟的项目，然后我强答了一下，然后被怼</p><p>稍微解释了一下</p><p>第一印象估计极差</p><p>问另一个项目，我心情及其烦躁，脑子已经跟不上了，说得很乱</p><p>又被怼</p><p>“好了，我没有问题了”</p><p>“你有什么想问我的嘛”</p><p>“问问生涯规划”</p><p>拿自身举例，跟我说做人要实诚，做任何工作都要诚实、稳重</p><p>并直接挂了面试流程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;部门：阿里菜鸟&lt;/p&gt;
&lt;p&gt;测开三面&lt;/p&gt;
&lt;p&gt;面试官性别女&lt;/p&gt;
&lt;p&gt;开头抽到简历上不熟的项目，然后我强答了一下，然后被怼&lt;/p&gt;
&lt;p&gt;稍微解释了一下&lt;/p&gt;
&lt;p&gt;第一印象估计极差&lt;/p&gt;
&lt;p&gt;问另一个项目，我心情及其烦躁，脑子已经跟不上了，说得很乱&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2020_Wang_PoRX:IIoT区块链共识的声誉激励方案</title>
    <link href="https://arthersun.github.io/2021/12/09/2020-Wang-%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E6%A1%88/"/>
    <id>https://arthersun.github.io/2021/12/09/2020-Wang-%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E6%A1%88/</id>
    <published>2021-12-08T16:12:33.000Z</published>
    <updated>2021-12-09T15:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="porxiiot区块链共识的声誉激励方案"><a class="markdownIt-Anchor" href="#porxiiot区块链共识的声誉激励方案"></a> PoRX:IIoT区块链共识的声誉激励方案</h3><h4 id="第一章-介绍"><a class="markdownIt-Anchor" href="#第一章-介绍"></a> 第一章 介绍</h4><p>介绍：</p><p>工业物联网（IIoT）是指工业生产中的各种设备，无论是工厂中的机器设备还是汽车和飞机中的发动机，其上安装传感器并连接到无线网络终端以收集和共享数据。目前，由于IIoT系统是一个开放的、分布式的、异构的系统，在IIoT中实现<strong>可信通信</strong>是一个巨大的挑战。区块链技术已成为解决工业物联网合作信任问题的新途径。利用区块链，可以构建<strong>防篡改</strong>系统，作为工业物联网硬件产品从芯片到整个设备的<strong>审计</strong>工具。</p><p>在IIoT中应用区块链技术的主要问题之一是解决<em>共识协议的安全性和效率问题</em>。本文提出了一种信誉机制，以鼓励正常节点和异常节点以良好的方式参与网络协作。为了引导这种行为，提出了一种<strong>基于声誉的激励方法</strong>。在声誉的收益支付函数中设计了奖惩因子。其有效性在于合作行为得到奖励，而非合作行为受到惩罚。</p><p>我们方案的主要优点是，我们基于声誉的激励模块可以在最先进的PoX协议（称为PoRX）上实现，并且可以使PoX协议达到更好的一致状态。因此，它将有利于IIoT与区块链的应用。</p><h5 id="工业物联网应用的例子"><a class="markdownIt-Anchor" href="#工业物联网应用的例子"></a> 工业物联网应用的例子</h5><p>智能电表能在社区本地运行，如果出现电源故障，这些智能电表可以确定故障范围，通过基于区块链的智能合约技术直接与本地变电站通信，并重新规划输电线路。</p><p><a href="https://zh.wikipedia.org/wiki/IOTA_(%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3)">IOTA</a></p><h5 id="工业物联网系统的问题的复述"><a class="markdownIt-Anchor" href="#工业物联网系统的问题的复述"></a> 工业物联网系统的问题的复述</h5><p>由于IIoT本身是一个开放系统，因此允许各种设备加入。一些恶意设备和不诚实设备在加入网络后可能会对IIoT系统的共识协议发起攻击，从而可能破坏IIoT的系统[8]。实际上，<strong>当前的最先进的共识协议没有考虑如何在共识协议中保证节点行为良好</strong>。在IIoT的实际应用中，解决IIoT系统中恶意节点的攻击一直是需要面对的现实问题[9,10]。为了将区块链成功应用于IIoT，构建一个可信、高效的区块链共识协议是一个亟待解决的关键问题。本文针对这些问题，提出了一种激励声誉方案，以激励节点在系统中保持稳定的良好行为。好的行为会得到奖励，坏的行为会受到惩罚。每个节点都有一个具有信誉值的标识。具有较高的信誉价值，会得到更多的合作。虽然声誉价值较低，但很少得到他人的合作。该方案的主要优点是基于声誉的激励模块可以建立在PoX协议的基础上，是一种实用的方法。</p><blockquote><p>缺乏一种奖惩机制</p></blockquote><h4 id="第二章-相关工作"><a class="markdownIt-Anchor" href="#第二章-相关工作"></a> 第二章 相关工作</h4><h5 id="共识协议"><a class="markdownIt-Anchor" href="#共识协议"></a> 共识协议</h5><p>PoW：核心思想是通过节点间计算能力的竞争来分配区块记账权。浪费大量电能</p><p>PoS：PoS的主要思想是，用户在系统中所占的比例与块生成的难度成反比。系统中节点持有的股份越大，他就越容易获胜。</p><h5 id="现有共识协议的问题一不确定性"><a class="markdownIt-Anchor" href="#现有共识协议的问题一不确定性"></a> 现有共识协议的问题一——不确定性</h5><p>几项协商一致的协议都有一个共同的问题，即<strong>协商一致的过程是不确定的</strong>。缺乏共识确定性导致交易确认延迟，这不适用于大多数需要实时确认的实时IIoT系统</p><blockquote><p>比如说比特币（pow）虽说是平均10分钟出一个块，但有可能1分钟出块，也有可能半小时出块，造成不确定性。</p></blockquote><h5 id="现有共识协议的问题二面向加密货币的共识协议不适用于物联网"><a class="markdownIt-Anchor" href="#现有共识协议的问题二面向加密货币的共识协议不适用于物联网"></a> 现有共识协议的问题二——面向加密货币的共识协议不适用于物联网</h5><p>IIoT系统的主要要求是，<strong>应根据以IIoT业务为中心的交易验证规则对交易进行验证</strong>。</p><p>这是一项基本要求，因为IIoT中的每个新事务基本上都独立于以前的事务，<strong>环境或事件的变化会影响设备读数的变化</strong>。因此，我们应该设计物联网交易的验证规则。</p><blockquote><p>BTC：比特币会把未花费的币维护成一个（未花费的交易输出表）UTXO</p></blockquote><p>例如，在智能家居中，<strong>只有当摄像头或任何其他传感器检测到房间中有人时，壁炉才会点亮</strong>。这意味着传感器读数是根据环境背景而不是孤立地进行验证的。</p><h5 id="现有共识协议的问题三分叉"><a class="markdownIt-Anchor" href="#现有共识协议的问题三分叉"></a> 现有共识协议的问题三——分叉</h5><p>共识协议还应具有共识的最终性，以避免出现分歧。此外，Huang[27]提出了一个分析模型来分析共识区块链中的分布式网络分叉概率。</p><h5 id="iiot系统的问题sybil攻击"><a class="markdownIt-Anchor" href="#iiot系统的问题sybil攻击"></a> IIOT系统的问题——Sybil攻击</h5><p>此外，IIoT系统也容易受到物理或网络攻击。最近，一场名为“Mirai”（Sophos裸体安全，2016）[28]的网络攻击感染了大量IIoT设备，包括DVR和CCTV摄像机，并将它们变成僵尸。然后，通过启动数以百万计的DNS查找请求形式的巨大数据流量，这些受损设备用于发起针对DNS服务提供商“DYN”的DDOS攻击。如果使用PoX共识协议，它可以有效抵御此DDOS攻击，但它面临51%的攻击。如果攻击者拥有整个网络一半以上的证明能力，则他可以实施攻击，并且成功的概率非常高。<strong>PoX共识协议也应该对Sybil攻击有效</strong>。</p><h5 id="分布式系统的信誉机制"><a class="markdownIt-Anchor" href="#分布式系统的信誉机制"></a> 分布式系统的信誉机制</h5><p>Gupta等人[29]提出了第一个P2P网络信誉系统。这是一个有效的解决办法。其他研究也对声誉系统做出了贡献，但没有一项是真正的去中心化。</p><p>近年来，区块链技术被关注并用于声誉设计。</p><p>Tavakolifard[30]对分散多代理系统中的信任和声誉进行了建模。</p><p>Yi[31]提出了在比特币上构建不可链接的（Coin Mixing）硬币混合系统的方案。</p><p>作者解释说，网络上的声誉与数字货币具有相同的要求：</p><p>（1）数字货币可以表示为一个数字变量；</p><blockquote><p>也就是说声誉需要被定量。</p></blockquote><p>（2）其价值由每一参与者商定，不可由第三方操纵。系统记录付款期间的交互反馈，将实际信誉的计算留给第三方应用程序。</p><blockquote><p>BTC的币价一直在波动，没有人可以定义BTC的价格。也就是说信誉也不能被强行定价。</p></blockquote><p>Khaqqi[32]提出了一个基于声誉的交易系统，其中声誉表示参与者对减排努力的表现和承诺。采用多准则分析方法对该方案与传统排污权交易方案模型进行比较。</p><p>Schaub等人[33]提出了一种基于区块链的无信任、分散和匿名的电子商务应用声誉系统。系统用Pos链保证声誉系统的共识，同时，它允许客户提交评级和文本审查。</p><p>此外，一些学者利用声誉机制改进区块链[34]。Gai Fangyu等人[35]提出了基于声誉证明的共识协议。该协议纯粹基于声誉激励，完全放弃代币激励。我们认为，其协议的激励机制不够完善，放弃代币激励会导致用户参与共识的动机显著降低。</p><h4 id="第三章-方法"><a class="markdownIt-Anchor" href="#第三章-方法"></a> 第三章 方法</h4><p>在共识层上面加了一层激励（声誉）层</p><p><img src="/2021/12/09/2020-Wang-%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E6%A1%88/image-20211209024205984.png" alt="image-20211209024205984"></p><p><img src="/2021/12/09/2020-Wang-%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E6%A1%88/image-20211209024045107.png" alt="image-20211209024045107"></p><p>输出函数是要满足的目标值，它由经常账户信誉估价师和当前信用度确定。该函数具有当前状态值state和随机nonce值nonce。一旦Hfunction输出小于目标值，则认为矿工获得了该区块记账权。矿工的声誉价值越大，区块产生的概率越大。</p><blockquote><p>实际上就是在原有的难度设置上多加了一层F，原有的可能是H（State,nonce）&lt;D</p></blockquote><p>该函数的设计标准是将当前矿工的帐户信誉值合并到D的难度中。其核心思想是，<strong>最大信誉值（上限）可以抵消20%-40%的难度，最小信誉值（下限）可以提高20%-40%的难度</strong>，</p><h5 id="基于身份的方法"><a class="markdownIt-Anchor" href="#基于身份的方法"></a> 基于身份的方法</h5><p>共识中使用了基于身份的方法。身份是IIoT系统中的一个重要属性。我们设计了共识活动的身份识别方法。其逻辑是建立一个<strong>全局注册表</strong>来存储参与协商一致的节点的标识声明。智能合约的陈述是一个身份所呈现的事实。这些声明由申报人签字，因此可以验证其真实性和完整性。节点调用合约可以在作为验证者参与协商一致之前成功注册。</p><h5 id="注册合约"><a class="markdownIt-Anchor" href="#注册合约"></a> 注册合约</h5><p>智能合约身份注册。在协商一致协议中，注册身份契约用于协助共识协议的运行。其主要任务是注册参与共识节点的身份，并<strong>与真实世界中的身份信息相关联</strong>（？）。登记合约应确保申报人账户的有效性、申报的有效性和申报的唯一性。因为只有一个注册合约，所以所有调用方都可以信任它的逻辑并使用它。身份登记合同的具体任务如下。</p><blockquote><p>与真实世界中身份信息相关联不就失去了匿名性吗</p><p>有点像联盟链的做法</p></blockquote><p>注册：将帐户注册为矿工。验证后，可获得区块生成权，并将账户存储在全局注册账户列表中，返回注册账户列表。</p><p>注销：当用户想要退出共识时，可以取消帐户。注销的帐户被视为无效帐户。它无法参与共识，该帐户将从注册帐户列表中删除。</p><blockquote><p>与BTC、ETH不一样的是，他这里的注册首先需要告知各方，其次也不是匿名</p></blockquote><p>注册时需要确保有一定保证金（用于罚款），注册后账户的声誉设置为初始声誉</p><p>注销时需要确保现有状态（什么状态？）是否小于初始值，如果是的话，将声誉设为0定为注销</p><h5 id="基于身份的方法具体描述"><a class="markdownIt-Anchor" href="#基于身份的方法具体描述"></a> 基于身份的方法具体描述</h5><p>基于身份的方法包括声誉构建、区块链启动过程、竞争周期、激励机制和协议参数更新规则，具体描述如下。</p><p>声誉构建</p><blockquote><p>一个矿工只能有一个账户，这样声誉值的设定才有意义。</p></blockquote><p>区块链启动过程</p><p>因为我们的计划涉及部署身份登记合同，这些合同由矿工操作。存在一个矛盾：<strong>矿工的注册需要合同，而合同的部署需要矿工</strong>。</p><p>设置一个零地址。零地址<strong>无需注册即可拥有区块记帐权限</strong>。当一个新的链（没有矿工，没有合同）需要启动时，开发者或负责人可以先使用零地址作为矿工，将身份注册合同部署到新的链上，然后用户可以正常使用该合同。应该注意的是，所有零地址的目的是处理这些相互矛盾的事情。所有零地址都没有私钥，因此使用此地址挖掘获得的奖励无法撤回。</p><p>竞争周期</p><p>在本文中，我们提出了一种竞争限制，称为竞争周期，它用C_duration表示。一般来说，竞争周期是现在时间之前一定数量的块。例如，当前块之前的100个块可以视为竞争周期。竞争周期根据系统中注册矿工的数量动态确定。建议使用矿工人数的两倍作为竞争周期的值，主要目的是：</p><ol><li>计算指定矿工的采矿难度。<strong>确保高声誉采矿者不能始终主导区块生产的优先级，并增加低声誉和潜在采矿者的机会</strong>。<br>例如，指数基数为2，竞争周期为100，矿工的声誉值为1200，开采1000号区块。如果900号至999号区块之间没有属于矿工的区块，则矿工的可用声誉值为1200。如果其中一个区块是矿工的，则矿工的可用声誉值为1200/2=600</li><li>用于计算矿工的声誉奖惩。声誉激励根据预期产生的区块数量计算，预期产生的区块数量将由竞争周期确定。</li></ol><p>激励机制</p><p>在原始协议中，矿工获得一定数量的代币和交易费，作为成功开采区块的奖励。在与声誉模块的新协议中，奖励还包括声誉奖励。</p><p>规则如下:</p><p>1.如果注册的节点竞争成功生成块，并且该块最终得到确认，则该节点将收到<strong>奖励</strong>，包括声誉和令牌。</p><p>2.声誉会下降。如果注册节点未能在一定时间内生成块，或未能达到自己生成的预期块数，则将对其进行<strong>处罚</strong>。</p><p>更新协议参数的规则</p><p>协议参数包括循环参数和其他参数。周期参数包括竞争周期、奖励周期和惩罚周期。其他参数包括最大预期块生成量、最小预期块生成量、可用声誉衰减基数和声誉难度转换率。</p><p>循环参数由矿工人数决定。由于矿工是动态的，因此需要一个更新周期来更新矿工。注意，在我们的模块中，惩罚周期是很难执行（每次区块链上的区块高度达到惩罚期），立即执行奖励周期（每个生成的区块必须按奖励周期进行奖励）。这里我们假设更新周期等于惩罚周期，即在每个惩罚周期之后，调用矿工注册合同以获得当前矿工编号并更新周期参数以进入下一轮惩罚周期。奖励周期和惩罚周期应<strong>根据竞争周期设置</strong>。如果竞争周期非常大（这是IIoT中的常见场景，系统中有许多矿工），则可以选择竞争周期的一部分作为奖励周期和惩罚周期。相反，如果竞争周期很小（例如在启动阶段），为了避免意外情况，我们可以选择几个竞争周期。</p><p>其他参数为静态设置。</p><p>为了使PoX共识协议在IIoT中得到广泛应用，必须提高PoX协议的安全性。我们提出了一个信誉模块来解决PoX的安全问题。声誉模块将在下一节中详细介绍。</p><h3 id="第四章-实验"><a class="markdownIt-Anchor" href="#第四章-实验"></a> 第四章 实验</h3><p>在以太坊上进行实验，在docker上运行节点</p><h5 id="理想的声誉增长"><a class="markdownIt-Anchor" href="#理想的声誉增长"></a> 理想的声誉增长</h5><p>首先，可以得到最理想条件下矿工的声誉增长曲线，即不包括声誉增长衰减和在一个竞争周期内产生过多区块而导致的声誉惩罚。为了便于观察，所有参数均设置为理想化，竞赛周期设置为0。</p><h5 id="理想的声誉增长-2"><a class="markdownIt-Anchor" href="#理想的声誉增长-2"></a> 理想的声誉增长</h5><p>正常的声誉增长包括声誉奖励衰减和在一个竞争周期内产生的过多区块造成的声誉惩罚。根据模型参数的不同，声誉增长的性能也不同。为了便于观察，参数设置不同。最大声誉的转换率设置为1。我们建立了三个计算能力相同的矿工。初始信誉值分别设置为500、1000和1500。所有三家矿商都能运营良好，并记录声誉价值的增长和产生区块的比例。为了进行比较，我们首先不考虑过多区块导致的声誉报酬和可用声誉的衰减。</p><p><img src="/2021/12/09/2020-Wang-%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E6%A1%88/image-20211209054008697.png" alt="image-20211209054008697"></p><p>信誉值为1500的节点出块率仍占较大比例，但信誉值增长不明显。因此，<strong>信誉值的差距将会缩小</strong>，这将导致信誉较低的节点能够参与共识，但大功率节点成功作恶的概率仍然很大。</p><p><img src="/2021/12/09/2020-Wang-%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E6%A1%88/image-20211209054015000.png" alt="image-20211209054015000"></p><p>实验参数设置的很杂，有种为了故意凸显实验设置的。</p><h5 id="协议安全性分析"><a class="markdownIt-Anchor" href="#协议安全性分析"></a> 协议安全性分析</h5><p>Sybil attack</p><p>非匿名：很少有具有POX共识的区块链能够真正抵御此类攻击，因为区块链的账户是完全匿名的，无法识别。我们提议的声誉模块有身份注册合约，只有注册的账户才有资格参与共识活动。合约保证一个人或一个节点只有一个注册帐户。因此，除非攻击者可以贿赂或窃取多人注册的信息，否则声誉模块可以很好地抵御Sybil攻击。</p><p>思考：</p><p>回到最开始的问题：</p><p>分叉：第3个问题通过不匿名解决了。</p><p>算法中也没有结合环境背景的设置</p><p>不确定性：第一个问题呢？以太坊出块仍然是不确定的。</p><p>Normal Reputation Growth并不能减少贫富差距？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;porxiiot区块链共识的声誉激励方案&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#porxiiot区块链共识的声誉激励方案&quot;&gt;&lt;/a&gt; PoRX:IIoT区块链共识的声誉激励方案&lt;/h3&gt;
&lt;h4 id=&quot;第一章-介绍&quot;&gt;&lt;a c</summary>
      
    
    
    
    
    <category term="论文" scheme="https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode错题本</title>
    <link href="https://arthersun.github.io/2021/12/06/Leetcode%E9%94%99%E9%A2%98%E6%9C%AC/"/>
    <id>https://arthersun.github.io/2021/12/06/Leetcode%E9%94%99%E9%A2%98%E6%9C%AC/</id>
    <published>2021-12-06T15:59:22.000Z</published>
    <updated>2021-12-06T16:15:15.286Z</updated>
    
    <content type="html"><![CDATA[<p>438 滑动窗口题</p><p><img src="/2021/12/06/Leetcode%E9%94%99%E9%A2%98%E6%9C%AC/image-20211207000124073.png" alt="image-20211207000124073"></p><p>在滑动窗口比较时，我把window[c]==need[c]和need.count©换了一个位置，导致了这样的悲剧。</p><p><img src="/2021/12/06/Leetcode%E9%94%99%E9%A2%98%E6%9C%AC/image-20211207001007621.png" alt="image-20211207001007621"></p><blockquote><p>c++ map对象先判断存不存在，再直接引用，否则会直接创建一个map[c]=0</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;438 滑动窗口题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/12/06/Leetcode%E9%94%99%E9%A2%98%E6%9C%AC/image-20211207000124073.png&quot; alt=&quot;image-20211207000124073&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://arthersun.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口题总结</title>
    <link href="https://arthersun.github.io/2021/12/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://arthersun.github.io/2021/12/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-06T12:21:28.000Z</published>
    <updated>2021-12-06T15:59:37.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口算法"><a class="markdownIt-Anchor" href="#滑动窗口算法"></a> 滑动窗口算法</h3><p>这个算法技巧的思路非常简单，就是维护一个窗口，然后不断的滑动，然后更新答案。</p><p>大概的思路模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的时间复杂度为O(N)，比字符串暴力算法高效很多。</p><p>通用的滑动窗口算法框架</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滑动窗口的思路"><a class="markdownIt-Anchor" href="#滑动窗口的思路"></a> 滑动窗口的思路</h4><ol><li><p>我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引<strong>左闭右开</strong>区间[left , right)称为一个窗口。</p></li><li><p>我们先不断地增加right指针扩大窗口[left , right)，直到窗口中的字符串符合要求（包含了T中的所有字符）</p></li><li><p>此时，我们停止增加right，转而不断增加left指针缩小窗口[left , right)，直到窗口中的字符串不再符合要求。同时，每次增加left，我们都要更新一轮结果。</p></li><li><p>重复第2和第3步，直到right到达字符串S的尽头。</p></li></ol><blockquote><p>主要思路：第2步相当于在寻找一个可行解，然后第3步在优化这个可行解，最终找到最优解。</p></blockquote><p>needs和window相当于计数器，分别记录<strong>T</strong>中字符出现次数和<strong>窗口</strong>中字符出现次数。</p><p>可以清晰的看到这个过程：</p><ol><li>初始状态：</li></ol><p><img src="/2021/12/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E6%80%BB%E7%BB%93/image-20211206211954222.png" alt="image-20211206211954222"></p><ol start="2"><li>增加right，直到窗口[left , right)包含了T的所有字符。</li></ol><p><img src="/2021/12/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E6%80%BB%E7%BB%93/image-20211206212312429.png" alt="image-20211206212312429"></p><ol start="3"><li><p>增加left，缩小窗口[left , right]:</p><p><img src="/2021/12/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E6%80%BB%E7%BB%93/image-20211206212349932.png" alt="image-20211206212349932"></p></li></ol><p>直到窗口中的字符串不再符合要求，left不再继续移动：</p><p><img src="/2021/12/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E6%80%BB%E7%BB%93/image-20211206212433460.png" alt="image-20211206212433460"></p><p>之后重复上述过程，先移动right，再移动left… 直到right指针到达字符串S的末端，算法结束。</p><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;滑动窗口算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#滑动窗口算法&quot;&gt;&lt;/a&gt; 滑动窗口算法&lt;/h3&gt;
&lt;p&gt;这个算法技巧的思路非常简单，就是维护一个窗口，然后不断的滑动，然后更新答案。&lt;/p&gt;
&lt;p&gt;大概的思路模板&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://arthersun.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>再学区块链及其应用</title>
    <link href="https://arthersun.github.io/2021/12/06/%E5%86%8D%E5%AD%A6%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://arthersun.github.io/2021/12/06/%E5%86%8D%E5%AD%A6%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2021-12-06T08:50:09.000Z</published>
    <updated>2021-12-09T01:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：<a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=4">区块链技术与应用</a></p><h3 id="04-比特币协议"><a class="markdownIt-Anchor" href="#04-比特币协议"></a> 04-比特币协议</h3><h4 id="区块链结构"><a class="markdownIt-Anchor" href="#区块链结构"></a> 区块链结构</h4><p>BitCoin Script把A的输入和A的输出连在一起，运行一下。</p><p>区块链结构</p><table><thead><tr><th>Block header</th><th>Block Body</th></tr></thead><tbody><tr><td>version</td><td>transaction list</td></tr><tr><td>hash of previous block header</td><td></td></tr><tr><td>Merkel root hash</td><td></td></tr><tr><td>target</td><td></td></tr><tr><td>nonce</td><td></td></tr></tbody></table><blockquote><p>整个块头的hash要小于目标阈值。H(header)≤target</p></blockquote><p>系统中包括全节点和轻节点</p><p>full node = fully validating node</p><p>light node = light with node(只保存区块头的信息，系统中大多数是轻节点)</p><p>轻节点没有参与区块链的构造和维护，它只是利用了区块链的一些信息，做一些查询。</p><h4 id="分布式共识"><a class="markdownIt-Anchor" href="#分布式共识"></a> 分布式共识</h4><p>分布式共识一个简单的例子是一个分布式hash表（distributed hash table）</p><blockquote><p>xiao-&gt;12345</p></blockquote><h5 id="关于分布式共识的不可能结论"><a class="markdownIt-Anchor" href="#关于分布式共识的不可能结论"></a> 关于分布式共识的不可能结论</h5><p>FLP：在一个异步的系统里，网络传输时延没有上限，即使只有一个成员是有问题的，也没有办法达成共识。</p><p>CAP：任何一个分布式系统，一致性，可用性和分区容错性只能满足两个，不可能三个都满足</p><h4 id="比特币中的共识协议"><a class="markdownIt-Anchor" href="#比特币中的共识协议"></a> 比特币中的共识协议</h4><p>membership</p><p>联盟链(例如hyperledger fabric)可从成员进入来限制</p><p>女巫攻击（sybil attack）：产生账户非常多（没用的本地账户）,来投票</p><p>比特币采用工作量证明，寻找nonce值来</p><p>UTXO：未花费的交易输出（unspent transaction output）</p><p>total inputs = total outputs</p><p>transaction-based ledger-基于交易的账本</p><p>第二个激励机制：交易费（transaction fee）</p><p>account-based ledger-基于账户的账本</p><p><strong>将来还要挖多少时间</strong>和<strong>已经挖了多少时间</strong>是没有关系的</p><h4 id="10-btc分叉"><a class="markdownIt-Anchor" href="#10-btc分叉"></a> 10-BTC分叉</h4><hr><p>分为硬分叉和软分叉</p><p>硬分叉，比如调大区块，旧节点不能认同大区块，只能认同原区块，新节点可以认同大区块和原区块，如果旧节点不升级软件，那么可以一直挖下去，造成出现两条链的情况。</p><p>软分叉，比如调小区块，或者重新赋予区块内某一没用过的值，旧节点可以认同，但新节点无法认同，于是旧节点挖出来的区块会一直被废弃，于是被迫升级软件。</p><h4 id="15-以太坊账户"><a class="markdownIt-Anchor" href="#15-以太坊账户"></a> 15-以太坊账户</h4><hr><p>BTC系统没有显式的维护账户的概念，导致BTC系统转出一笔钱，必须全部转出，并且转回给自己账户的另一个地址。</p><p>基于账户的模型(account-based ledger)</p><h5 id="双花攻击和重放攻击"><a class="markdownIt-Anchor" href="#双花攻击和重放攻击"></a> 双花攻击和重放攻击</h5><p>基于UTXO的余额-双花攻击-发钱的人不诚实，想再花一遍</p><p>基于账户的余额-重放攻击-收钱的人不诚实，想再收一遍</p><p>以太坊为了避免重放攻击加了一个转账次数nonce，每转账一次Nonce+1</p><p>以太坊中有两类账户：</p><p>外部（普通）账户：balance nonce</p><p>合约账户：code storage</p><h5 id="为什么不延用比特币的账户模型呢"><a class="markdownIt-Anchor" href="#为什么不延用比特币的账户模型呢"></a> 为什么不延用比特币的账户模型呢</h5><p>用智能合约时的合同纠纷</p><p>交易驱动的状态机</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课程链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1Vt411X7JF?p=4&quot;&gt;区块链技术与应用&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;04-比特币协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#04-</summary>
      
    
    
    
    
    <category term="项目" scheme="https://arthersun.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="区块链" scheme="https://arthersun.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPFS解读</title>
    <link href="https://arthersun.github.io/2021/12/06/IPFS%E8%A7%A3%E8%AF%BB/"/>
    <id>https://arthersun.github.io/2021/12/06/IPFS%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-12-06T02:08:09.000Z</published>
    <updated>2021-12-06T02:46:18.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ipfs解读"><a class="markdownIt-Anchor" href="#ipfs解读"></a> IPFS解读</h3><p>组件：</p><p>BitTorrent</p><p>Kademila DHT</p><p>SFS</p><p>Merkel DAG</p><p>Git</p><p><a href="https://gguoss.github.io/2017/05/28/ipfs/">IPFS白皮书</a></p><p>IPFS能够将网站、应用、文件和各种数据建立在点对点分布式网络上，并建立高效的索引。</p><p>基于位置寻址(Location)</p><p>基于内容寻址(Content )</p><p>Distributed Hash Tables(DHTs)</p><table><thead><tr><th>Key(CID)</th><th>Value(PeerID)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>BitSwap</p><table><thead><tr><th>IPFS Object</th><th></th></tr></thead><tbody><tr><td>Data</td><td>“Hello World”</td></tr><tr><td>Links</td><td>[ ]</td></tr></tbody></table><p>IPFS使用Git的Commit进行版本更新</p><p><img src="/2021/12/06/IPFS%E8%A7%A3%E8%AF%BB/image-20211206103403917.png" alt="image-20211206103403917"></p><p>增加激励机制，主动分发文件</p><p>FileCoin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ipfs解读&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ipfs解读&quot;&gt;&lt;/a&gt; IPFS解读&lt;/h3&gt;
&lt;p&gt;组件：&lt;/p&gt;
&lt;p&gt;BitTorrent&lt;/p&gt;
&lt;p&gt;Kademila DHT&lt;/p&gt;
&lt;p&gt;SFS&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>当区块链遇上分布式系统</title>
    <link href="https://arthersun.github.io/2021/12/05/%E5%BD%93%E5%8C%BA%E5%9D%97%E9%93%BE%E9%81%87%E4%B8%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://arthersun.github.io/2021/12/05/%E5%BD%93%E5%8C%BA%E5%9D%97%E9%93%BE%E9%81%87%E4%B8%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-12-05T03:52:54.000Z</published>
    <updated>2021-12-06T08:48:42.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-huang-当区块链遇上分布式系统"><a class="markdownIt-Anchor" href="#2020-huang-当区块链遇上分布式系统"></a> 2020-Huang-当区块链遇上分布式系统</h2><h4 id="几种分布式区块链系统"><a class="markdownIt-Anchor" href="#几种分布式区块链系统"></a> 几种分布式区块链系统</h4><p>DFS-distributed file systems-分布式文件系统</p><p>P2P distributed file systems-点对点分布式网络</p><blockquote><p>文件系统共享带宽，存储和计算资源，都存在不稳定，缺少审计，缺少激励算法的问题</p></blockquote><p>Inter-Planetary File System（IPFS）星际文件系统</p><blockquote><p>关于IPFS，IPFS是一种旨在创建持久且分布式存储和共享文件的网络传输协议</p><p>在IPFS网络中的节点将构成一个分布式文件系统</p><p>关于IPFS写了另一篇介绍<a href="IPFS%E8%A7%A3%E8%AF%BB.md">IPFS</a></p></blockquote><p>IPFS和Swarm整合了区块链系统，提出了有效的激励和安全保证，但是其可扩展性和隐私性也限制了新一代DFS的发展。</p><h4 id="集中式主网的分布式激励机制"><a class="markdownIt-Anchor" href="#集中式主网的分布式激励机制"></a> 集中式主网的分布式激励机制</h4><p>BitTorrent可以共享带宽，存储和计算资源，天然缺少激励机制</p><p>现在的bt系统一般通过分享率、上传量、H&amp;R积分等来设计激励机制，例如</p><p><img src="/2021/12/05/%E5%BD%93%E5%8C%BA%E5%9D%97%E9%93%BE%E9%81%87%E4%B8%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20211206112206290.png" alt="image-20211206112206290"></p><p><img src="/2021/12/05/%E5%BD%93%E5%8C%BA%E5%9D%97%E9%93%BE%E9%81%87%E4%B8%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20211206112646628.png" alt="image-20211206112646628"></p><p>上述指标达到一定时，就可以升级然后获得更多权限。</p><p><img src="/2021/12/05/%E5%BD%93%E5%8C%BA%E5%9D%97%E9%93%BE%E9%81%87%E4%B8%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20211206112748204.png" alt="image-20211206112748204"></p><p>这种激励机制有效，因为主网站中心化，也便于国家监管，但是正是因为中心化，所以容易被查封，一旦主网站被调查停止服务，用户将无法查找下载种子文件、上传文件；而且用户需要在网站上留存用户信息，并没有做到隐私保护。</p><h4 id="基于区块链的分布式激励机制设计"><a class="markdownIt-Anchor" href="#基于区块链的分布式激励机制设计"></a> 基于区块链的分布式激励机制设计</h4><p>区块链为什么适合被设计激励机制？</p><p>区块链系统会设计一种虚拟货币，当参与人数够多这种虚拟货币就会被广泛认可，甚至可以兑换法币（比特币、以太坊）。</p><p>区块链系统会通过设计好的机制（比特币），或者提供透明的<strong>智能合约</strong>供人编写（以太坊）来分发或交易这些虚拟货币。</p><p>此外，区块链系统天然自带<strong>出块有奖励</strong>。</p><p>下面分布式系统通过集成相应的区块链来保证激励的进行。</p><table><thead><tr><th>IPFS</th><th>Swarm</th><th>Storj</th></tr></thead><tbody><tr><td>FileCoin</td><td>以太坊</td><td>Metadisk</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2020-huang-当区块链遇上分布式系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2020-huang-当区块链遇上分布式系统&quot;&gt;&lt;/a&gt; 2020-Huang-当区块链遇上分布式系统&lt;/h2&gt;
&lt;h4 id=&quot;几种分布式区块</summary>
      
    
    
    
    
    <category term="论文" scheme="https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="分布式" scheme="https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="区块链" scheme="https://arthersun.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>page</title>
    <link href="https://arthersun.github.io/2021/12/04/draft/Java%E9%A1%B9%E7%9B%AE%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"/>
    <id>https://arthersun.github.io/2021/12/04/draft/Java%E9%A1%B9%E7%9B%AE%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</id>
    <published>2021-12-04T07:40:00.000Z</published>
    <updated>2021-12-04T08:03:51.776Z</updated>
    
    
    
    
    
    <category term="后端" scheme="https://arthersun.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="开发" scheme="https://arthersun.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习</title>
    <link href="https://arthersun.github.io/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/"/>
    <id>https://arthersun.github.io/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-12-01T02:05:30.000Z</published>
    <updated>2021-12-04T08:03:21.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>k8s前世今生</p></blockquote><p>Google 10年容器化基础架构<br>特点：<br>轻量级：消耗资源少<br>开源<br>弹性伸缩<br>负载均衡：IPVS</p><p>适合人群：软件工程师 测试工程师 运维工程师 软件架构师 项目经理</p><blockquote><p>知识图谱</p></blockquote><p>介绍说明： 前世今生 Kubernetes框架 kubernetes关键字含义</p><p>基础概念：什么是Pod（最小管理单元）  控制器类型  k8s 网络通讯模式</p><p>kubernetes: 构建k8s集群</p><p>资源清单：资源   掌握资源清单的语法   编写Pod    掌握Pod的生命周期</p><p>Pod控制器：掌握各种控制器的特点以及使用定义方式</p><p>服务发现：掌握SVC原理及其构建方式</p><p>存储：掌握多种存储类型的特点，并且能够在不同环境中选择合适的存储方案</p><p>调度器：掌握调度器原理  能够根据要求把Pod定义到想要的节点运行</p><p>安全：集群的认证  鉴权  访问控制  原理及其流程</p><p>HELM：等于Linux中的Yum管理器   掌握HELM原理   HELM模板自定义   HELM部署一些常用插件</p><p>运维：修改Kubeadm达到证书可用期限为10年   能够构建高可用的Kubernetes集群</p><p>服务分类</p><p>​有状态服务：DBMS</p><p>​无状态服务：LVS  APACHE</p><p>高可用集群副本数据最好是&gt;=3 奇数个</p><blockquote><p>主要组件</p></blockquote><p>APISERVER：所有服务访问统一入口</p><p>ControllerManager：维持副本期望数目</p><p>Scheduler：负责介绍任务，选择合适的节点进行分配任务</p><p>ETCD：键值对数据库，存储k8s集群所有重要信息（持久化）</p><p><img src="/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/image-20211203185317526.png" alt></p><p>Kubelet：直接跟容器引擎交互实现容器的声明周期管理</p><p>Kube-proxy：负责写入规则至IPTABLES 、IPVS实现服务</p><p>COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析</p><p>DASHBOARD：给k8s集群提供一个B/S结构访问体系</p><p>INGRESS  CONTROLLER：官方只能实现四层代理，INGRESS可以实现七层代理</p><p>FEDETATION：提供一个可以跨集群中心多k8s统一管理功能</p><p>PROMETHEUS：提供k8s集群的监控能力</p><p>ELK：提供k8s集群日志统一分析接入平台</p><blockquote><p>k8s基础功能</p></blockquote><ol><li>Pod概念<ul><li>自主式Pod</li><li>控制器管理的Pod</li></ul></li><li>网络通讯方式</li></ol><p>在同一个Pod里，端口是一样的。既共享网络，又共享存储卷。</p><blockquote><p>ReplicaSet与Deployment</p></blockquote><p>ReplicationController用来确保容器应用的副本数始终保持在用户定义的副本数。即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收。在新版本的Kubernetes中建议使用ReplicaSet来取代ReplicationController</p><p>ReplicaSet，跟ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector</p><p>虽然ReplicaSet可以独立使用，但一般还是建议使用Deployment来自动管理ReplicaSet，这样就无需担心跟其他机制的不兼容问题（比如ReplicaSet不支持rolling-update 但Deployment支持）</p><blockquote><p>HPA: Horizontal Pod Autoscaling</p></blockquote><p>Horizontal Pod Autoscaling仅适用于Deployment和ReplicaSet，在v1版本中仅支持根据Pod的CPU利用率扩容，在v1alpha版本中，支持根据内存和用户自定义的metric扩缩容</p><blockquote><p>StatefullSet</p></blockquote><p>StatefullSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括：</p><p>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</p><p>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于headless Service(即没有Cluster IP的Service)来实现</p><p>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序一次进行（即从0到N-1,在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现</p><p>有序收缩，有序删除（即从N-1到0）</p><blockquote><p>DeamonSet</p></blockquote><p>DeamonSet确保全部（或者一些）Node上运行一个Pod的副本，当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收。删除DaemonSet将会删除它创建的所有Pod。</p><p>使用DaemonSet的一些典型用法：</p><ul><li>运行集群存储daemon，例如每个Node上运行glusterd、ceph</li><li>在每个Node上运行日志手机daemon，例如fluentd、logstash</li><li>在每个Node上运行监控daemon，例如Prometheus Node Exporter</li></ul><blockquote><p>Job，Cronjob</p></blockquote><p>Job负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</p><p>Cron Job管理基于时间的Job，即</p><ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul><p><img src="/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/image-20211203202022302.png" alt="image-20211203202022302"></p><p>多服务之间的交互方式</p><p><img src="/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/image-20211203203526208.png" alt="image-20211203203526208"></p><blockquote><p>网络通讯方式</p></blockquote><p>Kubernetes的网络模型假定了所有Pod都在一个可以直接联通的扁平的网络空间中，这在GCE（Google Compute Engine）里面是现成的网络模型，Kubernetes假定这个网络已经存在。</p><p>而在私有云里搭建Kubernetes集群，就不能假定这个网络已经存在了，我们需要自己实现这个网络假设，将不同节点上的Docker容器之间的互相访问先打通，然后运行Kubernetes</p><p>同一个Pod内的多个容器之间：localhost</p><p>各Pod之间的通讯：Overlay Network</p><p>Pod和Service之间的通讯，各节点的Iptables规则</p><blockquote><p>Overlay Network怎么实现</p></blockquote><p>Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。而且它还能在这些IP地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。</p><h4 id="flannel怎么运行"><a class="markdownIt-Anchor" href="#flannel怎么运行"></a> Flannel怎么运行</h4><p><img src="/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/image-20211203204451842.png" alt="image-20211203204451842"></p><h4 id="etcd和flannel的关系"><a class="markdownIt-Anchor" href="#etcd和flannel的关系"></a> ETCD和Flannel的关系</h4><p>ETCD给Flannel提供说明：</p><ul><li>存储管理Flannel可分配的IP地址段资源</li><li>监控ETCD中每个Pod的实际地址，并在内存中建立维护Pod节点路由表</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;k8s前世今生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Google 10年容器化基础架构&lt;br&gt;
特点：&lt;br&gt;
轻量级：消耗资源少&lt;br&gt;
开源&lt;br&gt;
弹性伸缩&lt;br&gt;
负载均衡：IPVS&lt;/p&gt;
&lt;p&gt;适合人群：软件工程师 测试工程师 运</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://arthersun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>默克尔树</title>
    <link href="https://arthersun.github.io/2021/11/22/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/"/>
    <id>https://arthersun.github.io/2021/11/22/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/</id>
    <published>2021-11-22T14:24:43.000Z</published>
    <updated>2021-12-04T07:58:11.530Z</updated>
    
    <content type="html"><![CDATA[<h1>Merkle 树结构</h1><p><a href="https://en.wikipedia.org/wiki/Merkle_tree">默克尔树</a>（又叫哈希树）是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。默克尔树最早由 Merkle Ralf 在 1980 年提出，曾广泛用于文件系统和 P2P 系统中。</p><p>其主要特点为：</p><ul><li>最下面的叶节点包含存储数据或其哈希值。</li><li>非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。</li></ul><p>进一步地，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点的内容的哈希值。</p><p>默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。</p><p>目前，默克尔树的典型应用场景包括如下几种。</p><h2 id="证明某个集合中存在或不存在某个元素"><a class="markdownIt-Anchor" href="#证明某个集合中存在或不存在某个元素"></a> 证明某个集合中存在或不存在某个元素</h2><p>通过构建集合的默克尔树，并提供该元素各级兄弟节点中的 Hash 值，可以不暴露集合完整内容而证明某元素存在。</p><p>另外，对于可以进行排序的集合，可以将不存在元素的位置用空值代替，以此构建稀疏默克尔树（Sparse Merkle Tree）。该结构可以证明某个集合中不包括指定元素。</p><h2 id="快速比较大量数据"><a class="markdownIt-Anchor" href="#快速比较大量数据"></a> 快速比较大量数据</h2><p>对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着所代表的两组数据必然相同。否则，必然不同。</p><p>由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。</p><h2 id="快速定位修改"><a class="markdownIt-Anchor" href="#快速定位修改"></a> 快速定位修改</h2><p>以下图为例，基于数据 D0……D3 构造默克尔树，如果 D1 中数据被修改，会影响到 N1，N4 和 Root。</p><p><img src="/2021/11/22/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/1.png" alt="img"></p><p>Merkle 树示例</p><p>因此，一旦发现某个节点如 Root 的数值发生变化，沿着 Root --&gt; N4 --&gt; N1，最多通过 O(lgN) 时间即可快速定位到实际发生改变的数据块 D1。</p><h2 id="零知识证明"><a class="markdownIt-Anchor" href="#零知识证明"></a> 零知识证明</h2><p>仍以上图为例，如何向他人证明拥有某个数据 D0 而不暴露其它信息。挑战者提供随机数据 D1，D2 和 D3，或由证明人生成（需要加入特定信息避免被人复用证明过程）。</p><p>证明人构造如图所示的默克尔树，公布 N1，N5，Root。验证者自行计算 Root 值，验证是否跟提供值一致，即可很容易检测 D0 存在。整个过程中验证者无法获知与 D0 相关的额外信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Merkle 树结构&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot;&gt;默克尔树&lt;/a&gt;（又叫哈希树）是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。默克尔树最早由 Merkle R</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://arthersun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="论文" scheme="https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>11_20_项目组log_包括后几个月参与的任务</title>
    <link href="https://arthersun.github.io/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%BB%84log/"/>
    <id>https://arthersun.github.io/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%BB%84log/</id>
    <published>2021-11-20T02:27:34.000Z</published>
    <updated>2021-12-04T08:02:02.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间与实习时间</p></blockquote><p>4月份中期，整个项目3个月内干完</p><blockquote><p>参与的集成任务</p></blockquote><p>2月20号在corda上集成多对多拍卖<br>1月10号在corda上集成条件隐私保护<br>12月11日之前给出基本的激励智能合约机制的实现，到1月15日之前设计一个高级版的区块链的激励机制</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;时间与实习时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4月份中期，整个项目3个月内干完&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参与的集成任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2月20号在corda上集成多对多拍卖&lt;br&gt;
1月10号</summary>
      
    
    
    
    
    <category term="项目" scheme="https://arthersun.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="https://arthersun.github.io/2021/11/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://arthersun.github.io/2021/11/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-11-19T13:40:08.000Z</published>
    <updated>2021-12-04T08:03:37.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>linux怎么查询端口号</p></blockquote><p>lsof -i:xxx (xxx是网络号)</p><blockquote><p>linux怎么杀死以PID为名的进程</p></blockquote><p>kill -9 PID</p><blockquote><p>linux怎么输出全局变量名</p></blockquote><p>echo $PATH</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;linux怎么查询端口号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;lsof -i:xxx (xxx是网络号)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;linux怎么杀死以PID为名的进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;kill -9 </summary>
      
    
    
    
    
    <category term="linux" scheme="https://arthersun.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>开题要点</title>
    <link href="https://arthersun.github.io/2021/11/18/%E5%BC%80%E9%A2%98%E8%A6%81%E7%82%B9/"/>
    <id>https://arthersun.github.io/2021/11/18/%E5%BC%80%E9%A2%98%E8%A6%81%E7%82%B9/</id>
    <published>2021-11-18T02:49:42.000Z</published>
    <updated>2021-12-04T08:01:21.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开题报告</p></blockquote><p>题目：落实到方法，</p><p>解决问题 --&gt; 说人家的方法有问题<br>用人家的方法-&gt;说人家的方法好-&gt;可以为本文在xx场景下提供选择。</p><blockquote><p>问题</p></blockquote><p>干的事和问题不是同一个东西</p><p>设计算法的难点在哪</p><blockquote><p>3.1研究方法</p></blockquote><p>理论研究<br>实验<br>数据</p><blockquote><p>3.2技术路线</p></blockquote><p>针对本文的三个研究内容，分别阐述技术路线，具体如下。</p><blockquote><p>3.3可行性分析</p></blockquote><p>1.研究经验可借鉴<br>2.数据条件具备<br>3.实验环境具备<br>4.理论研究能力具备<br>5.实验能力具备<br>6.技术路线可行</p><blockquote><p>PPT</p></blockquote><p>参考文献不用写全名，写是哪个期刊上就行</p><p>研究现状能说清楚就不要贴图<br>从别人的论文中找现状的证据贴在PPT中</p><p>做case分析</p><p>根据产出主要实现哪两个难点，PPT有图放图，文档不用画。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开题报告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目：落实到方法，&lt;/p&gt;
&lt;p&gt;解决问题 --&amp;gt; 说人家的方法有问题&lt;br&gt;
用人家的方法-&amp;gt;说人家的方法好-&amp;gt;可以为本文在xx场景下提供选择。&lt;/p&gt;
&lt;blockquote</summary>
      
    
    
    
    
    <category term="论文" scheme="https://arthersun.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
</feed>
