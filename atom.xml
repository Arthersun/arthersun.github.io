<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2023-03-09T03:17:29.984Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何激活一个pd虚拟机中的windows客户端</title>
    <link href="https://arthersun.github.io/2023/03/09/%E5%A6%82%E4%BD%95%E6%BF%80%E6%B4%BB%E4%B8%80%E4%B8%AApd%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84windows%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://arthersun.github.io/2023/03/09/%E5%A6%82%E4%BD%95%E6%BF%80%E6%B4%BB%E4%B8%80%E4%B8%AApd%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84windows%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2023-03-09T03:14:11.000Z</published>
    <updated>2023-03-09T03:17:29.984Z</updated>
    
    <content type="html"><![CDATA[<p>下载这个链接<br><a href="https://lark-assets-prod-aliyun.oss-cn-hangzhou.aliyuncs.com/yuque/0/2020/zip/1276107/1590561456491-7cf5bf3a-fb5c-447a-8320-05251c2059b0.zip?OSSAccessKeyId=LTAI4GGhPJmQ4HWCmhDAn4F5&amp;Expires=1678333483&amp;Signature=AjQxuh0qbJAPxSfJyVZJ272y2aw%3D&amp;response-content-disposition=attachment%3Bfilename*%3DUTF-8%27%27W10%25E6%2595%25B0%25E5%25AD%2597%25E8%25AE%25B8%25E5%258F%25AF.zip">win10数字许可</a></p><p>然后点击 <strong>安装</strong> 和 <strong>激活</strong> 就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下载这个链接&lt;br&gt;
&lt;a href=&quot;https://lark-assets-prod-aliyun.oss-cn-hangzhou.aliyuncs.com/yuque/0/2020/zip/1276107/1590561456491-7cf5bf3a-fb5c-447</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何写一个corda flow</title>
    <link href="https://arthersun.github.io/2023/02/19/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAcorda-flow/"/>
    <id>https://arthersun.github.io/2023/02/19/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAcorda-flow/</id>
    <published>2023-02-19T10:59:55.000Z</published>
    <updated>2023-02-19T23:48:49.934Z</updated>
    
    <content type="html"><![CDATA[<p>大部分的智能合约平台是用消息广播的形式来传播数据或者小道消息网络来共享数据，</p><p>Gossip协议是流行病协议，是那种把消息传播到附近的几个点然后最终扩散到全体区块链的协议，符合最终一致性</p><p>也就是说corda可以决定什么时候和谁交流什么东西</p><p>Steps:</p><ol><li>Alice创建一个新的交易请求并且对它签名</li><li>Alice发送请求和签名到Bob</li><li>Bob检查请求，验证并对它签名</li><li>Bob发回交易和签名到Alice</li></ol><p>编写flow主要把流程写在call里面</p><p>@Suspendable非常重要，因为它会把call变成一个no-breaking，不加的话会等待另一个节点返回，占用线程池的资源</p><p>@InitiatingFlow是说明这个flow是可以直接触发的，@InitiatedBy是说明那个流程是不可以直接触发的</p><p>@StartableByRPC是说可以用rpc直接触发这个flow</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大部分的智能合约平台是用消息广播的形式来传播数据或者小道消息网络来共享数据，&lt;/p&gt;
&lt;p&gt;Gossip协议是流行病协议，是那种把消息传播到附近的几个点然后最终扩散到全体区块链的协议，符合最终一致性&lt;/p&gt;
&lt;p&gt;也就是说corda可以决定什么时候和谁交流什么东西&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何写一个corda contract</title>
    <link href="https://arthersun.github.io/2023/02/19/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAcorda-contract/"/>
    <id>https://arthersun.github.io/2023/02/19/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAcorda-contract/</id>
    <published>2023-02-19T10:26:20.000Z</published>
    <updated>2023-02-19T11:00:11.311Z</updated>
    
    <content type="html"><![CDATA[<p>利用Transaction打包Input、Output两种State，以Flow为媒介进行多方验证及签名收集实现账本的更新</p><p>但是只有两种State是无法标明数据的操作想法，于是使用Command来标明</p><hr><p>后来发现不重要</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;利用Transaction打包Input、Output两种State，以Flow为媒介进行多方验证及签名收集实现账本的更新&lt;/p&gt;
&lt;p&gt;但是只有两种State是无法标明数据的操作想法，于是使用Command来标明&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;后来发现不重要&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>corda几种state的区别</title>
    <link href="https://arthersun.github.io/2023/02/19/corda%E5%87%A0%E7%A7%8Dstate%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2023/02/19/corda%E5%87%A0%E7%A7%8Dstate%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-02-19T03:02:18.000Z</published>
    <updated>2023-02-19T10:26:01.886Z</updated>
    
    <content type="html"><![CDATA[<p>也可以用corda建立一个传统区块链的网络</p><p>你所写的state要implements这个state</p><p>participants代表你所写的state，如果state创建或者修改，那么所有在participants的对象都会被通知到</p><p>实现一个ContractState接口就是一个最简单且好的State</p><p>这个房子被拆掉的话，owner也不会知道，所以需要在participant加入东西</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也可以用corda建立一个传统区块链的网络&lt;/p&gt;
&lt;p&gt;你所写的state要implements这个state&lt;/p&gt;
&lt;p&gt;participants代表你所写的state，如果state创建或者修改，那么所有在participants的对象都会被通知到&lt;/p&gt;
&lt;p&gt;实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Field userMapper inUserServiceImpl required a bean of type xxxMapper that could not be found</title>
    <link href="https://arthersun.github.io/2023/02/19/Field-userMapper-inUserServiceImpl-required-a-bean-of-type-xxxMapper-that-could-not-be-found/"/>
    <id>https://arthersun.github.io/2023/02/19/Field-userMapper-inUserServiceImpl-required-a-bean-of-type-xxxMapper-that-could-not-be-found/</id>
    <published>2023-02-19T02:54:58.000Z</published>
    <updated>2023-02-19T02:59:14.924Z</updated>
    
    <content type="html"><![CDATA[<p>网上的一些解决办法用处不大，发现其实是<br>导入mybatis包的错误</p><p>之前导入的包是：</p><p><code>org.mybatis:mybatis:3.5.11”</code></p><p>改成</p><p><code>compile(&quot;org.mybatis.spring.boot:mybatis-spring-boot-starter:1.3.2”)</code></p><p>就好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网上的一些解决办法用处不大，发现其实是&lt;br&gt;
导入mybatis包的错误&lt;/p&gt;
&lt;p&gt;之前导入的包是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.mybatis:mybatis:3.5.11”&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;p&gt;&lt;code&gt;compile(&amp;quo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>同态加密</title>
    <link href="https://arthersun.github.io/2023/01/06/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    <id>https://arthersun.github.io/2023/01/06/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/</id>
    <published>2023-01-05T17:06:41.000Z</published>
    <updated>2023-01-05T17:06:41.631Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>解决了一个很久没解决的bug</title>
    <link href="https://arthersun.github.io/2022/12/29/%E8%A7%A3%E5%86%B3%E4%BA%86%E4%B8%80%E4%B8%AA%E5%BE%88%E4%B9%85%E6%B2%A1%E8%A7%A3%E5%86%B3%E7%9A%84bug/"/>
    <id>https://arthersun.github.io/2022/12/29/%E8%A7%A3%E5%86%B3%E4%BA%86%E4%B8%80%E4%B8%AA%E5%BE%88%E4%B9%85%E6%B2%A1%E8%A7%A3%E5%86%B3%E7%9A%84bug/</id>
    <published>2022-12-28T17:12:44.000Z</published>
    <updated>2022-12-31T16:00:32.812Z</updated>
    
    <content type="html"><![CDATA[<p>##概述</p><p>通过提前调用getVaultFilters方法解决了/vault-query接口在不调用/vault-filter接口失效的问题，同时在corda/node-server库提了pr</p><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>项目中使用一个开源区块链浏览器去查看节点的state（可以理解为区块链节点逻辑存储上的数据）</p><p>我们通过使用/vault-query去获取所有state，这个接口有一个filter参数，其中有一个字段叫stateTypes，如果这个字段为空时，可以查到数据；如果不为空，则显示查到数据为null。</p><h2 id="发现问题"><a class="markdownIt-Anchor" href="#发现问题"></a> 发现问题</h2><p>发现代码中使用contractStateClassMap去获取类，这个hashmap的key是一个string, 因为filter的stateTypes是一个string，value对应的是一个Class，获取对应string的同名的class，然后从中去筛选出来这个相应的class。</p><p>getVaultFilters()方法专门先读一遍区块链节点数据库中的数据，不同功能的数据是不一样的，然后把里面的所有的filter全部都装进这个hashmap里面。</p><p>但是这个方法只有在调用/vault-filter接口才被调用。</p><p>导致不调这个方法直接调hashmap的话为空</p><p>此外如果不使用statetype这个过滤字段的话，是能够成功返回数据的，因为hashmap为空不影响</p><p>但是如果statetype不为空，则会显示查到的数据为null</p><h2 id="解决问题"><a class="markdownIt-Anchor" href="#解决问题"></a> 解决问题</h2><p>在hashmap添加判断，如果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##概述&lt;/p&gt;
&lt;p&gt;通过提前调用getVaultFilters方法解决了/vault-query接口在不调用/vault-filter接口失效的问题，同时在corda/node-server库提了pr&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>类加载和双亲委派机制</title>
    <link href="https://arthersun.github.io/2022/12/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>https://arthersun.github.io/2022/12/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-14T02:57:48.000Z</published>
    <updated>2022-12-14T13:15:14.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a class="markdownIt-Anchor" href="#类加载"></a> 类加载</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类加载&quot;&gt;&lt;/a&gt; 类加载&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://arthersun.github.io/2022/12/14/Mybatis-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/12/14/Mybatis-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-12-13T17:03:40.000Z</published>
    <updated>2022-12-13T17:12:08.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-mybatis井号与的区别"><a class="markdownIt-Anchor" href="#mysql-mybatis井号与的区别"></a> mysql Mybatis井号#与$的区别</h1><p>mybatis中使用ParameterType向sql语句传参，在sql语句中引用这些参数的时候，有两种方式：#parameterName, $parameterName。</p><p>1， #是一个占位符，$是拼接符。</p><p>#是一个占位符，$是拼接符。</p><p>（1）使用#parameterName方式引用参数的时候，Mybatis会把传入的参数当成是一个字符串，自动添加双引号。</p><p>（2）使用$parameterName引用参数时，不做任何处理，直接将值拼接在sql语句中。</p><p>2，使用 # 能够防止sql注入，$不能避免注入攻击。</p><p>#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译。</p><p>3 ，总结</p><p>建议使用# 。</p><h1 id="预编译"><a class="markdownIt-Anchor" href="#预编译"></a> $ 预编译</h1><p>预编译就是将#{}替换成？占位符，然后在执行时替换成实际传入的user_id值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10:27:20.247 [main] DEBUG william.mybatis.quickstart.mapper.UserMapper.selectById - ==&gt;  Preparing: select id, user_name from t_user where id = ? </span><br><span class="line">10:27:20.285 [main] DEBUG william.mybatis.quickstart.mapper.UserMapper.selectById - ==&gt; Parameters: 1(Long)</span><br></pre></td></tr></table></figure><p>因为&quot;#{}&quot;会在传入的值两端加上单引号，所以可以很大程度上防止SQL注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Mybatis框架下易产生SQL注入漏洞的情况主要分为以下三种：</span><br><span class="line"></span><br><span class="line">1、模糊查询</span><br><span class="line"></span><br><span class="line">Select * from news where title like ‘%#&#123;title&#125;%’</span><br><span class="line"></span><br><span class="line">在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</span><br><span class="line"></span><br><span class="line">正确写法：</span><br><span class="line">select * from news where tile like concat(‘%’,#&#123;title&#125;, ‘%’)</span><br><span class="line"></span><br><span class="line">2、in 之后的多个参数</span><br><span class="line"></span><br><span class="line">in之后多个id查询时使用# 同样会报错，</span><br><span class="line"></span><br><span class="line">Select * from news where id in (#&#123;ids&#125;)</span><br><span class="line"></span><br><span class="line">正确用法为使用foreach，而不是将#替换为$</span><br><span class="line"></span><br><span class="line">id in</span><br><span class="line">&lt;foreach collection=&quot;ids&quot; item=&quot;item&quot; open=&quot;(&quot;separatosr=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">#&#123;ids&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">3、order by 之后</span><br><span class="line"></span><br><span class="line">这种场景应当在Java层面做映射，设置一个字段/表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面。需要注意的是在mybatis-generator自动生成的SQL语句中，order by使用的也是$，而like和in没有问题。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql-mybatis井号与的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mysql-mybatis井号与的区别&quot;&gt;&lt;/a&gt; mysql Mybatis井号#与$的区别&lt;/h1&gt;
&lt;p&gt;mybatis中使用Parameter</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redo log和Binlog</title>
    <link href="https://arthersun.github.io/2022/12/13/Redo-log%E5%92%8CBinlog/"/>
    <id>https://arthersun.github.io/2022/12/13/Redo-log%E5%92%8CBinlog/</id>
    <published>2022-12-13T14:42:18.000Z</published>
    <updated>2022-12-13T17:03:19.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redo-log和binlog的不同"><a class="markdownIt-Anchor" href="#redo-log和binlog的不同"></a> Redo log和Binlog的不同</h1><ol><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><h1 id="redo_log设置"><a class="markdownIt-Anchor" href="#redo_log设置"></a> redo_log设置</h1><ol><li><p>redo log 用于保证 crash-safe 能力。</p></li><li><p>innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p></li><li><p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证MySQL 异常重启之后 binlog 不丢失。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redo-log和binlog的不同&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redo-log和binlog的不同&quot;&gt;&lt;/a&gt; Redo log和Binlog的不同&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;redo log 是 Inn</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>抽象类和接口</title>
    <link href="https://arthersun.github.io/2022/12/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://arthersun.github.io/2022/12/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-12-13T10:47:50.000Z</published>
    <updated>2022-12-13T14:42:03.466Z</updated>
    
    <content type="html"><![CDATA[<p>普通类：只有具体的实现</p><p>抽象类：具体实现和规范（抽象方法）都有</p><p>接口：只有规范</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;普通类：只有具体的实现&lt;/p&gt;
&lt;p&gt;抽象类：具体实现和规范（抽象方法）都有&lt;/p&gt;
&lt;p&gt;接口：只有规范&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://arthersun.github.io/2022/12/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://arthersun.github.io/2022/12/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2022-12-12T16:23:12.000Z</published>
    <updated>2022-12-12T17:44:13.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis持久化"><a class="markdownIt-Anchor" href="#redis持久化"></a> Redis持久化</h1><ol><li>RDB</li></ol><p>每间隔一段时间就将内存中的数据集快照写入磁盘，即Snapshot快照，恢复时是将快照文件直接读到内存里。</p><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>适合大规模数据，但是可能丢失最后一次数据</p><ol start="2"><li>AOF</li></ol><p>将我们的所有命令都记录下来，history，恢复的时候全部再执行一遍</p><p>将Redis执行过的所有写指令记录下来，只许追加文件，不可以改写文件，redis在启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>优点：</p><ol><li><p>每一次修改都会同步，文件完整性更好</p></li><li><p>每秒同步一次，可能会丢失一秒的数据</p></li><li><p>从不同步，效率最高</p></li></ol><p>缺点：</p><ol><li><p>相对于数据文件来说，aof远远大于rdb，恢复的速度也比rdb慢</p></li><li><p>aof运行效率也要比rdb慢，redis默认的配置就是rdb持久化</p></li></ol><h1 id="aof重写"><a class="markdownIt-Anchor" href="#aof重写"></a> aof重写</h1><p>aof默认是文件无限追加，文件会越来越大。</p><p>如果大于64mb，那么就会fork新进程重写</p><p>如果只做缓存，不需要做持久化。</p><h1 id="5-性能建议"><a class="markdownIt-Anchor" href="#5-性能建议"></a> 5、性能建议</h1><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。(900秒内有1个更改就rdb)</p><p>如果Enable AoF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</p><p>如果不Enable AOF，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis持久化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis持久化&quot;&gt;&lt;/a&gt; Redis持久化&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;RDB&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每间隔一段时间就将内存中的数据集快照写入磁盘，即Snapsh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis数据结构的实现</title>
    <link href="https://arthersun.github.io/2022/12/12/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://arthersun.github.io/2022/12/12/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-12T07:19:58.000Z</published>
    <updated>2022-12-12T16:06:45.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型与数据结构的关系"><a class="markdownIt-Anchor" href="#数据类型与数据结构的关系"></a> 数据类型与数据结构的关系</h1><ol><li><p>String -&gt; SDS</p></li><li><p>List -&gt; quicklist</p></li><li><p>Hash -&gt; 压缩列表、哈希表</p></li><li><p>Set -&gt; 哈希表或整数集合</p></li><li><p>Zset -&gt; 压缩列表或跳表</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据类型与数据结构的关系&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据类型与数据结构的关系&quot;&gt;&lt;/a&gt; 数据类型与数据结构的关系&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;String -&amp;gt; SDS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring事务</title>
    <link href="https://arthersun.github.io/2022/12/10/spring%E4%BA%8B%E5%8A%A1/"/>
    <id>https://arthersun.github.io/2022/12/10/spring%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-12-10T08:02:21.000Z</published>
    <updated>2022-12-10T08:19:28.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring事务失效的情况"><a class="markdownIt-Anchor" href="#spring事务失效的情况"></a> spring事务失效的情况</h1><ol><li><p>在方法内使用异步线程</p></li><li><p>在方法内直接调其他方法，因为没有经过事务的代理，没有办法去依赖spring做AOP增强。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring事务失效的情况&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#spring事务失效的情况&quot;&gt;&lt;/a&gt; spring事务失效的情况&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在方法内使用异步线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CAP原理和它的例子</title>
    <link href="https://arthersun.github.io/2022/12/08/CAP%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%83%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <id>https://arthersun.github.io/2022/12/08/CAP%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%83%E7%9A%84%E4%BE%8B%E5%AD%90/</id>
    <published>2022-12-08T07:11:43.000Z</published>
    <updated>2022-12-08T07:22:07.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cap定理"><a class="markdownIt-Anchor" href="#cap定理"></a> CAP定理</h1><p>C：一致性，更新操作成功后，所有节点在同一时间的数据完全一致</p><p>A：可用性，请求发送后能在正确时间得到预期响应</p><p>P：分区容错性，分布式系统在遇到某节点或网络错误的时候，仍然能对外提供满足一致性或可用性的结果。</p><h1 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h1><p>订单系统-&gt;库存系统</p><p>业务功能：在下单后订单系统新建订单，会在库存系统减少库存</p><p>CP：满足一致性和分区容错性。下单后，用户等待库存系统减少后得到下单成功的结果</p><p>AP：满足可用性和分区容错性。下单后，订单系统创建订单，用户得到下单成功的结果，然后系统异步完成减少库存</p><p>CA：满足可用性和分区容错性。不拆分数据系统，在一个数据库的一个事务中完成操作，也就是单体应用</p><p>通俗来讲，在一个分布式系统中，一致性和可用性不能同时满足。如果同时满足，那么就是一个单体系统</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cap定理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cap定理&quot;&gt;&lt;/a&gt; CAP定理&lt;/h1&gt;
&lt;p&gt;C：一致性，更新操作成功后，所有节点在同一时间的数据完全一致&lt;/p&gt;
&lt;p&gt;A：可用性，请求发送后能在正确时间得到预期响应&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大数据技术生态</title>
    <link href="https://arthersun.github.io/2022/12/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81/"/>
    <id>https://arthersun.github.io/2022/12/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81/</id>
    <published>2022-12-07T15:38:58.000Z</published>
    <updated>2022-12-08T07:11:32.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hadoop"><a class="markdownIt-Anchor" href="#hadoop"></a> Hadoop</h1><p>Hadoop是一个分布式存储系统，使用HDFS存储分布式数据，解决单机数据存不下的问题，使用MapReduce并行计算，解决计算速度问题。</p><h1 id="hive"><a class="markdownIt-Anchor" href="#hive"></a> Hive</h1><p>Hive解决的是分布式场景下不能像传统数据库一样写SQL的问题</p><h1 id="spark"><a class="markdownIt-Anchor" href="#spark"></a> Spark</h1><p>Spark是基于内存的计算，非常快</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hadoop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hadoop&quot;&gt;&lt;/a&gt; Hadoop&lt;/h1&gt;
&lt;p&gt;Hadoop是一个分布式存储系统，使用HDFS存储分布式数据，解决单机数据存不下的问题，使用MapReduce并行计算，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="https://arthersun.github.io/2022/12/07/kafka/"/>
    <id>https://arthersun.github.io/2022/12/07/kafka/</id>
    <published>2022-12-07T12:19:28.000Z</published>
    <updated>2022-12-07T13:36:07.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为啥需要消息队列"><a class="markdownIt-Anchor" href="#为啥需要消息队列"></a> 为啥需要消息队列</h1><ol><li><p>异步：允许用户把一个消息放入队列，但不立即处理它，在需要的时候再去处理他它们</p></li><li><p>解耦：只要遵守同样的接口约束，就可以独立的扩展或修改两边的处理过程</p></li><li><p>缓冲/消峰：有利于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p></li></ol><h1 id="消息队列的模式"><a class="markdownIt-Anchor" href="#消息队列的模式"></a> 消息队列的模式</h1><ol><li><p>点对点模式：消费者一个个去消息队列中拉取数据。缺点是，消费者需要额外的线程去监控队列中是否有消息要被消费。</p></li><li><p>发布订阅模式：生产者将消息放入消息队列后，队列会将消息推送给订阅过该类信息的消费者，但消息队列由于无法感知消费者消费的速度，速度慢了会造成资源的浪费，速度快了会让速度慢的消费者无法承受。</p></li></ol><h1 id="kafka高吞吐量的分布式发布订阅消息系统"><a class="markdownIt-Anchor" href="#kafka高吞吐量的分布式发布订阅消息系统"></a> kafka：高吞吐量的分布式发布订阅消息系统</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为啥需要消息队列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为啥需要消息队列&quot;&gt;&lt;/a&gt; 为啥需要消息队列&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;异步：允许用户把一个消息放入队列，但不立即处理它，在需要的时候再去处理他它们&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于区块链的交易平台的功能流程</title>
    <link href="https://arthersun.github.io/2022/12/07/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/12/07/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2022-12-07T10:41:05.000Z</published>
    <updated>2022-12-07T12:19:18.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于区块链的交易平台的理想功能流程仅供参考"><a class="markdownIt-Anchor" href="#基于区块链的交易平台的理想功能流程仅供参考"></a> 基于区块链的交易平台的理想功能流程（仅供参考）</h1><p>转账：</p><ol><li><p>后端接收到前端传送的/issuecash请求，主要包含<code>转账金额</code>和<code>接收人</code></p></li><li><p>向区块链服务发送RPC请求，请求一个当前用户的金额，如果得到的金额小于转账金额，直接返回转账金额不够</p></li><li><p>向区块链服务发送RPC请求，这个请求包含转账金额和接收人，发起转账，</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于区块链的交易平台的理想功能流程仅供参考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于区块链的交易平台的理想功能流程仅供参考&quot;&gt;&lt;/a&gt; 基于区块链的交易平台的理想功能流程（仅供参考）&lt;/h1&gt;
&lt;p&gt;转账：&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hmdianping中的redis应用</title>
    <link href="https://arthersun.github.io/2022/12/07/hmdianping%E4%B8%AD%E7%9A%84redis%E5%BA%94%E7%94%A8/"/>
    <id>https://arthersun.github.io/2022/12/07/hmdianping%E4%B8%AD%E7%9A%84redis%E5%BA%94%E7%94%A8/</id>
    <published>2022-12-07T09:16:10.000Z</published>
    <updated>2022-12-07T10:34:40.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑马点评中redis的应用"><a class="markdownIt-Anchor" href="#黑马点评中redis的应用"></a> 黑马点评中redis的应用</h1><ol><li><p>短信登录：使用Redis共享session</p></li><li><p>查询缓存：缓存穿透、缓存雪崩解决</p></li><li><p>优惠券秒杀：Redis的计数器、分布式锁、Redis的三种消息队列</p></li><li><p>附近商户：Redis的GeoHash应用</p></li><li><p>UV统计：Redis的HyperLogLog的统计</p></li><li><p>用户签到：Redis的BitMap数据统计功能</p></li><li><p>好友关注：Set集合的关注、取关、共同关注、消息推送</p></li><li><p>达人探店：基于List的点赞列表，基于SortedSet的点赞排行榜</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;黑马点评中redis的应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#黑马点评中redis的应用&quot;&gt;&lt;/a&gt; 黑马点评中redis的应用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;短信登录：使用Redis共享session&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>stream流的一些妙用</title>
    <link href="https://arthersun.github.io/2022/12/05/stream%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E7%94%A8/"/>
    <id>https://arthersun.github.io/2022/12/05/stream%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E7%94%A8/</id>
    <published>2022-12-05T07:06:49.000Z</published>
    <updated>2022-12-05T07:31:28.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组最小值"><a class="markdownIt-Anchor" href="#求数组最小值"></a> 求数组最小值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(baseCosts).min().getAsInt()</span><br></pre></td></tr></table></figure><h1 id="装箱"><a class="markdownIt-Anchor" href="#装箱"></a> 装箱</h1><p>Arrays.stream(arr).boxed().toArray(Integer[]::new)</p><h1 id="拆箱"><a class="markdownIt-Anchor" href="#拆箱"></a> 拆箱</h1><p>Arrays.stream(integers).mapToInt(Integer::valueOf).toArray()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;求数组最小值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#求数组最小值&quot;&gt;&lt;/a&gt; 求数组最小值&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    
  </entry>
  
</feed>
