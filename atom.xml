<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2022-12-14T13:15:14.926Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类加载和双亲委派机制</title>
    <link href="https://arthersun.github.io/2022/12/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>https://arthersun.github.io/2022/12/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-14T02:57:48.000Z</published>
    <updated>2022-12-14T13:15:14.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a class="markdownIt-Anchor" href="#类加载"></a> 类加载</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类加载&quot;&gt;&lt;/a&gt; 类加载&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://arthersun.github.io/2022/12/14/Mybatis-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/12/14/Mybatis-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-12-13T17:03:40.000Z</published>
    <updated>2022-12-13T17:12:08.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-mybatis井号与的区别"><a class="markdownIt-Anchor" href="#mysql-mybatis井号与的区别"></a> mysql Mybatis井号#与$的区别</h1><p>mybatis中使用ParameterType向sql语句传参，在sql语句中引用这些参数的时候，有两种方式：#parameterName, $parameterName。</p><p>1， #是一个占位符，$是拼接符。</p><p>#是一个占位符，$是拼接符。</p><p>（1）使用#parameterName方式引用参数的时候，Mybatis会把传入的参数当成是一个字符串，自动添加双引号。</p><p>（2）使用$parameterName引用参数时，不做任何处理，直接将值拼接在sql语句中。</p><p>2，使用 # 能够防止sql注入，$不能避免注入攻击。</p><p>#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译。</p><p>3 ，总结</p><p>建议使用# 。</p><h1 id="预编译"><a class="markdownIt-Anchor" href="#预编译"></a> $ 预编译</h1><p>预编译就是将#{}替换成？占位符，然后在执行时替换成实际传入的user_id值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10:27:20.247 [main] DEBUG william.mybatis.quickstart.mapper.UserMapper.selectById - ==&gt;  Preparing: select id, user_name from t_user where id = ? </span><br><span class="line">10:27:20.285 [main] DEBUG william.mybatis.quickstart.mapper.UserMapper.selectById - ==&gt; Parameters: 1(Long)</span><br></pre></td></tr></table></figure><p>因为&quot;#{}&quot;会在传入的值两端加上单引号，所以可以很大程度上防止SQL注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Mybatis框架下易产生SQL注入漏洞的情况主要分为以下三种：</span><br><span class="line"></span><br><span class="line">1、模糊查询</span><br><span class="line"></span><br><span class="line">Select * from news where title like ‘%#&#123;title&#125;%’</span><br><span class="line"></span><br><span class="line">在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</span><br><span class="line"></span><br><span class="line">正确写法：</span><br><span class="line">select * from news where tile like concat(‘%’,#&#123;title&#125;, ‘%’)</span><br><span class="line"></span><br><span class="line">2、in 之后的多个参数</span><br><span class="line"></span><br><span class="line">in之后多个id查询时使用# 同样会报错，</span><br><span class="line"></span><br><span class="line">Select * from news where id in (#&#123;ids&#125;)</span><br><span class="line"></span><br><span class="line">正确用法为使用foreach，而不是将#替换为$</span><br><span class="line"></span><br><span class="line">id in</span><br><span class="line">&lt;foreach collection=&quot;ids&quot; item=&quot;item&quot; open=&quot;(&quot;separatosr=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">#&#123;ids&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">3、order by 之后</span><br><span class="line"></span><br><span class="line">这种场景应当在Java层面做映射，设置一个字段/表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面。需要注意的是在mybatis-generator自动生成的SQL语句中，order by使用的也是$，而like和in没有问题。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql-mybatis井号与的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mysql-mybatis井号与的区别&quot;&gt;&lt;/a&gt; mysql Mybatis井号#与$的区别&lt;/h1&gt;
&lt;p&gt;mybatis中使用Parameter</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redo log和Binlog</title>
    <link href="https://arthersun.github.io/2022/12/13/Redo-log%E5%92%8CBinlog/"/>
    <id>https://arthersun.github.io/2022/12/13/Redo-log%E5%92%8CBinlog/</id>
    <published>2022-12-13T14:42:18.000Z</published>
    <updated>2022-12-13T17:03:19.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redo-log和binlog的不同"><a class="markdownIt-Anchor" href="#redo-log和binlog的不同"></a> Redo log和Binlog的不同</h1><ol><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><h1 id="redo_log设置"><a class="markdownIt-Anchor" href="#redo_log设置"></a> redo_log设置</h1><ol><li><p>redo log 用于保证 crash-safe 能力。</p></li><li><p>innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p></li><li><p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证MySQL 异常重启之后 binlog 不丢失。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redo-log和binlog的不同&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redo-log和binlog的不同&quot;&gt;&lt;/a&gt; Redo log和Binlog的不同&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;redo log 是 Inn</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>抽象类和接口</title>
    <link href="https://arthersun.github.io/2022/12/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://arthersun.github.io/2022/12/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-12-13T10:47:50.000Z</published>
    <updated>2022-12-13T14:42:03.466Z</updated>
    
    <content type="html"><![CDATA[<p>普通类：只有具体的实现</p><p>抽象类：具体实现和规范（抽象方法）都有</p><p>接口：只有规范</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;普通类：只有具体的实现&lt;/p&gt;
&lt;p&gt;抽象类：具体实现和规范（抽象方法）都有&lt;/p&gt;
&lt;p&gt;接口：只有规范&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://arthersun.github.io/2022/12/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://arthersun.github.io/2022/12/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2022-12-12T16:23:12.000Z</published>
    <updated>2022-12-12T17:44:13.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis持久化"><a class="markdownIt-Anchor" href="#redis持久化"></a> Redis持久化</h1><ol><li>RDB</li></ol><p>每间隔一段时间就将内存中的数据集快照写入磁盘，即Snapshot快照，恢复时是将快照文件直接读到内存里。</p><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>适合大规模数据，但是可能丢失最后一次数据</p><ol start="2"><li>AOF</li></ol><p>将我们的所有命令都记录下来，history，恢复的时候全部再执行一遍</p><p>将Redis执行过的所有写指令记录下来，只许追加文件，不可以改写文件，redis在启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>优点：</p><ol><li><p>每一次修改都会同步，文件完整性更好</p></li><li><p>每秒同步一次，可能会丢失一秒的数据</p></li><li><p>从不同步，效率最高</p></li></ol><p>缺点：</p><ol><li><p>相对于数据文件来说，aof远远大于rdb，恢复的速度也比rdb慢</p></li><li><p>aof运行效率也要比rdb慢，redis默认的配置就是rdb持久化</p></li></ol><h1 id="aof重写"><a class="markdownIt-Anchor" href="#aof重写"></a> aof重写</h1><p>aof默认是文件无限追加，文件会越来越大。</p><p>如果大于64mb，那么就会fork新进程重写</p><p>如果只做缓存，不需要做持久化。</p><h1 id="5-性能建议"><a class="markdownIt-Anchor" href="#5-性能建议"></a> 5、性能建议</h1><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。(900秒内有1个更改就rdb)</p><p>如果Enable AoF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</p><p>如果不Enable AOF，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis持久化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis持久化&quot;&gt;&lt;/a&gt; Redis持久化&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;RDB&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每间隔一段时间就将内存中的数据集快照写入磁盘，即Snapsh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis数据结构的实现</title>
    <link href="https://arthersun.github.io/2022/12/12/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://arthersun.github.io/2022/12/12/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-12T07:19:58.000Z</published>
    <updated>2022-12-12T16:06:45.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型与数据结构的关系"><a class="markdownIt-Anchor" href="#数据类型与数据结构的关系"></a> 数据类型与数据结构的关系</h1><ol><li><p>String -&gt; SDS</p></li><li><p>List -&gt; quicklist</p></li><li><p>Hash -&gt; 压缩列表、哈希表</p></li><li><p>Set -&gt; 哈希表或整数集合</p></li><li><p>Zset -&gt; 压缩列表或跳表</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据类型与数据结构的关系&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据类型与数据结构的关系&quot;&gt;&lt;/a&gt; 数据类型与数据结构的关系&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;String -&amp;gt; SDS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring事务</title>
    <link href="https://arthersun.github.io/2022/12/10/spring%E4%BA%8B%E5%8A%A1/"/>
    <id>https://arthersun.github.io/2022/12/10/spring%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-12-10T08:02:21.000Z</published>
    <updated>2022-12-10T08:19:28.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring事务失效的情况"><a class="markdownIt-Anchor" href="#spring事务失效的情况"></a> spring事务失效的情况</h1><ol><li><p>在方法内使用异步线程</p></li><li><p>在方法内直接调其他方法，因为没有经过事务的代理，没有办法去依赖spring做AOP增强。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring事务失效的情况&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#spring事务失效的情况&quot;&gt;&lt;/a&gt; spring事务失效的情况&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在方法内使用异步线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CAP原理和它的例子</title>
    <link href="https://arthersun.github.io/2022/12/08/CAP%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%83%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <id>https://arthersun.github.io/2022/12/08/CAP%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%83%E7%9A%84%E4%BE%8B%E5%AD%90/</id>
    <published>2022-12-08T07:11:43.000Z</published>
    <updated>2022-12-08T07:22:07.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cap定理"><a class="markdownIt-Anchor" href="#cap定理"></a> CAP定理</h1><p>C：一致性，更新操作成功后，所有节点在同一时间的数据完全一致</p><p>A：可用性，请求发送后能在正确时间得到预期响应</p><p>P：分区容错性，分布式系统在遇到某节点或网络错误的时候，仍然能对外提供满足一致性或可用性的结果。</p><h1 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h1><p>订单系统-&gt;库存系统</p><p>业务功能：在下单后订单系统新建订单，会在库存系统减少库存</p><p>CP：满足一致性和分区容错性。下单后，用户等待库存系统减少后得到下单成功的结果</p><p>AP：满足可用性和分区容错性。下单后，订单系统创建订单，用户得到下单成功的结果，然后系统异步完成减少库存</p><p>CA：满足可用性和分区容错性。不拆分数据系统，在一个数据库的一个事务中完成操作，也就是单体应用</p><p>通俗来讲，在一个分布式系统中，一致性和可用性不能同时满足。如果同时满足，那么就是一个单体系统</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cap定理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cap定理&quot;&gt;&lt;/a&gt; CAP定理&lt;/h1&gt;
&lt;p&gt;C：一致性，更新操作成功后，所有节点在同一时间的数据完全一致&lt;/p&gt;
&lt;p&gt;A：可用性，请求发送后能在正确时间得到预期响应&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大数据技术生态</title>
    <link href="https://arthersun.github.io/2022/12/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81/"/>
    <id>https://arthersun.github.io/2022/12/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81/</id>
    <published>2022-12-07T15:38:58.000Z</published>
    <updated>2022-12-08T07:11:32.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hadoop"><a class="markdownIt-Anchor" href="#hadoop"></a> Hadoop</h1><p>Hadoop是一个分布式存储系统，使用HDFS存储分布式数据，解决单机数据存不下的问题，使用MapReduce并行计算，解决计算速度问题。</p><h1 id="hive"><a class="markdownIt-Anchor" href="#hive"></a> Hive</h1><p>Hive解决的是分布式场景下不能像传统数据库一样写SQL的问题</p><h1 id="spark"><a class="markdownIt-Anchor" href="#spark"></a> Spark</h1><p>Spark是基于内存的计算，非常快</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hadoop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hadoop&quot;&gt;&lt;/a&gt; Hadoop&lt;/h1&gt;
&lt;p&gt;Hadoop是一个分布式存储系统，使用HDFS存储分布式数据，解决单机数据存不下的问题，使用MapReduce并行计算，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="https://arthersun.github.io/2022/12/07/kafka/"/>
    <id>https://arthersun.github.io/2022/12/07/kafka/</id>
    <published>2022-12-07T12:19:28.000Z</published>
    <updated>2022-12-07T13:36:07.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为啥需要消息队列"><a class="markdownIt-Anchor" href="#为啥需要消息队列"></a> 为啥需要消息队列</h1><ol><li><p>异步：允许用户把一个消息放入队列，但不立即处理它，在需要的时候再去处理他它们</p></li><li><p>解耦：只要遵守同样的接口约束，就可以独立的扩展或修改两边的处理过程</p></li><li><p>缓冲/消峰：有利于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p></li></ol><h1 id="消息队列的模式"><a class="markdownIt-Anchor" href="#消息队列的模式"></a> 消息队列的模式</h1><ol><li><p>点对点模式：消费者一个个去消息队列中拉取数据。缺点是，消费者需要额外的线程去监控队列中是否有消息要被消费。</p></li><li><p>发布订阅模式：生产者将消息放入消息队列后，队列会将消息推送给订阅过该类信息的消费者，但消息队列由于无法感知消费者消费的速度，速度慢了会造成资源的浪费，速度快了会让速度慢的消费者无法承受。</p></li></ol><h1 id="kafka高吞吐量的分布式发布订阅消息系统"><a class="markdownIt-Anchor" href="#kafka高吞吐量的分布式发布订阅消息系统"></a> kafka：高吞吐量的分布式发布订阅消息系统</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为啥需要消息队列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为啥需要消息队列&quot;&gt;&lt;/a&gt; 为啥需要消息队列&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;异步：允许用户把一个消息放入队列，但不立即处理它，在需要的时候再去处理他它们&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于区块链的交易平台的功能流程</title>
    <link href="https://arthersun.github.io/2022/12/07/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/12/07/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2022-12-07T10:41:05.000Z</published>
    <updated>2022-12-07T12:19:18.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于区块链的交易平台的理想功能流程仅供参考"><a class="markdownIt-Anchor" href="#基于区块链的交易平台的理想功能流程仅供参考"></a> 基于区块链的交易平台的理想功能流程（仅供参考）</h1><p>转账：</p><ol><li><p>后端接收到前端传送的/issuecash请求，主要包含<code>转账金额</code>和<code>接收人</code></p></li><li><p>向区块链服务发送RPC请求，请求一个当前用户的金额，如果得到的金额小于转账金额，直接返回转账金额不够</p></li><li><p>向区块链服务发送RPC请求，这个请求包含转账金额和接收人，发起转账，</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于区块链的交易平台的理想功能流程仅供参考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于区块链的交易平台的理想功能流程仅供参考&quot;&gt;&lt;/a&gt; 基于区块链的交易平台的理想功能流程（仅供参考）&lt;/h1&gt;
&lt;p&gt;转账：&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hmdianping中的redis应用</title>
    <link href="https://arthersun.github.io/2022/12/07/hmdianping%E4%B8%AD%E7%9A%84redis%E5%BA%94%E7%94%A8/"/>
    <id>https://arthersun.github.io/2022/12/07/hmdianping%E4%B8%AD%E7%9A%84redis%E5%BA%94%E7%94%A8/</id>
    <published>2022-12-07T09:16:10.000Z</published>
    <updated>2022-12-07T10:34:40.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑马点评中redis的应用"><a class="markdownIt-Anchor" href="#黑马点评中redis的应用"></a> 黑马点评中redis的应用</h1><ol><li><p>短信登录：使用Redis共享session</p></li><li><p>查询缓存：缓存穿透、缓存雪崩解决</p></li><li><p>优惠券秒杀：Redis的计数器、分布式锁、Redis的三种消息队列</p></li><li><p>附近商户：Redis的GeoHash应用</p></li><li><p>UV统计：Redis的HyperLogLog的统计</p></li><li><p>用户签到：Redis的BitMap数据统计功能</p></li><li><p>好友关注：Set集合的关注、取关、共同关注、消息推送</p></li><li><p>达人探店：基于List的点赞列表，基于SortedSet的点赞排行榜</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;黑马点评中redis的应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#黑马点评中redis的应用&quot;&gt;&lt;/a&gt; 黑马点评中redis的应用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;短信登录：使用Redis共享session&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>stream流的一些妙用</title>
    <link href="https://arthersun.github.io/2022/12/05/stream%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E7%94%A8/"/>
    <id>https://arthersun.github.io/2022/12/05/stream%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E7%94%A8/</id>
    <published>2022-12-05T07:06:49.000Z</published>
    <updated>2022-12-05T07:31:28.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组最小值"><a class="markdownIt-Anchor" href="#求数组最小值"></a> 求数组最小值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(baseCosts).min().getAsInt()</span><br></pre></td></tr></table></figure><h1 id="装箱"><a class="markdownIt-Anchor" href="#装箱"></a> 装箱</h1><p>Arrays.stream(arr).boxed().toArray(Integer[]::new)</p><h1 id="拆箱"><a class="markdownIt-Anchor" href="#拆箱"></a> 拆箱</h1><p>Arrays.stream(integers).mapToInt(Integer::valueOf).toArray()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;求数组最小值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#求数组最小值&quot;&gt;&lt;/a&gt; 求数组最小值&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池参数和设置相关</title>
    <link href="https://arthersun.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
    <id>https://arthersun.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/</id>
    <published>2022-12-03T04:42:50.000Z</published>
    <updated>2022-12-03T04:55:21.147Z</updated>
    
    <content type="html"><![CDATA[<p>线程池参数设置是一个常考的难点，下面逐一进行分析</p><h1 id="任务拒绝策略"><a class="markdownIt-Anchor" href="#任务拒绝策略"></a> 任务拒绝策略</h1><p>任务拒绝策略具有不同的适用场景</p><ol><li><p>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常，是线程池默认的拒绝策略，抛出异常有利于帮助反馈程序的运行状态。所以在关键业务推荐使用此拒绝策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现。</p></li><li><p>DiscardPolicy：丢弃任务，不抛异常。由于可能无法发现系统异常状态，还得根据实际业务是否允许丢弃老任务来认真衡量。</p></li><li><p>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</p></li><li><p>CallerRunsPolicy：由调用线程（提交任务的线程）处理改任务。让所有任务都执行完毕，所以就适合大量计算的任务类型去执行。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程池参数设置是一个常考的难点，下面逐一进行分析&lt;/p&gt;
&lt;h1 id=&quot;任务拒绝策略&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#任务拒绝策略&quot;&gt;&lt;/a&gt; 任务拒绝策略&lt;/h1&gt;
&lt;p&gt;任务拒绝策略具有不同的适用场景&lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMS和G1收集器</title>
    <link href="https://arthersun.github.io/2022/11/29/CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://arthersun.github.io/2022/11/29/CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-11-29T05:21:27.000Z</published>
    <updated>2022-11-29T05:23:14.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="g1收集器"><a class="markdownIt-Anchor" href="#g1收集器"></a> G1收集器</h1><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p><p>空间整理：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</p><p>停顿是可以预测的</p><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;g1收集器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#g1收集器&quot;&gt;&lt;/a&gt; G1收集器&lt;/h1&gt;
&lt;p&gt;G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>又是悲痛又顿悟的一晚上</title>
    <link href="https://arthersun.github.io/2022/11/28/%E5%8F%88%E6%98%AF%E6%82%B2%E7%97%9B%E5%8F%88%E9%A1%BF%E6%82%9F%E7%9A%84%E4%B8%80%E6%99%9A%E4%B8%8A/"/>
    <id>https://arthersun.github.io/2022/11/28/%E5%8F%88%E6%98%AF%E6%82%B2%E7%97%9B%E5%8F%88%E9%A1%BF%E6%82%9F%E7%9A%84%E4%B8%80%E6%99%9A%E4%B8%8A/</id>
    <published>2022-11-28T15:11:06.000Z</published>
    <updated>2022-11-28T15:31:06.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="又是悲痛又顿悟的一晚上"><a class="markdownIt-Anchor" href="#又是悲痛又顿悟的一晚上"></a> 又是悲痛又顿悟的一晚上</h1><p>恻隐之心人皆有之。</p><p>有时候看着大家一脸着急的样子，突然明白自己无论如何伪装，在别人面前都是一眼透明。</p><p>大部分虽然自身也难保，但也是想要善意的帮助他人。</p><p>真诚真的是最大的杀器。</p><p>加油啊少年，不要辜负那么多人的善意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;又是悲痛又顿悟的一晚上&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#又是悲痛又顿悟的一晚上&quot;&gt;&lt;/a&gt; 又是悲痛又顿悟的一晚上&lt;/h1&gt;
&lt;p&gt;恻隐之心人皆有之。&lt;/p&gt;
&lt;p&gt;有时候看着大家一脸着急的样子，突然明白自己无论如何伪装，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>进程、线程、协程</title>
    <link href="https://arthersun.github.io/2022/11/28/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/11/28/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/</id>
    <published>2022-11-28T01:53:21.000Z</published>
    <updated>2022-11-28T15:06:41.601Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis和MySQL的数据一致性问题</title>
    <link href="https://arthersun.github.io/2022/11/27/Redis%E5%92%8CMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://arthersun.github.io/2022/11/27/Redis%E5%92%8CMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2022-11-27T13:14:39.000Z</published>
    <updated>2022-11-28T01:52:58.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于redis和mysql的架构如何保证数据一致性"><a class="markdownIt-Anchor" href="#基于redis和mysql的架构如何保证数据一致性"></a> 基于Redis和MySQL的架构，如何保证数据一致性</h1><ol><li><p>一般情况下，Redis是用作应用程序和数据库之间读操作的缓存，主要目的是减少数据库IO，提升数据查询性能。</p></li><li><p>一般流程：</p></li></ol><ul><li><ol><li>命中缓存，从缓存中加载数据</li></ol></li><li><ol start="2"><li>没有命中缓存，从数据库中加载数据</li></ol></li><li><ol start="3"><li>加载到的数据写入缓存</li></ol></li></ul><ol start="3"><li>存在的问题：</li></ol><p>当数据发生变化时，需要同时更新Redis和MySQL，可能出现一方更新失败，一方更新成功的情况，从而出现数据一致性问题。</p><ol start="4"><li>解决办法：</li></ol><ul><li><ol><li>先更新数据库，再更新缓存。如果缓存更新失败，就会导致数据库和Redis中的数据不一致。</li></ol></li><li><ol start="2"><li>先删除缓存，再更新数据库。这样下次访问Redis的时候，发现Redis中的数据是空的，这时候再加载。</li></ol></li><li>但是在极端情况下，我们并不能保证删除Redis和更新数据库这两个操作的原子性。在这个过程中，如果有其他线程访问的话，还是会有数据一致性问题。所以在极端情况下，需要采用最终一致性方案</li></ul><h2 id="最终一致性方案"><a class="markdownIt-Anchor" href="#最终一致性方案"></a> 最终一致性方案：</h2><ol><li><p>MySQL更新数据库的数据</p></li><li><p>更新Redis中的数据</p></li><li><p>失败的请求写入MQ事务消息</p></li><li><p>异步重试，确保成功</p></li></ol><p>还可以通过Canal组件监控binlog文件，从binlog中加载数据，然后同步到Redis中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于redis和mysql的架构如何保证数据一致性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于redis和mysql的架构如何保证数据一致性&quot;&gt;&lt;/a&gt; 基于Redis和MySQL的架构，如何保证数据一致性&lt;/h1&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外企的优势中英文版本</title>
    <link href="https://arthersun.github.io/2022/11/27/%E5%A4%96%E4%BC%81%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%AD%E8%8B%B1%E6%96%87%E7%89%88%E6%9C%AC/"/>
    <id>https://arthersun.github.io/2022/11/27/%E5%A4%96%E4%BC%81%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%AD%E8%8B%B1%E6%96%87%E7%89%88%E6%9C%AC/</id>
    <published>2022-11-26T18:19:47.000Z</published>
    <updated>2022-11-27T13:14:26.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外企的优势中英文版本"><a class="markdownIt-Anchor" href="#外企的优势中英文版本"></a> 外企的优势中英文版本</h1><ol><li>流程标准化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外企的优势中英文版本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#外企的优势中英文版本&quot;&gt;&lt;/a&gt; 外企的优势中英文版本&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;流程标准化&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS</title>
    <link href="https://arthersun.github.io/2022/11/25/HTTP%E5%92%8CHTTPS/"/>
    <id>https://arthersun.github.io/2022/11/25/HTTP%E5%92%8CHTTPS/</id>
    <published>2022-11-25T05:50:08.000Z</published>
    <updated>2022-11-25T05:57:04.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http和https的演进"><a class="markdownIt-Anchor" href="#http和https的演进"></a> HTTP和HTTPS的演进</h1><p>HTTP是TCP三次握手后就可以传输数据了</p><p>但是传输的是明文数据</p><h2 id="演进"><a class="markdownIt-Anchor" href="#演进"></a> 演进：</h2><ol><li><p>如果用对称加密，那需要每两个服务器和客户端商量一个秘钥，维护成本很高。</p></li><li><p>如果用非对称加密，因为公钥公开的，可以被黑客截获，它就可以用公钥解密，获取其中的内容。</p></li><li><p>如果用非对称加密和对称加密一起使用，非对称加密传输对称秘钥，对称秘钥加解密后传输，但这时无法确定是黑客还是中间人</p></li><li><p>使用SSL证书，证书中包括证书发布机构CA、证书有效期、公钥、证书所有者、签名，客户端收到服务器的SSL证书时，会对证书真伪进行检验。</p></li></ol><p>（1）首先浏览器读取证书中证书所有者、有效期等校验<br>（2）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http和https的演进&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#http和https的演进&quot;&gt;&lt;/a&gt; HTTP和HTTPS的演进&lt;/h1&gt;
&lt;p&gt;HTTP是TCP三次握手后就可以传输数据了&lt;/p&gt;
&lt;p&gt;但是传输的是明文数据</summary>
      
    
    
    
    
  </entry>
  
</feed>
