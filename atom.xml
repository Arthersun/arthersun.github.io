<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2022-12-03T04:55:21.147Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池参数和设置相关</title>
    <link href="https://arthersun.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
    <id>https://arthersun.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/</id>
    <published>2022-12-03T04:42:50.000Z</published>
    <updated>2022-12-03T04:55:21.147Z</updated>
    
    <content type="html"><![CDATA[<p>线程池参数设置是一个常考的难点，下面逐一进行分析</p><h1 id="任务拒绝策略"><a class="markdownIt-Anchor" href="#任务拒绝策略"></a> 任务拒绝策略</h1><p>任务拒绝策略具有不同的适用场景</p><ol><li><p>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常，是线程池默认的拒绝策略，抛出异常有利于帮助反馈程序的运行状态。所以在关键业务推荐使用此拒绝策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现。</p></li><li><p>DiscardPolicy：丢弃任务，不抛异常。由于可能无法发现系统异常状态，还得根据实际业务是否允许丢弃老任务来认真衡量。</p></li><li><p>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</p></li><li><p>CallerRunsPolicy：由调用线程（提交任务的线程）处理改任务。让所有任务都执行完毕，所以就适合大量计算的任务类型去执行。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程池参数设置是一个常考的难点，下面逐一进行分析&lt;/p&gt;
&lt;h1 id=&quot;任务拒绝策略&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#任务拒绝策略&quot;&gt;&lt;/a&gt; 任务拒绝策略&lt;/h1&gt;
&lt;p&gt;任务拒绝策略具有不同的适用场景&lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMS和G1收集器</title>
    <link href="https://arthersun.github.io/2022/11/29/CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://arthersun.github.io/2022/11/29/CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-11-29T05:21:27.000Z</published>
    <updated>2022-11-29T05:23:14.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="g1收集器"><a class="markdownIt-Anchor" href="#g1收集器"></a> G1收集器</h1><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p><p>空间整理：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</p><p>停顿是可以预测的</p><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;g1收集器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#g1收集器&quot;&gt;&lt;/a&gt; G1收集器&lt;/h1&gt;
&lt;p&gt;G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>又是悲痛又顿悟的一晚上</title>
    <link href="https://arthersun.github.io/2022/11/28/%E5%8F%88%E6%98%AF%E6%82%B2%E7%97%9B%E5%8F%88%E9%A1%BF%E6%82%9F%E7%9A%84%E4%B8%80%E6%99%9A%E4%B8%8A/"/>
    <id>https://arthersun.github.io/2022/11/28/%E5%8F%88%E6%98%AF%E6%82%B2%E7%97%9B%E5%8F%88%E9%A1%BF%E6%82%9F%E7%9A%84%E4%B8%80%E6%99%9A%E4%B8%8A/</id>
    <published>2022-11-28T15:11:06.000Z</published>
    <updated>2022-11-28T15:31:06.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="又是悲痛又顿悟的一晚上"><a class="markdownIt-Anchor" href="#又是悲痛又顿悟的一晚上"></a> 又是悲痛又顿悟的一晚上</h1><p>恻隐之心人皆有之。</p><p>有时候看着大家一脸着急的样子，突然明白自己无论如何伪装，在别人面前都是一眼透明。</p><p>大部分虽然自身也难保，但也是想要善意的帮助他人。</p><p>真诚真的是最大的杀器。</p><p>加油啊少年，不要辜负那么多人的善意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;又是悲痛又顿悟的一晚上&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#又是悲痛又顿悟的一晚上&quot;&gt;&lt;/a&gt; 又是悲痛又顿悟的一晚上&lt;/h1&gt;
&lt;p&gt;恻隐之心人皆有之。&lt;/p&gt;
&lt;p&gt;有时候看着大家一脸着急的样子，突然明白自己无论如何伪装，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>进程、线程、协程</title>
    <link href="https://arthersun.github.io/2022/11/28/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/11/28/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/</id>
    <published>2022-11-28T01:53:21.000Z</published>
    <updated>2022-11-28T15:06:41.601Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis和MySQL的数据一致性问题</title>
    <link href="https://arthersun.github.io/2022/11/27/Redis%E5%92%8CMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://arthersun.github.io/2022/11/27/Redis%E5%92%8CMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2022-11-27T13:14:39.000Z</published>
    <updated>2022-11-28T01:52:58.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于redis和mysql的架构如何保证数据一致性"><a class="markdownIt-Anchor" href="#基于redis和mysql的架构如何保证数据一致性"></a> 基于Redis和MySQL的架构，如何保证数据一致性</h1><ol><li><p>一般情况下，Redis是用作应用程序和数据库之间读操作的缓存，主要目的是减少数据库IO，提升数据查询性能。</p></li><li><p>一般流程：</p></li></ol><ul><li><ol><li>命中缓存，从缓存中加载数据</li></ol></li><li><ol start="2"><li>没有命中缓存，从数据库中加载数据</li></ol></li><li><ol start="3"><li>加载到的数据写入缓存</li></ol></li></ul><ol start="3"><li>存在的问题：</li></ol><p>当数据发生变化时，需要同时更新Redis和MySQL，可能出现一方更新失败，一方更新成功的情况，从而出现数据一致性问题。</p><ol start="4"><li>解决办法：</li></ol><ul><li><ol><li>先更新数据库，再更新缓存。如果缓存更新失败，就会导致数据库和Redis中的数据不一致。</li></ol></li><li><ol start="2"><li>先删除缓存，再更新数据库。这样下次访问Redis的时候，发现Redis中的数据是空的，这时候再加载。</li></ol></li><li>但是在极端情况下，我们并不能保证删除Redis和更新数据库这两个操作的原子性。在这个过程中，如果有其他线程访问的话，还是会有数据一致性问题。所以在极端情况下，需要采用最终一致性方案</li></ul><h2 id="最终一致性方案"><a class="markdownIt-Anchor" href="#最终一致性方案"></a> 最终一致性方案：</h2><ol><li><p>MySQL更新数据库的数据</p></li><li><p>更新Redis中的数据</p></li><li><p>失败的请求写入MQ事务消息</p></li><li><p>异步重试，确保成功</p></li></ol><p>还可以通过Canal组件监控binlog文件，从binlog中加载数据，然后同步到Redis中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于redis和mysql的架构如何保证数据一致性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于redis和mysql的架构如何保证数据一致性&quot;&gt;&lt;/a&gt; 基于Redis和MySQL的架构，如何保证数据一致性&lt;/h1&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外企的优势中英文版本</title>
    <link href="https://arthersun.github.io/2022/11/27/%E5%A4%96%E4%BC%81%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%AD%E8%8B%B1%E6%96%87%E7%89%88%E6%9C%AC/"/>
    <id>https://arthersun.github.io/2022/11/27/%E5%A4%96%E4%BC%81%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%AD%E8%8B%B1%E6%96%87%E7%89%88%E6%9C%AC/</id>
    <published>2022-11-26T18:19:47.000Z</published>
    <updated>2022-11-27T13:14:26.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外企的优势中英文版本"><a class="markdownIt-Anchor" href="#外企的优势中英文版本"></a> 外企的优势中英文版本</h1><ol><li>流程标准化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外企的优势中英文版本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#外企的优势中英文版本&quot;&gt;&lt;/a&gt; 外企的优势中英文版本&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;流程标准化&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS</title>
    <link href="https://arthersun.github.io/2022/11/25/HTTP%E5%92%8CHTTPS/"/>
    <id>https://arthersun.github.io/2022/11/25/HTTP%E5%92%8CHTTPS/</id>
    <published>2022-11-25T05:50:08.000Z</published>
    <updated>2022-11-25T05:57:04.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http和https的演进"><a class="markdownIt-Anchor" href="#http和https的演进"></a> HTTP和HTTPS的演进</h1><p>HTTP是TCP三次握手后就可以传输数据了</p><p>但是传输的是明文数据</p><h2 id="演进"><a class="markdownIt-Anchor" href="#演进"></a> 演进：</h2><ol><li><p>如果用对称加密，那需要每两个服务器和客户端商量一个秘钥，维护成本很高。</p></li><li><p>如果用非对称加密，因为公钥公开的，可以被黑客截获，它就可以用公钥解密，获取其中的内容。</p></li><li><p>如果用非对称加密和对称加密一起使用，非对称加密传输对称秘钥，对称秘钥加解密后传输，但这时无法确定是黑客还是中间人</p></li><li><p>使用SSL证书，证书中包括证书发布机构CA、证书有效期、公钥、证书所有者、签名，客户端收到服务器的SSL证书时，会对证书真伪进行检验。</p></li></ol><p>（1）首先浏览器读取证书中证书所有者、有效期等校验<br>（2）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http和https的演进&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#http和https的演进&quot;&gt;&lt;/a&gt; HTTP和HTTPS的演进&lt;/h1&gt;
&lt;p&gt;HTTP是TCP三次握手后就可以传输数据了&lt;/p&gt;
&lt;p&gt;但是传输的是明文数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JIT编译器</title>
    <link href="https://arthersun.github.io/2022/11/25/JIT%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>https://arthersun.github.io/2022/11/25/JIT%E7%BC%96%E8%AF%91%E5%99%A8/</id>
    <published>2022-11-25T04:53:42.000Z</published>
    <updated>2022-11-25T05:18:12.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jit编译器"><a class="markdownIt-Anchor" href="#jit编译器"></a> JIT编译器</h1><p>java从源代码到运行的过程如下图：</p><p>.java -&gt; javac编译 -&gt; .class -&gt; 解释器&amp;JIT -&gt; 机器可理解的代码</p><p>需要注意的是.class -&gt; 机器码 这一步。JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</p><p>且有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引入了JIT编译器，而JIT属于运行时编译。</p><p>当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可直接使用。</p><p>机器码的运行效率肯定是高于JAVA解释器的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jit编译器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jit编译器&quot;&gt;&lt;/a&gt; JIT编译器&lt;/h1&gt;
&lt;p&gt;java从源代码到运行的过程如下图：&lt;/p&gt;
&lt;p&gt;.java -&amp;gt; javac编译 -&amp;gt; .class -</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深夜碎碎念</title>
    <link href="https://arthersun.github.io/2022/11/24/%E6%B7%B1%E5%A4%9C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://arthersun.github.io/2022/11/24/%E6%B7%B1%E5%A4%9C%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2022-11-24T15:43:45.000Z</published>
    <updated>2022-11-24T15:56:09.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深夜碎碎念"><a class="markdownIt-Anchor" href="#深夜碎碎念"></a> 深夜碎碎念</h1><p>最难的几年莫过于读研</p><p>那种受挫后不断反思，不断揉碎自己重塑价值的过程，是煎熬啊</p><p>越长大越沉默，是看到很多事情后发现懒得解释，懒得沟通，就这样吧，说话也挺累的</p><p>好在善意的人还是挺多的</p><p>加油吧少年，为了自己的生活</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深夜碎碎念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#深夜碎碎念&quot;&gt;&lt;/a&gt; 深夜碎碎念&lt;/h1&gt;
&lt;p&gt;最难的几年莫过于读研&lt;/p&gt;
&lt;p&gt;那种受挫后不断反思，不断揉碎自己重塑价值的过程，是煎熬啊&lt;/p&gt;
&lt;p&gt;越长大越沉默，是看</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap原理</title>
    <link href="https://arthersun.github.io/2022/11/24/ConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
    <id>https://arthersun.github.io/2022/11/24/ConcurrentHashMap%E5%8E%9F%E7%90%86/</id>
    <published>2022-11-24T15:43:09.000Z</published>
    <updated>2022-11-24T15:43:33.774Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>值传递和引用传递</title>
    <link href="https://arthersun.github.io/2022/11/24/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://arthersun.github.io/2022/11/24/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2022-11-24T13:38:54.000Z</published>
    <updated>2022-11-24T13:38:54.148Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>类加载子系统</title>
    <link href="https://arthersun.github.io/2022/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://arthersun.github.io/2022/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-11-21T02:11:32.000Z</published>
    <updated>2022-11-21T02:33:25.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载子系统"><a class="markdownIt-Anchor" href="#类加载子系统"></a> 类加载子系统</h1><p>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载子系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类加载子系统&quot;&gt;&lt;/a&gt; 类加载子系统&lt;/h1&gt;
&lt;p&gt;类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。&lt;/p&gt;
&lt;p&gt;Cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池相关</title>
    <link href="https://arthersun.github.io/2022/11/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <id>https://arthersun.github.io/2022/11/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</id>
    <published>2022-11-20T07:43:41.000Z</published>
    <updated>2022-11-20T08:18:30.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池相关"><a class="markdownIt-Anchor" href="#线程池相关"></a> 线程池相关</h1><p>ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量。</p><p>| 状态名 | 接收新任务 | 处理阻塞队列任务 | 说明 |<br>| Running | Y | Y |<br>| Shutdown | N | N | 不会接收新任务，但会处理阻塞队列剩余任务 |<br>| Stop | N | N | 会中断正在执行的任务，并抛弃阻塞队列任务 |<br>| Tidying | - | - | 任务全执行完毕，活动线程为0即将进入终结 |<br>| Terminated | - | - | 终结状态 |</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池相关&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池相关&quot;&gt;&lt;/a&gt; 线程池相关&lt;/h1&gt;
&lt;p&gt;ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量。&lt;/p&gt;
&lt;p&gt;| 状态名 | </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>try-catch-finally执行顺序</title>
    <link href="https://arthersun.github.io/2022/11/18/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://arthersun.github.io/2022/11/18/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-11-18T03:20:25.000Z</published>
    <updated>2022-11-19T01:42:28.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="try-catch-finally执行顺序"><a class="markdownIt-Anchor" href="#try-catch-finally执行顺序"></a> try-catch-finally执行顺序</h1><p>1、不管有没有出现异常，finally块中的代码都会执行；</p><p>2、当try和catch中有return时，finally仍然会执行；</p><p>3、finally是在return后面的表达式运算后执行的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;try-catch-finally执行顺序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#try-catch-finally执行顺序&quot;&gt;&lt;/a&gt; try-catch-finally执行顺序&lt;/h1&gt;
&lt;p&gt;1、不管有没有出现异常，fin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchonized锁升级流程</title>
    <link href="https://arthersun.github.io/2022/11/17/synchonized%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/11/17/synchonized%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/</id>
    <published>2022-11-17T02:56:53.000Z</published>
    <updated>2022-11-17T03:01:00.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized锁升级"><a class="markdownIt-Anchor" href="#synchronized锁升级"></a> synchronized锁升级</h1><p>根据上面内容可以知道，synchronized锁有四种状态：无锁，偏向锁、轻量级锁和重量级锁，下面介绍四种状态和其之间的转换。</p><p>2.1 无锁</p><p>当一个对象被创建之后，还没有线程进入，这个时候对象处于无锁状态，其Mark Word中的信息如上表所示。</p><p>2.2 偏向锁</p><p>当锁处于无锁状态时，有一个线程A访问同步块并获取锁时，会在对象头和栈帧中的锁记录记录线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来进行加锁和解锁，只需要简单的测试一下啊对象头中的线程ID和当前线程是否一致。</p><p>2.3 轻量级锁</p><p>在偏向锁的基础上，又有另外一个线程B进来，这时判断对象头中存储的线程A的ID和线程B不一致，就会使用CAS竞争锁，并且升级为轻量级锁，会在线程栈中创建一个锁记录(lock Record)，将Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头的Mark Word替换成指向锁记录的指针，如果成功，则当前线程获得锁；失败，表示其他线程竞争锁，当前线程便尝试CAS来获取锁。</p><p>2.4 重量级锁</p><p>当线程没有获得轻量级锁时，线程会CAS自旋来获取锁，当一个线程自旋10次之后，仍然未获得锁，那么就会升级成为重量级锁。</p><p>成为重量级锁之后，线程会进入阻塞队列(EntryList)，线程不再自旋获取锁，而是由CPU进行调度，线程串行执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;synchronized锁升级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#synchronized锁升级&quot;&gt;&lt;/a&gt; synchronized锁升级&lt;/h1&gt;
&lt;p&gt;根据上面内容可以知道，synchronized锁有四种状态：无锁，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mybatis八股</title>
    <link href="https://arthersun.github.io/2022/11/16/mybatis%E5%85%AB%E8%82%A1/"/>
    <id>https://arthersun.github.io/2022/11/16/mybatis%E5%85%AB%E8%82%A1/</id>
    <published>2022-11-16T13:56:54.000Z</published>
    <updated>2022-11-17T02:49:05.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis编程步骤是什么样的"><a class="markdownIt-Anchor" href="#mybatis编程步骤是什么样的"></a> MyBatis编程步骤是什么样的?</h1><p>1、创建SqlSessionFactory</p><p>2、通过SqlSessionFactory创建Sql Session</p><p>3、通过sqlsession执行数据库操作</p><p>4、调用session.commit()提交事务</p><p>5、调用session.close()关闭会话</p><h1 id="jdbc编程有哪些不足之处mybatis是如何解决这些问题的"><a class="markdownIt-Anchor" href="#jdbc编程有哪些不足之处mybatis是如何解决这些问题的"></a> JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>解决：在SqlMapConfig。xml中配置数据链接池，使用连接池管理数据库链接。</p><p>2、Sql语句写在代码中造成代码不易维护，实际应用sq！变化的可能较大，sq！变动需要改变java代码。</p><p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p><p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>解决：Mybatis自动将java对象映射至sql语句。</p><p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p>解决：Mybatis自动将Sql执行结果映射至java对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mybatis编程步骤是什么样的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mybatis编程步骤是什么样的&quot;&gt;&lt;/a&gt; MyBatis编程步骤是什么样的?&lt;/h1&gt;
&lt;p&gt;1、创建SqlSessionFactory&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PUT请求和POST请求的区别</title>
    <link href="https://arthersun.github.io/2022/11/15/PUT%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/11/15/PUT%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-15T07:47:10.000Z</published>
    <updated>2022-11-15T08:09:44.361Z</updated>
    
    <content type="html"><![CDATA[<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST <a href="http://www.forum.com/articles%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%9C%A8http://www.forum.com/articles%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E5%B8%96%E5%AD%90%EF%BC%8CHTTP%E5%93%8D%E5%BA%94%E4%B8%AD%E5%BA%94%E5%8C%85%E5%90%AB%E5%B8%96%E5%AD%90%E7%9A%84%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%B8%96%E5%AD%90%E7%9A%84URI%E3%80%82%E4%B8%A4%E6%AC%A1%E7%9B%B8%E5%90%8C%E7%9A%84POST%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%88%9B%E5%BB%BA%E4%B8%A4%E4%BB%BD%E8%B5%84%E6%BA%90%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%85%B7%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84URI%EF%BC%9B%E6%89%80%E4%BB%A5%EF%BC%8CPOST%E6%96%B9%E6%B3%95%E4%B8%8D%E5%85%B7%E5%A4%87%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%82%E8%80%8CPUT%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84URI%E6%98%AF%E8%A6%81%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0%E7%9A%84%E8%B5%84%E6%BA%90%E6%9C%AC%E8%BA%AB%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%9APUT">http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT</a> <a href="http://www.forum/articles/4231%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0ID%E4%B8%BA4231%E7%9A%84%E5%B8%96%E5%AD%90%E3%80%82%E5%AF%B9%E5%90%8C%E4%B8%80URI%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1PUT%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%80%E6%AC%A1PUT%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%9B%E5%9B%A0%E6%AD%A4%EF%BC%8CPUT%E6%96%B9%E6%B3%95%E5%85%B7%E6%9C%89%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%82">http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</a></p><p>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</p><h1 id="幂等设计"><a class="markdownIt-Anchor" href="#幂等设计"></a> 幂等设计</h1><p>分布式事务 vs 幂等设计<br>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。</p><p>这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int create_ticket()</span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST &lt;a href=&quot;http://www.forum.com/articles%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%9C%A8http://www.forum</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GET请求和POST请求的区别</title>
    <link href="https://arthersun.github.io/2022/11/15/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/11/15/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-15T06:37:56.000Z</published>
    <updated>2022-11-15T06:38:52.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用上的区别"><a class="markdownIt-Anchor" href="#使用上的区别"></a> 使用上的区别：</h1><p>GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。</p><p>GET方式提交的数据有长度限制，则POST的数据则可以非常大〞，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</p><p>POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</p><h1 id="本质区别"><a class="markdownIt-Anchor" href="#本质区别"></a> 本质区别</h1><p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。</p><p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用上的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用上的区别&quot;&gt;&lt;/a&gt; 使用上的区别：&lt;/h1&gt;
&lt;p&gt;GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP常用的请求方式</title>
    <link href="https://arthersun.github.io/2022/11/15/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
    <id>https://arthersun.github.io/2022/11/15/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</id>
    <published>2022-11-15T06:34:48.000Z</published>
    <updated>2022-11-15T07:43:03.779Z</updated>
    
    <content type="html"><![CDATA[<p>GET 获取资源</p><p>POST 传输实体主体</p><p>PUT 上传文件</p><p>DELETE 删除文件</p><p>HEAD 和GET方法类似，但只返回报文首部，不返回报文实体主体部分</p><p>PATCH 对资源进行部分修改</p><p>OPTIONS 查询指定的URL支持的方法</p><p>CONNECT 要求用隧道协议进行代理</p><p>TRACE 服务器会将通信路径返回给客户端</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GET 获取资源&lt;/p&gt;
&lt;p&gt;POST 传输实体主体&lt;/p&gt;
&lt;p&gt;PUT 上传文件&lt;/p&gt;
&lt;p&gt;DELETE 删除文件&lt;/p&gt;
&lt;p&gt;HEAD 和GET方法类似，但只返回报文首部，不返回报文实体主体部分&lt;/p&gt;
&lt;p&gt;PATCH 对资源进行部分修改&lt;/p&gt;
&lt;p&gt;OP</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="https://arthersun.github.io/2022/11/15/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://arthersun.github.io/2022/11/15/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2022-11-15T06:28:48.000Z</published>
    <updated>2022-11-15T06:34:11.248Z</updated>
    
    <content type="html"><![CDATA[<p>常见状态码：</p><p>200：服务器正确处理了请求。</p><p>301：（永久移动）请求的网页已永久移动到新位置。服务器返回该响应（对GET或HEAD请求的相应）时，会自动将请求者转到新位置。</p><p>302：（临时移动）服务器目前从不同位置的网页相应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>400：客户端请求有语法错误，不能被服务器所理解。</p><p>403：服务器收到请求，但是拒绝提供服务。</p><p>404：（未找到）服务器找不到请求的网页。</p><p>500：（服务器内部错误）服务器遇到错误，无法完成请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见状态码：&lt;/p&gt;
&lt;p&gt;200：服务器正确处理了请求。&lt;/p&gt;
&lt;p&gt;301：（永久移动）请求的网页已永久移动到新位置。服务器返回该响应（对GET或HEAD请求的相应）时，会自动将请求者转到新位置。&lt;/p&gt;
&lt;p&gt;302：（临时移动）服务器目前从不同位置的网页相应请求，</summary>
      
    
    
    
    
  </entry>
  
</feed>
