<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2022-11-24T15:56:09.954Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深夜碎碎念</title>
    <link href="https://arthersun.github.io/2022/11/24/%E6%B7%B1%E5%A4%9C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://arthersun.github.io/2022/11/24/%E6%B7%B1%E5%A4%9C%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2022-11-24T15:43:45.000Z</published>
    <updated>2022-11-24T15:56:09.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深夜碎碎念"><a class="markdownIt-Anchor" href="#深夜碎碎念"></a> 深夜碎碎念</h1><p>最难的几年莫过于读研</p><p>那种受挫后不断反思，不断揉碎自己重塑价值的过程，是煎熬啊</p><p>越长大越沉默，是看到很多事情后发现懒得解释，懒得沟通，就这样吧，说话也挺累的</p><p>好在善意的人还是挺多的</p><p>加油吧少年，为了自己的生活</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深夜碎碎念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#深夜碎碎念&quot;&gt;&lt;/a&gt; 深夜碎碎念&lt;/h1&gt;
&lt;p&gt;最难的几年莫过于读研&lt;/p&gt;
&lt;p&gt;那种受挫后不断反思，不断揉碎自己重塑价值的过程，是煎熬啊&lt;/p&gt;
&lt;p&gt;越长大越沉默，是看</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap原理</title>
    <link href="https://arthersun.github.io/2022/11/24/ConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
    <id>https://arthersun.github.io/2022/11/24/ConcurrentHashMap%E5%8E%9F%E7%90%86/</id>
    <published>2022-11-24T15:43:09.000Z</published>
    <updated>2022-11-24T15:43:33.774Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>值传递和引用传递</title>
    <link href="https://arthersun.github.io/2022/11/24/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://arthersun.github.io/2022/11/24/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2022-11-24T13:38:54.000Z</published>
    <updated>2022-11-24T13:38:54.148Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>类加载子系统</title>
    <link href="https://arthersun.github.io/2022/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://arthersun.github.io/2022/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-11-21T02:11:32.000Z</published>
    <updated>2022-11-21T02:33:25.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载子系统"><a class="markdownIt-Anchor" href="#类加载子系统"></a> 类加载子系统</h1><p>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载子系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类加载子系统&quot;&gt;&lt;/a&gt; 类加载子系统&lt;/h1&gt;
&lt;p&gt;类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。&lt;/p&gt;
&lt;p&gt;Cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池相关</title>
    <link href="https://arthersun.github.io/2022/11/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <id>https://arthersun.github.io/2022/11/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</id>
    <published>2022-11-20T07:43:41.000Z</published>
    <updated>2022-11-20T08:18:30.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池相关"><a class="markdownIt-Anchor" href="#线程池相关"></a> 线程池相关</h1><p>ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量。</p><p>| 状态名 | 接收新任务 | 处理阻塞队列任务 | 说明 |<br>| Running | Y | Y |<br>| Shutdown | N | N | 不会接收新任务，但会处理阻塞队列剩余任务 |<br>| Stop | N | N | 会中断正在执行的任务，并抛弃阻塞队列任务 |<br>| Tidying | - | - | 任务全执行完毕，活动线程为0即将进入终结 |<br>| Terminated | - | - | 终结状态 |</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池相关&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池相关&quot;&gt;&lt;/a&gt; 线程池相关&lt;/h1&gt;
&lt;p&gt;ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量。&lt;/p&gt;
&lt;p&gt;| 状态名 | </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>try-catch-finally执行顺序</title>
    <link href="https://arthersun.github.io/2022/11/18/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://arthersun.github.io/2022/11/18/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-11-18T03:20:25.000Z</published>
    <updated>2022-11-19T01:42:28.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="try-catch-finally执行顺序"><a class="markdownIt-Anchor" href="#try-catch-finally执行顺序"></a> try-catch-finally执行顺序</h1><p>1、不管有没有出现异常，finally块中的代码都会执行；</p><p>2、当try和catch中有return时，finally仍然会执行；</p><p>3、finally是在return后面的表达式运算后执行的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;try-catch-finally执行顺序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#try-catch-finally执行顺序&quot;&gt;&lt;/a&gt; try-catch-finally执行顺序&lt;/h1&gt;
&lt;p&gt;1、不管有没有出现异常，fin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchonized锁升级流程</title>
    <link href="https://arthersun.github.io/2022/11/17/synchonized%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/11/17/synchonized%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/</id>
    <published>2022-11-17T02:56:53.000Z</published>
    <updated>2022-11-17T03:01:00.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized锁升级"><a class="markdownIt-Anchor" href="#synchronized锁升级"></a> synchronized锁升级</h1><p>根据上面内容可以知道，synchronized锁有四种状态：无锁，偏向锁、轻量级锁和重量级锁，下面介绍四种状态和其之间的转换。</p><p>2.1 无锁</p><p>当一个对象被创建之后，还没有线程进入，这个时候对象处于无锁状态，其Mark Word中的信息如上表所示。</p><p>2.2 偏向锁</p><p>当锁处于无锁状态时，有一个线程A访问同步块并获取锁时，会在对象头和栈帧中的锁记录记录线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来进行加锁和解锁，只需要简单的测试一下啊对象头中的线程ID和当前线程是否一致。</p><p>2.3 轻量级锁</p><p>在偏向锁的基础上，又有另外一个线程B进来，这时判断对象头中存储的线程A的ID和线程B不一致，就会使用CAS竞争锁，并且升级为轻量级锁，会在线程栈中创建一个锁记录(lock Record)，将Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头的Mark Word替换成指向锁记录的指针，如果成功，则当前线程获得锁；失败，表示其他线程竞争锁，当前线程便尝试CAS来获取锁。</p><p>2.4 重量级锁</p><p>当线程没有获得轻量级锁时，线程会CAS自旋来获取锁，当一个线程自旋10次之后，仍然未获得锁，那么就会升级成为重量级锁。</p><p>成为重量级锁之后，线程会进入阻塞队列(EntryList)，线程不再自旋获取锁，而是由CPU进行调度，线程串行执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;synchronized锁升级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#synchronized锁升级&quot;&gt;&lt;/a&gt; synchronized锁升级&lt;/h1&gt;
&lt;p&gt;根据上面内容可以知道，synchronized锁有四种状态：无锁，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mybatis八股</title>
    <link href="https://arthersun.github.io/2022/11/16/mybatis%E5%85%AB%E8%82%A1/"/>
    <id>https://arthersun.github.io/2022/11/16/mybatis%E5%85%AB%E8%82%A1/</id>
    <published>2022-11-16T13:56:54.000Z</published>
    <updated>2022-11-17T02:49:05.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis编程步骤是什么样的"><a class="markdownIt-Anchor" href="#mybatis编程步骤是什么样的"></a> MyBatis编程步骤是什么样的?</h1><p>1、创建SqlSessionFactory</p><p>2、通过SqlSessionFactory创建Sql Session</p><p>3、通过sqlsession执行数据库操作</p><p>4、调用session.commit()提交事务</p><p>5、调用session.close()关闭会话</p><h1 id="jdbc编程有哪些不足之处mybatis是如何解决这些问题的"><a class="markdownIt-Anchor" href="#jdbc编程有哪些不足之处mybatis是如何解决这些问题的"></a> JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>解决：在SqlMapConfig。xml中配置数据链接池，使用连接池管理数据库链接。</p><p>2、Sql语句写在代码中造成代码不易维护，实际应用sq！变化的可能较大，sq！变动需要改变java代码。</p><p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p><p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>解决：Mybatis自动将java对象映射至sql语句。</p><p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p>解决：Mybatis自动将Sql执行结果映射至java对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mybatis编程步骤是什么样的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mybatis编程步骤是什么样的&quot;&gt;&lt;/a&gt; MyBatis编程步骤是什么样的?&lt;/h1&gt;
&lt;p&gt;1、创建SqlSessionFactory&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PUT请求和POST请求的区别</title>
    <link href="https://arthersun.github.io/2022/11/15/PUT%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/11/15/PUT%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-15T07:47:10.000Z</published>
    <updated>2022-11-15T08:09:44.361Z</updated>
    
    <content type="html"><![CDATA[<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST <a href="http://www.forum.com/articles%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%9C%A8http://www.forum.com/articles%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E5%B8%96%E5%AD%90%EF%BC%8CHTTP%E5%93%8D%E5%BA%94%E4%B8%AD%E5%BA%94%E5%8C%85%E5%90%AB%E5%B8%96%E5%AD%90%E7%9A%84%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%B8%96%E5%AD%90%E7%9A%84URI%E3%80%82%E4%B8%A4%E6%AC%A1%E7%9B%B8%E5%90%8C%E7%9A%84POST%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%88%9B%E5%BB%BA%E4%B8%A4%E4%BB%BD%E8%B5%84%E6%BA%90%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%85%B7%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84URI%EF%BC%9B%E6%89%80%E4%BB%A5%EF%BC%8CPOST%E6%96%B9%E6%B3%95%E4%B8%8D%E5%85%B7%E5%A4%87%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%82%E8%80%8CPUT%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84URI%E6%98%AF%E8%A6%81%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0%E7%9A%84%E8%B5%84%E6%BA%90%E6%9C%AC%E8%BA%AB%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%9APUT">http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT</a> <a href="http://www.forum/articles/4231%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0ID%E4%B8%BA4231%E7%9A%84%E5%B8%96%E5%AD%90%E3%80%82%E5%AF%B9%E5%90%8C%E4%B8%80URI%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1PUT%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%80%E6%AC%A1PUT%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%9B%E5%9B%A0%E6%AD%A4%EF%BC%8CPUT%E6%96%B9%E6%B3%95%E5%85%B7%E6%9C%89%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%82">http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</a></p><p>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</p><h1 id="幂等设计"><a class="markdownIt-Anchor" href="#幂等设计"></a> 幂等设计</h1><p>分布式事务 vs 幂等设计<br>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。</p><p>这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int create_ticket()</span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST &lt;a href=&quot;http://www.forum.com/articles%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%9C%A8http://www.forum</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GET请求和POST请求的区别</title>
    <link href="https://arthersun.github.io/2022/11/15/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/11/15/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-15T06:37:56.000Z</published>
    <updated>2022-11-15T06:38:52.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用上的区别"><a class="markdownIt-Anchor" href="#使用上的区别"></a> 使用上的区别：</h1><p>GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。</p><p>GET方式提交的数据有长度限制，则POST的数据则可以非常大〞，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</p><p>POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</p><h1 id="本质区别"><a class="markdownIt-Anchor" href="#本质区别"></a> 本质区别</h1><p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。</p><p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用上的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用上的区别&quot;&gt;&lt;/a&gt; 使用上的区别：&lt;/h1&gt;
&lt;p&gt;GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP常用的请求方式</title>
    <link href="https://arthersun.github.io/2022/11/15/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
    <id>https://arthersun.github.io/2022/11/15/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</id>
    <published>2022-11-15T06:34:48.000Z</published>
    <updated>2022-11-15T07:43:03.779Z</updated>
    
    <content type="html"><![CDATA[<p>GET 获取资源</p><p>POST 传输实体主体</p><p>PUT 上传文件</p><p>DELETE 删除文件</p><p>HEAD 和GET方法类似，但只返回报文首部，不返回报文实体主体部分</p><p>PATCH 对资源进行部分修改</p><p>OPTIONS 查询指定的URL支持的方法</p><p>CONNECT 要求用隧道协议进行代理</p><p>TRACE 服务器会将通信路径返回给客户端</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GET 获取资源&lt;/p&gt;
&lt;p&gt;POST 传输实体主体&lt;/p&gt;
&lt;p&gt;PUT 上传文件&lt;/p&gt;
&lt;p&gt;DELETE 删除文件&lt;/p&gt;
&lt;p&gt;HEAD 和GET方法类似，但只返回报文首部，不返回报文实体主体部分&lt;/p&gt;
&lt;p&gt;PATCH 对资源进行部分修改&lt;/p&gt;
&lt;p&gt;OP</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="https://arthersun.github.io/2022/11/15/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://arthersun.github.io/2022/11/15/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2022-11-15T06:28:48.000Z</published>
    <updated>2022-11-15T06:34:11.248Z</updated>
    
    <content type="html"><![CDATA[<p>常见状态码：</p><p>200：服务器正确处理了请求。</p><p>301：（永久移动）请求的网页已永久移动到新位置。服务器返回该响应（对GET或HEAD请求的相应）时，会自动将请求者转到新位置。</p><p>302：（临时移动）服务器目前从不同位置的网页相应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>400：客户端请求有语法错误，不能被服务器所理解。</p><p>403：服务器收到请求，但是拒绝提供服务。</p><p>404：（未找到）服务器找不到请求的网页。</p><p>500：（服务器内部错误）服务器遇到错误，无法完成请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见状态码：&lt;/p&gt;
&lt;p&gt;200：服务器正确处理了请求。&lt;/p&gt;
&lt;p&gt;301：（永久移动）请求的网页已永久移动到新位置。服务器返回该响应（对GET或HEAD请求的相应）时，会自动将请求者转到新位置。&lt;/p&gt;
&lt;p&gt;302：（临时移动）服务器目前从不同位置的网页相应请求，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AOP和拦截器</title>
    <link href="https://arthersun.github.io/2022/11/14/AOP%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://arthersun.github.io/2022/11/14/AOP%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2022-11-14T13:45:17.000Z</published>
    <updated>2022-11-15T06:28:39.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="aop原理"><a class="markdownIt-Anchor" href="#aop原理"></a> AOP原理</h1><ol><li>创建代理对象阶段</li></ol><p>在Spring中，创建Bean实例都是从getBean()方法开始的，在实例创建之后，Spring容器将根据AOP的配置去匹配目标类的类名，看目标类的类名是否满足切面规则。</p><p>如果满足切面规则，就会调用ProxyFactory创建代理Bean并缓存到IOC容器中。根据目标对象的自动选择不同的代理策略。如果目标类实现了接口，Spring会默认选择JDK Proxy，如果目标类没有实现接口，Spring会默认选择Cglib Proxy。</p><ol start="2"><li>拦截目标对象阶段</li></ol><p>当用户调用目标对象的某个方法时，将会被一个叫做AopProxy的对象拦截，Spring将所有的调用策略封装到了这个对象中，它默认实现了InvocationHandler接口，也就是调用代理对象的外层拦截器。在这个接口的invoke()方法中，会出发MethodInvocation的proceed()方法。在这个方法中会按顺序执行符合所有AOP拦截规则的拦截器链。</p><ol start="3"><li>调用代理对象阶段</li></ol><p>Spring AOP拦截器链中的每个元素被命名为MethodInterceptor，其实就是切面配置中的Advice通知。这个回调可以简单地理解为是新生成的代理Bean中的方法。也就是我们常说的被织入的代码片段，这些被织入的代码片段会在这个阶段执行。</p><ol start="4"><li>调用目标对象阶段</li></ol><p>MethodInterceptor接口也有一个invoke()方法，在MethodInterceptor的invoke()方法中会触发对目标对象方法的调用，也就是反射调用目标对象的方法。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>流程：</p><ol><li><p>代理对象：就是由Spring代理策略生成的对象；</p></li><li><p>目标对象：就是我们自己写的业务代码；</p></li><li><p>织入代码：就是要在我们自己写的业务代码增加的代码片段；</p></li><li><p>切面通知：就是封装织入代码片段的回调方法；</p></li><li><p>MethodInvocation：负责执行拦截器链，在proceed()方法中执行；</p></li><li><p>MethodInterceptor：负责执行织入的代码片段，在invoke()方法中执行。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;aop原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#aop原理&quot;&gt;&lt;/a&gt; AOP原理&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;创建代理对象阶段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Spring中，创建Bean实例都是从getBean()方法开始的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://arthersun.github.io/2022/11/14/%E6%AD%BB%E9%94%81/"/>
    <id>https://arthersun.github.io/2022/11/14/%E6%AD%BB%E9%94%81/</id>
    <published>2022-11-14T10:57:35.000Z</published>
    <updated>2022-11-14T11:25:03.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><p>死锁，就是说两个或两个以上的线程在执行的过程中，去争夺同一个共享资源导致相互等待的现象。如果没有外部干预，线程会一直处于阻塞状态，无法往下执行。这样一直等待处于阻塞状态的线程，被称为死锁线程。</p><h1 id="产生死锁的原因"><a class="markdownIt-Anchor" href="#产生死锁的原因"></a> 产生死锁的原因</h1><p>产生死锁需要同时满足以下四个条件：</p><ol><li>互斥条件，共享资源a和b只能被一个线程占用</li><li>请求和保持条件，线程T1已经获取共享资源a，在等待共享资源b的时候，不释放共享资源a</li><li>不可抢占条件，其他线程不能强行抢占线程T1占有的资源</li><li>循环等待条件，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，这形成了循环等待</li></ol><h1 id="如何避免死锁"><a class="markdownIt-Anchor" href="#如何避免死锁"></a> 如何避免死锁</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#死锁&quot;&gt;&lt;/a&gt; 死锁&lt;/h1&gt;
&lt;p&gt;死锁，就是说两个或两个以上的线程在执行的过程中，去争夺同一个共享资源导致相互等待的现象。如果没有外部干预，线程会一直处于阻塞状态，无法往下执行。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内存溢出和内存泄漏</title>
    <link href="https://arthersun.github.io/2022/11/14/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://arthersun.github.io/2022/11/14/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2022-11-14T10:48:49.000Z</published>
    <updated>2022-11-14T10:57:27.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存溢出"><a class="markdownIt-Anchor" href="#内存溢出"></a> 内存溢出</h1><p>JVM中可用内存空间存不下了，比如只有3M，但现在要创建一个5M的对象，新创建的就放不进去了。</p><h1 id="内存泄漏"><a class="markdownIt-Anchor" href="#内存泄漏"></a> 内存泄漏</h1><p>在业务代码执行过程中，有些对象它应该被回收，但是又有其他对象引用它，因此，GC不能自动回收。最终会导致内存泄漏。</p><h1 id="如何避免"><a class="markdownIt-Anchor" href="#如何避免"></a> 如何避免</h1><p>特别是一些流对象，比如OutputStream，Reader，BitMap，Document，很容易忘掉close。最麻烦的是要顺序回收，顺序错了还会产生空指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存溢出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存溢出&quot;&gt;&lt;/a&gt; 内存溢出&lt;/h1&gt;
&lt;p&gt;JVM中可用内存空间存不下了，比如只有3M，但现在要创建一个5M的对象，新创建的就放不进去了。&lt;/p&gt;
&lt;h1 id=&quot;内存泄漏&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>逐层排序二叉树所需的最少操作数目</title>
    <link href="https://arthersun.github.io/2022/11/14/%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE/"/>
    <id>https://arthersun.github.io/2022/11/14/%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE/</id>
    <published>2022-11-14T04:41:42.000Z</published>
    <updated>2022-11-14T05:45:02.185Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><p>给你一个 值互不相同 的二叉树的根节点 root 。</p><p>在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。</p><p>返回每一层按 严格递增顺序 排序所需的最少操作数目。</p><p>节点的 层数 是该节点和根节点之间的路径的边数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 4 和 3 。第 2 层变为 [3,4] 。</span><br><span class="line">- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。</span><br><span class="line">- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。</span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure><p>思路：</p><p>使用置换环算法得到数组排序需要的最小交换次数。</p><p>具体实现思想：</p><ol><li>使用Map记录每个节点值及其应该放到的位置</li><li>从头到尾遍历初始数组，使用flag[]数组标记当前元素是否已经参与过（即已经被加入环中），对已经参与过的数组则不再需要遍历。每次成环结束，记录成环个数loop。</li><li>最终最小交换次数为：数组长度-成环个数 nums.size()-loop</li></ol><p><img src="/2022/11/14/%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE/%E7%BD%AE%E6%8D%A2%E7%8E%AF.jpg" alt="置换环"></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    // 返回使得 nums 递增需要的最小交换元素次数</span><br><span class="line">    public int minChanges(int[] nums)&#123;</span><br><span class="line">        int[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;copy.length; i++)&#123;</span><br><span class="line">            map.put(copy[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] flag = new boolean[nums.length];  // 用于标记 nums[i] 是否已经被加入环中</span><br><span class="line">        int loop = 0; // 环的个数</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(!flag[i])&#123;</span><br><span class="line">                int j = i;</span><br><span class="line">                while(!flag[j])&#123; // 画环</span><br><span class="line">                    int index = map.get(nums[j]); // 当前节点指向的位置，画环过程</span><br><span class="line">                    flag[j] = true; // 将 j 加入环中</span><br><span class="line">                    j = index; // 将当前节点移动到环上下个节点</span><br><span class="line">                &#125;</span><br><span class="line">                loop++; // 环数递增</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.length - loop; // 最小交换次数为 ： 数组长度 - 环数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：晚晴🌤</span><br><span class="line">链接：https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/solutions/1965867/by-liu-wan-qing-zjlj/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;给你一个 值互不相同 的二叉树的根节点 root 。&lt;/p&gt;
&lt;p&gt;在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。&lt;/p&gt;
&lt;p&gt;返回每一层按 严格递增顺序 排序所需的最少操作数目。&lt;/p&gt;
&lt;p&gt;节点的 层数 是该节点和根节点</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最小公倍数为K的子数组数目</title>
    <link href="https://arthersun.github.io/2022/11/14/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://arthersun.github.io/2022/11/14/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</id>
    <published>2022-11-14T04:11:37.000Z</published>
    <updated>2022-11-14T04:41:10.827Z</updated>
    
    <content type="html"><![CDATA[<p>辗转相除法：</p><p>用大数对小数求余，若余数为0，则除数为最大公约数。若余数不为0，将此余数作为除数，小数作为被除数，重新求余，直到余数为0为止。此时的最大公约数为余数。</p><p>例如：27和6.  27%6=3.  6%3=0.  所以最大公约数为3.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int gcd(int a, int b)&#123;</span><br><span class="line">        while (b != 0)&#123;</span><br><span class="line">            int tmp = a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最大公约数和最小公倍数的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个数的乘积等于这两个数的最大公约数与最小公倍数的乘积。假设有两个数是a、b，它</span><br><span class="line">们的最大公约数是B，最小公倍数是q。那么存在这样的关系式：ab=pg。</span><br></pre></td></tr></table></figure><p>于是代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int subarrayLCM(int[] nums, int k) &#123;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int cur = nums[i];</span><br><span class="line">            for(int j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">                cur = cur*nums[j]/gcd(cur,nums[j]);</span><br><span class="line">                if(cur==k)&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;else if(cur&gt;k)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用辗转相除法写gcd</span><br><span class="line">    public int gcd(int a, int b)&#123;</span><br><span class="line">        while(b!=0)&#123;</span><br><span class="line">            int temp = a%b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;辗转相除法：&lt;/p&gt;
&lt;p&gt;用大数对小数求余，若余数为0，则除数为最大公约数。若余数不为0，将此余数作为除数，小数作为被除数，重新求余，直到余数为0为止。此时的最大公约数为余数。&lt;/p&gt;
&lt;p&gt;例如：27和6.  27%6=3.  6%3=0.  所以最大公约数为3.&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>吾日三省吾身</title>
    <link href="https://arthersun.github.io/2022/11/13/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    <id>https://arthersun.github.io/2022/11/13/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/</id>
    <published>2022-11-13T06:54:16.000Z</published>
    <updated>2022-11-13T06:54:39.014Z</updated>
    
    <content type="html"><![CDATA[<p>越来越谦逊低调</p><p>不想说任何谎言</p><p>对别人也越来越宽容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;越来越谦逊低调&lt;/p&gt;
&lt;p&gt;不想说任何谎言&lt;/p&gt;
&lt;p&gt;对别人也越来越宽容&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>复习加密算法</title>
    <link href="https://arthersun.github.io/2022/11/13/%E5%A4%8D%E4%B9%A0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://arthersun.github.io/2022/11/13/%E5%A4%8D%E4%B9%A0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-11-13T03:51:02.000Z</published>
    <updated>2022-11-13T06:54:03.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复习加密算法"><a class="markdownIt-Anchor" href="#复习加密算法"></a> 复习加密算法</h1><h3 id="ecc椭圆曲线加密算法"><a class="markdownIt-Anchor" href="#ecc椭圆曲线加密算法"></a> ECC椭圆曲线加密算法</h3><p>椭圆曲线加密算法是基于椭圆曲线数学理论实现的一种非对称加密算法。</p><p>相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。</p><p>160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。</p><p>比特币使用了secp256k1这条特殊的椭圆曲线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y^2 = x^3 + 7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复习加密算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#复习加密算法&quot;&gt;&lt;/a&gt; 复习加密算法&lt;/h1&gt;
&lt;h3 id=&quot;ecc椭圆曲线加密算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ecc椭圆曲</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>便捷版快排</title>
    <link href="https://arthersun.github.io/2022/11/12/%E4%BE%BF%E6%8D%B7%E7%89%88%E5%BF%AB%E6%8E%92/"/>
    <id>https://arthersun.github.io/2022/11/12/%E4%BE%BF%E6%8D%B7%E7%89%88%E5%BF%AB%E6%8E%92/</id>
    <published>2022-11-12T13:16:52.000Z</published>
    <updated>2022-11-12T13:17:39.952Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line">private void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">int temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line">if (start &gt;= end)</span><br><span class="line">return;</span><br><span class="line">int k = arr[start];</span><br><span class="line">int i = start, j = end;</span><br><span class="line">while (i != j) &#123;</span><br><span class="line">while (i &lt; j &amp;&amp; arr[j] &gt;= k)</span><br><span class="line">--j;</span><br><span class="line">swap(arr, i, j);</span><br><span class="line">while (i &lt; j &amp;&amp; arr[i] &lt;= k)</span><br><span class="line">++i;</span><br><span class="line">swap(arr, i, j);</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr, start, i - 1);</span><br><span class="line">quickSort(arr, i + 1, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;5, 2, 6, 9, 1, 3, 4, 8, 7, 10&#125;;</span><br><span class="line">new QuickSort().quickSort(arr, 0, arr.length - 1);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
</feed>
