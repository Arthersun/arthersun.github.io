<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2022-12-08T07:22:07.212Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAP原理和它的例子</title>
    <link href="https://arthersun.github.io/2022/12/08/CAP%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%83%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <id>https://arthersun.github.io/2022/12/08/CAP%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%83%E7%9A%84%E4%BE%8B%E5%AD%90/</id>
    <published>2022-12-08T07:11:43.000Z</published>
    <updated>2022-12-08T07:22:07.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cap定理"><a class="markdownIt-Anchor" href="#cap定理"></a> CAP定理</h1><p>C：一致性，更新操作成功后，所有节点在同一时间的数据完全一致</p><p>A：可用性，请求发送后能在正确时间得到预期响应</p><p>P：分区容错性，分布式系统在遇到某节点或网络错误的时候，仍然能对外提供满足一致性或可用性的结果。</p><h1 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h1><p>订单系统-&gt;库存系统</p><p>业务功能：在下单后订单系统新建订单，会在库存系统减少库存</p><p>CP：满足一致性和分区容错性。下单后，用户等待库存系统减少后得到下单成功的结果</p><p>AP：满足可用性和分区容错性。下单后，订单系统创建订单，用户得到下单成功的结果，然后系统异步完成减少库存</p><p>CA：满足可用性和分区容错性。不拆分数据系统，在一个数据库的一个事务中完成操作，也就是单体应用</p><p>通俗来讲，在一个分布式系统中，一致性和可用性不能同时满足。如果同时满足，那么就是一个单体系统</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cap定理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cap定理&quot;&gt;&lt;/a&gt; CAP定理&lt;/h1&gt;
&lt;p&gt;C：一致性，更新操作成功后，所有节点在同一时间的数据完全一致&lt;/p&gt;
&lt;p&gt;A：可用性，请求发送后能在正确时间得到预期响应&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大数据技术生态</title>
    <link href="https://arthersun.github.io/2022/12/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81/"/>
    <id>https://arthersun.github.io/2022/12/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81/</id>
    <published>2022-12-07T15:38:58.000Z</published>
    <updated>2022-12-08T07:11:32.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hadoop"><a class="markdownIt-Anchor" href="#hadoop"></a> Hadoop</h1><p>Hadoop是一个分布式存储系统，使用HDFS存储分布式数据，解决单机数据存不下的问题，使用MapReduce并行计算，解决计算速度问题。</p><h1 id="hive"><a class="markdownIt-Anchor" href="#hive"></a> Hive</h1><p>Hive解决的是分布式场景下不能像传统数据库一样写SQL的问题</p><h1 id="spark"><a class="markdownIt-Anchor" href="#spark"></a> Spark</h1><p>Spark是基于内存的计算，非常快</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hadoop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hadoop&quot;&gt;&lt;/a&gt; Hadoop&lt;/h1&gt;
&lt;p&gt;Hadoop是一个分布式存储系统，使用HDFS存储分布式数据，解决单机数据存不下的问题，使用MapReduce并行计算，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="https://arthersun.github.io/2022/12/07/kafka/"/>
    <id>https://arthersun.github.io/2022/12/07/kafka/</id>
    <published>2022-12-07T12:19:28.000Z</published>
    <updated>2022-12-07T13:36:07.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为啥需要消息队列"><a class="markdownIt-Anchor" href="#为啥需要消息队列"></a> 为啥需要消息队列</h1><ol><li><p>异步：允许用户把一个消息放入队列，但不立即处理它，在需要的时候再去处理他它们</p></li><li><p>解耦：只要遵守同样的接口约束，就可以独立的扩展或修改两边的处理过程</p></li><li><p>缓冲/消峰：有利于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p></li></ol><h1 id="消息队列的模式"><a class="markdownIt-Anchor" href="#消息队列的模式"></a> 消息队列的模式</h1><ol><li><p>点对点模式：消费者一个个去消息队列中拉取数据。缺点是，消费者需要额外的线程去监控队列中是否有消息要被消费。</p></li><li><p>发布订阅模式：生产者将消息放入消息队列后，队列会将消息推送给订阅过该类信息的消费者，但消息队列由于无法感知消费者消费的速度，速度慢了会造成资源的浪费，速度快了会让速度慢的消费者无法承受。</p></li></ol><h1 id="kafka高吞吐量的分布式发布订阅消息系统"><a class="markdownIt-Anchor" href="#kafka高吞吐量的分布式发布订阅消息系统"></a> kafka：高吞吐量的分布式发布订阅消息系统</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为啥需要消息队列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为啥需要消息队列&quot;&gt;&lt;/a&gt; 为啥需要消息队列&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;异步：允许用户把一个消息放入队列，但不立即处理它，在需要的时候再去处理他它们&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于区块链的交易平台的功能流程</title>
    <link href="https://arthersun.github.io/2022/12/07/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/12/07/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2022-12-07T10:41:05.000Z</published>
    <updated>2022-12-07T12:19:18.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于区块链的交易平台的理想功能流程仅供参考"><a class="markdownIt-Anchor" href="#基于区块链的交易平台的理想功能流程仅供参考"></a> 基于区块链的交易平台的理想功能流程（仅供参考）</h1><p>转账：</p><ol><li><p>后端接收到前端传送的/issuecash请求，主要包含<code>转账金额</code>和<code>接收人</code></p></li><li><p>向区块链服务发送RPC请求，请求一个当前用户的金额，如果得到的金额小于转账金额，直接返回转账金额不够</p></li><li><p>向区块链服务发送RPC请求，这个请求包含转账金额和接收人，发起转账，</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于区块链的交易平台的理想功能流程仅供参考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于区块链的交易平台的理想功能流程仅供参考&quot;&gt;&lt;/a&gt; 基于区块链的交易平台的理想功能流程（仅供参考）&lt;/h1&gt;
&lt;p&gt;转账：&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hmdianping中的redis应用</title>
    <link href="https://arthersun.github.io/2022/12/07/hmdianping%E4%B8%AD%E7%9A%84redis%E5%BA%94%E7%94%A8/"/>
    <id>https://arthersun.github.io/2022/12/07/hmdianping%E4%B8%AD%E7%9A%84redis%E5%BA%94%E7%94%A8/</id>
    <published>2022-12-07T09:16:10.000Z</published>
    <updated>2022-12-07T10:34:40.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑马点评中redis的应用"><a class="markdownIt-Anchor" href="#黑马点评中redis的应用"></a> 黑马点评中redis的应用</h1><ol><li><p>短信登录：使用Redis共享session</p></li><li><p>查询缓存：缓存穿透、缓存雪崩解决</p></li><li><p>优惠券秒杀：Redis的计数器、分布式锁、Redis的三种消息队列</p></li><li><p>附近商户：Redis的GeoHash应用</p></li><li><p>UV统计：Redis的HyperLogLog的统计</p></li><li><p>用户签到：Redis的BitMap数据统计功能</p></li><li><p>好友关注：Set集合的关注、取关、共同关注、消息推送</p></li><li><p>达人探店：基于List的点赞列表，基于SortedSet的点赞排行榜</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;黑马点评中redis的应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#黑马点评中redis的应用&quot;&gt;&lt;/a&gt; 黑马点评中redis的应用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;短信登录：使用Redis共享session&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>stream流的一些妙用</title>
    <link href="https://arthersun.github.io/2022/12/05/stream%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E7%94%A8/"/>
    <id>https://arthersun.github.io/2022/12/05/stream%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E7%94%A8/</id>
    <published>2022-12-05T07:06:49.000Z</published>
    <updated>2022-12-05T07:31:28.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组最小值"><a class="markdownIt-Anchor" href="#求数组最小值"></a> 求数组最小值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(baseCosts).min().getAsInt()</span><br></pre></td></tr></table></figure><h1 id="装箱"><a class="markdownIt-Anchor" href="#装箱"></a> 装箱</h1><p>Arrays.stream(arr).boxed().toArray(Integer[]::new)</p><h1 id="拆箱"><a class="markdownIt-Anchor" href="#拆箱"></a> 拆箱</h1><p>Arrays.stream(integers).mapToInt(Integer::valueOf).toArray()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;求数组最小值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#求数组最小值&quot;&gt;&lt;/a&gt; 求数组最小值&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池参数和设置相关</title>
    <link href="https://arthersun.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
    <id>https://arthersun.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/</id>
    <published>2022-12-03T04:42:50.000Z</published>
    <updated>2022-12-03T04:55:21.147Z</updated>
    
    <content type="html"><![CDATA[<p>线程池参数设置是一个常考的难点，下面逐一进行分析</p><h1 id="任务拒绝策略"><a class="markdownIt-Anchor" href="#任务拒绝策略"></a> 任务拒绝策略</h1><p>任务拒绝策略具有不同的适用场景</p><ol><li><p>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常，是线程池默认的拒绝策略，抛出异常有利于帮助反馈程序的运行状态。所以在关键业务推荐使用此拒绝策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现。</p></li><li><p>DiscardPolicy：丢弃任务，不抛异常。由于可能无法发现系统异常状态，还得根据实际业务是否允许丢弃老任务来认真衡量。</p></li><li><p>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</p></li><li><p>CallerRunsPolicy：由调用线程（提交任务的线程）处理改任务。让所有任务都执行完毕，所以就适合大量计算的任务类型去执行。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程池参数设置是一个常考的难点，下面逐一进行分析&lt;/p&gt;
&lt;h1 id=&quot;任务拒绝策略&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#任务拒绝策略&quot;&gt;&lt;/a&gt; 任务拒绝策略&lt;/h1&gt;
&lt;p&gt;任务拒绝策略具有不同的适用场景&lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMS和G1收集器</title>
    <link href="https://arthersun.github.io/2022/11/29/CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://arthersun.github.io/2022/11/29/CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-11-29T05:21:27.000Z</published>
    <updated>2022-11-29T05:23:14.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="g1收集器"><a class="markdownIt-Anchor" href="#g1收集器"></a> G1收集器</h1><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p><p>空间整理：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</p><p>停顿是可以预测的</p><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;g1收集器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#g1收集器&quot;&gt;&lt;/a&gt; G1收集器&lt;/h1&gt;
&lt;p&gt;G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>又是悲痛又顿悟的一晚上</title>
    <link href="https://arthersun.github.io/2022/11/28/%E5%8F%88%E6%98%AF%E6%82%B2%E7%97%9B%E5%8F%88%E9%A1%BF%E6%82%9F%E7%9A%84%E4%B8%80%E6%99%9A%E4%B8%8A/"/>
    <id>https://arthersun.github.io/2022/11/28/%E5%8F%88%E6%98%AF%E6%82%B2%E7%97%9B%E5%8F%88%E9%A1%BF%E6%82%9F%E7%9A%84%E4%B8%80%E6%99%9A%E4%B8%8A/</id>
    <published>2022-11-28T15:11:06.000Z</published>
    <updated>2022-11-28T15:31:06.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="又是悲痛又顿悟的一晚上"><a class="markdownIt-Anchor" href="#又是悲痛又顿悟的一晚上"></a> 又是悲痛又顿悟的一晚上</h1><p>恻隐之心人皆有之。</p><p>有时候看着大家一脸着急的样子，突然明白自己无论如何伪装，在别人面前都是一眼透明。</p><p>大部分虽然自身也难保，但也是想要善意的帮助他人。</p><p>真诚真的是最大的杀器。</p><p>加油啊少年，不要辜负那么多人的善意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;又是悲痛又顿悟的一晚上&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#又是悲痛又顿悟的一晚上&quot;&gt;&lt;/a&gt; 又是悲痛又顿悟的一晚上&lt;/h1&gt;
&lt;p&gt;恻隐之心人皆有之。&lt;/p&gt;
&lt;p&gt;有时候看着大家一脸着急的样子，突然明白自己无论如何伪装，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>进程、线程、协程</title>
    <link href="https://arthersun.github.io/2022/11/28/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/11/28/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/</id>
    <published>2022-11-28T01:53:21.000Z</published>
    <updated>2022-11-28T15:06:41.601Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis和MySQL的数据一致性问题</title>
    <link href="https://arthersun.github.io/2022/11/27/Redis%E5%92%8CMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://arthersun.github.io/2022/11/27/Redis%E5%92%8CMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2022-11-27T13:14:39.000Z</published>
    <updated>2022-11-28T01:52:58.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于redis和mysql的架构如何保证数据一致性"><a class="markdownIt-Anchor" href="#基于redis和mysql的架构如何保证数据一致性"></a> 基于Redis和MySQL的架构，如何保证数据一致性</h1><ol><li><p>一般情况下，Redis是用作应用程序和数据库之间读操作的缓存，主要目的是减少数据库IO，提升数据查询性能。</p></li><li><p>一般流程：</p></li></ol><ul><li><ol><li>命中缓存，从缓存中加载数据</li></ol></li><li><ol start="2"><li>没有命中缓存，从数据库中加载数据</li></ol></li><li><ol start="3"><li>加载到的数据写入缓存</li></ol></li></ul><ol start="3"><li>存在的问题：</li></ol><p>当数据发生变化时，需要同时更新Redis和MySQL，可能出现一方更新失败，一方更新成功的情况，从而出现数据一致性问题。</p><ol start="4"><li>解决办法：</li></ol><ul><li><ol><li>先更新数据库，再更新缓存。如果缓存更新失败，就会导致数据库和Redis中的数据不一致。</li></ol></li><li><ol start="2"><li>先删除缓存，再更新数据库。这样下次访问Redis的时候，发现Redis中的数据是空的，这时候再加载。</li></ol></li><li>但是在极端情况下，我们并不能保证删除Redis和更新数据库这两个操作的原子性。在这个过程中，如果有其他线程访问的话，还是会有数据一致性问题。所以在极端情况下，需要采用最终一致性方案</li></ul><h2 id="最终一致性方案"><a class="markdownIt-Anchor" href="#最终一致性方案"></a> 最终一致性方案：</h2><ol><li><p>MySQL更新数据库的数据</p></li><li><p>更新Redis中的数据</p></li><li><p>失败的请求写入MQ事务消息</p></li><li><p>异步重试，确保成功</p></li></ol><p>还可以通过Canal组件监控binlog文件，从binlog中加载数据，然后同步到Redis中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于redis和mysql的架构如何保证数据一致性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于redis和mysql的架构如何保证数据一致性&quot;&gt;&lt;/a&gt; 基于Redis和MySQL的架构，如何保证数据一致性&lt;/h1&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外企的优势中英文版本</title>
    <link href="https://arthersun.github.io/2022/11/27/%E5%A4%96%E4%BC%81%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%AD%E8%8B%B1%E6%96%87%E7%89%88%E6%9C%AC/"/>
    <id>https://arthersun.github.io/2022/11/27/%E5%A4%96%E4%BC%81%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%AD%E8%8B%B1%E6%96%87%E7%89%88%E6%9C%AC/</id>
    <published>2022-11-26T18:19:47.000Z</published>
    <updated>2022-11-27T13:14:26.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外企的优势中英文版本"><a class="markdownIt-Anchor" href="#外企的优势中英文版本"></a> 外企的优势中英文版本</h1><ol><li>流程标准化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外企的优势中英文版本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#外企的优势中英文版本&quot;&gt;&lt;/a&gt; 外企的优势中英文版本&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;流程标准化&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS</title>
    <link href="https://arthersun.github.io/2022/11/25/HTTP%E5%92%8CHTTPS/"/>
    <id>https://arthersun.github.io/2022/11/25/HTTP%E5%92%8CHTTPS/</id>
    <published>2022-11-25T05:50:08.000Z</published>
    <updated>2022-11-25T05:57:04.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http和https的演进"><a class="markdownIt-Anchor" href="#http和https的演进"></a> HTTP和HTTPS的演进</h1><p>HTTP是TCP三次握手后就可以传输数据了</p><p>但是传输的是明文数据</p><h2 id="演进"><a class="markdownIt-Anchor" href="#演进"></a> 演进：</h2><ol><li><p>如果用对称加密，那需要每两个服务器和客户端商量一个秘钥，维护成本很高。</p></li><li><p>如果用非对称加密，因为公钥公开的，可以被黑客截获，它就可以用公钥解密，获取其中的内容。</p></li><li><p>如果用非对称加密和对称加密一起使用，非对称加密传输对称秘钥，对称秘钥加解密后传输，但这时无法确定是黑客还是中间人</p></li><li><p>使用SSL证书，证书中包括证书发布机构CA、证书有效期、公钥、证书所有者、签名，客户端收到服务器的SSL证书时，会对证书真伪进行检验。</p></li></ol><p>（1）首先浏览器读取证书中证书所有者、有效期等校验<br>（2）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http和https的演进&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#http和https的演进&quot;&gt;&lt;/a&gt; HTTP和HTTPS的演进&lt;/h1&gt;
&lt;p&gt;HTTP是TCP三次握手后就可以传输数据了&lt;/p&gt;
&lt;p&gt;但是传输的是明文数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JIT编译器</title>
    <link href="https://arthersun.github.io/2022/11/25/JIT%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>https://arthersun.github.io/2022/11/25/JIT%E7%BC%96%E8%AF%91%E5%99%A8/</id>
    <published>2022-11-25T04:53:42.000Z</published>
    <updated>2022-11-25T05:18:12.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jit编译器"><a class="markdownIt-Anchor" href="#jit编译器"></a> JIT编译器</h1><p>java从源代码到运行的过程如下图：</p><p>.java -&gt; javac编译 -&gt; .class -&gt; 解释器&amp;JIT -&gt; 机器可理解的代码</p><p>需要注意的是.class -&gt; 机器码 这一步。JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</p><p>且有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引入了JIT编译器，而JIT属于运行时编译。</p><p>当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可直接使用。</p><p>机器码的运行效率肯定是高于JAVA解释器的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jit编译器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jit编译器&quot;&gt;&lt;/a&gt; JIT编译器&lt;/h1&gt;
&lt;p&gt;java从源代码到运行的过程如下图：&lt;/p&gt;
&lt;p&gt;.java -&amp;gt; javac编译 -&amp;gt; .class -</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深夜碎碎念</title>
    <link href="https://arthersun.github.io/2022/11/24/%E6%B7%B1%E5%A4%9C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://arthersun.github.io/2022/11/24/%E6%B7%B1%E5%A4%9C%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2022-11-24T15:43:45.000Z</published>
    <updated>2022-11-24T15:56:09.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深夜碎碎念"><a class="markdownIt-Anchor" href="#深夜碎碎念"></a> 深夜碎碎念</h1><p>最难的几年莫过于读研</p><p>那种受挫后不断反思，不断揉碎自己重塑价值的过程，是煎熬啊</p><p>越长大越沉默，是看到很多事情后发现懒得解释，懒得沟通，就这样吧，说话也挺累的</p><p>好在善意的人还是挺多的</p><p>加油吧少年，为了自己的生活</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深夜碎碎念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#深夜碎碎念&quot;&gt;&lt;/a&gt; 深夜碎碎念&lt;/h1&gt;
&lt;p&gt;最难的几年莫过于读研&lt;/p&gt;
&lt;p&gt;那种受挫后不断反思，不断揉碎自己重塑价值的过程，是煎熬啊&lt;/p&gt;
&lt;p&gt;越长大越沉默，是看</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap原理</title>
    <link href="https://arthersun.github.io/2022/11/24/ConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
    <id>https://arthersun.github.io/2022/11/24/ConcurrentHashMap%E5%8E%9F%E7%90%86/</id>
    <published>2022-11-24T15:43:09.000Z</published>
    <updated>2022-11-24T15:43:33.774Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>值传递和引用传递</title>
    <link href="https://arthersun.github.io/2022/11/24/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://arthersun.github.io/2022/11/24/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2022-11-24T13:38:54.000Z</published>
    <updated>2022-11-24T13:38:54.148Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>类加载子系统</title>
    <link href="https://arthersun.github.io/2022/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://arthersun.github.io/2022/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-11-21T02:11:32.000Z</published>
    <updated>2022-11-21T02:33:25.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载子系统"><a class="markdownIt-Anchor" href="#类加载子系统"></a> 类加载子系统</h1><p>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载子系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类加载子系统&quot;&gt;&lt;/a&gt; 类加载子系统&lt;/h1&gt;
&lt;p&gt;类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。&lt;/p&gt;
&lt;p&gt;Cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池相关</title>
    <link href="https://arthersun.github.io/2022/11/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <id>https://arthersun.github.io/2022/11/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</id>
    <published>2022-11-20T07:43:41.000Z</published>
    <updated>2022-11-20T08:18:30.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池相关"><a class="markdownIt-Anchor" href="#线程池相关"></a> 线程池相关</h1><p>ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量。</p><p>| 状态名 | 接收新任务 | 处理阻塞队列任务 | 说明 |<br>| Running | Y | Y |<br>| Shutdown | N | N | 不会接收新任务，但会处理阻塞队列剩余任务 |<br>| Stop | N | N | 会中断正在执行的任务，并抛弃阻塞队列任务 |<br>| Tidying | - | - | 任务全执行完毕，活动线程为0即将进入终结 |<br>| Terminated | - | - | 终结状态 |</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池相关&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池相关&quot;&gt;&lt;/a&gt; 线程池相关&lt;/h1&gt;
&lt;p&gt;ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量。&lt;/p&gt;
&lt;p&gt;| 状态名 | </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>try-catch-finally执行顺序</title>
    <link href="https://arthersun.github.io/2022/11/18/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://arthersun.github.io/2022/11/18/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-11-18T03:20:25.000Z</published>
    <updated>2022-11-19T01:42:28.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="try-catch-finally执行顺序"><a class="markdownIt-Anchor" href="#try-catch-finally执行顺序"></a> try-catch-finally执行顺序</h1><p>1、不管有没有出现异常，finally块中的代码都会执行；</p><p>2、当try和catch中有return时，finally仍然会执行；</p><p>3、finally是在return后面的表达式运算后执行的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;try-catch-finally执行顺序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#try-catch-finally执行顺序&quot;&gt;&lt;/a&gt; try-catch-finally执行顺序&lt;/h1&gt;
&lt;p&gt;1、不管有没有出现异常，fin</summary>
      
    
    
    
    
  </entry>
  
</feed>
