<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2021-12-01T02:05:30.246Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s学习</title>
    <link href="https://arthersun.github.io/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/"/>
    <id>https://arthersun.github.io/2021/12/01/k8s%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-12-01T02:05:30.000Z</published>
    <updated>2021-12-01T02:05:30.246Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://arthersun.github.io/2021/11/30/2020-Guo/"/>
    <id>https://arthersun.github.io/2021/11/30/2020-Guo/</id>
    <published>2021-11-30T02:49:51.037Z</published>
    <updated>2021-11-30T02:50:38.728Z</updated>
    
    <content type="html"><![CDATA[<p>（1）我们设计了一种新的标签结构，它使用原始文件块的一组哈希值和特定的副本标识符来计算多个副本的验证标签。因此，只有这组散列值需要组织到IBMT中，并且IBMT的复杂性与副本的数量无关，这为三个副本节省了近66%的树存储成本。尽管这组哈希值适用于所有副本，但是可以使用特定的副本标识符来保证完整性证明确实来自已检查的副本。</p><p>(2)我们提出了一种平衡的ADS称为IBMT，它可以保证在任何更新情况下的预期do (logn)性能。然后，我们提出了一个批处理叶子验证(BLV)解决方案，可以同时验证多个有问题叶子的值和索引，而不需要重复的传输和计算。当检查三个副本，每个副本使用460个块时，与单独验证多个叶子相比，这减少了近43%的带宽成本。</p><p>(3)利用同态性质将被检查副本的多个证明聚合为一个证明，从而只需要传输和验证聚合证明。与逐个检查多个副本相比，当检查三个副本且每个副本有460个块时，审计师的计算时间提高了近40%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（1）我们设计了一种新的标签结构，它使用原始文件块的一组哈希值和特定的副本标识符来计算多个副本的验证标签。因此，只有这组散列值需要组织到IBMT中，并且IBMT的复杂性与副本的数量无关，这为三个副本节省了近66%的树存储成本。尽管这组哈希值适用于所有副本，但是可以使用特定的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2020_Huang</title>
    <link href="https://arthersun.github.io/2021/11/28/2020-Huang/"/>
    <id>https://arthersun.github.io/2021/11/28/2020-Huang/</id>
    <published>2021-11-28T07:25:46.000Z</published>
    <updated>2021-11-28T09:31:38.234Z</updated>
    
    <content type="html"><![CDATA[<p>系统架构：<br>PKG由一个完全可信的权威机构管理，该机构负责为整个系统设置公共参数，并为GM生成密钥对。</p><p>假设DO具有有限的通信、计算和存储资源。它根据需要生成并发送审计挑战给CSP，同时<strong>维护ACT来跟踪数据块的变化</strong>。</p><p>作为DOs的成员，GM是由某一组DOs共同指定的。然而，它被认为拥有比普通DOs更多的资源。</p><p>GM负责维护管理DOs的区块链分类帐，并在分类帐更新时将结果返回给他们。</p><p>CSP为DOs提供了重要的存储空间和计算能力。它还负责存储区块链，在收到审计质疑时响应证明。在我们的假设中，CSP可能是不诚实的，不同CSP之间存在商业竞争。</p><p>激励算法：</p><ol><li>区块链的另一个重要部分是激励机制，它可以鼓励共识节点诚实地重复某些任务并获得奖励，从而增强整个系统的分布式信任和结果的可靠性。在假设所有实体都是理性的基础上，我们大致提出了一种可行的激励机制，考虑到经济利益和不当行为：<br>DO（数据拥有者）需要购买信用来支付gm和csp的操作请求<br>在协商一致的过程中的每一次沟通将花费gm和csp的一部分信用。<br>如果CSP（服务提供商）拒绝DO（数据拥有者）的申请，信用评分将大幅下降，而DO除了已经支付的申请费外，还将得到额外的补偿。<br>GM只有在被管理的DO请求通过后才能获得信用奖励，否则GM既不盈利也不亏损。<br>如果当前回合成功达成最终共识，一个代表将会变大但呈线性增长，而其他共识节点将会变小但也呈线性增长。<br>DO可以根据信用评分自由选择任何CSP来存储数据，或选择任何GM来传输消息。如果信用评分低于某个阈值，现有的消费者就会选择另一家CSP或通用汽车。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;系统架构：&lt;br&gt;
PKG由一个完全可信的权威机构管理，该机构负责为整个系统设置公共参数，并为GM生成密钥对。&lt;/p&gt;
&lt;p&gt;假设DO具有有限的通信、计算和存储资源。它根据需要生成并发送审计挑战给CSP，同时&lt;strong&gt;维护ACT来跟踪数据块的变化&lt;/strong&gt;。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2019_Xu</title>
    <link href="https://arthersun.github.io/2021/11/24/2019-Xu/"/>
    <id>https://arthersun.github.io/2021/11/24/2019-Xu/</id>
    <published>2021-11-24T12:42:22.000Z</published>
    <updated>2021-11-24T15:01:56.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用智能合约来自动进行区块链审计</p></blockquote><p>这个区块链审计模型有三种实体：</p><ol><li>用户</li><li>网络存储服务提供商</li><li>公证节点</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用智能合约来自动进行区块链审计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个区块链审计模型有三种实体：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户&lt;/li&gt;
&lt;li&gt;网络存储服务提供商&lt;/li&gt;
&lt;li&gt;公证节点&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2020_Xu</title>
    <link href="https://arthersun.github.io/2021/11/24/2020-Xu/"/>
    <id>https://arthersun.github.io/2021/11/24/2020-Xu/</id>
    <published>2021-11-24T12:37:31.000Z</published>
    <updated>2021-11-24T15:35:56.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p></blockquote><p>基于双线性对技术的客户端数据重复数据删除方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于双线性对技术的客户端数据重复数据删除方案。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021_Nourah</title>
    <link href="https://arthersun.github.io/2021/11/24/2021-Nourah/"/>
    <id>https://arthersun.github.io/2021/11/24/2021-Nourah/</id>
    <published>2021-11-24T11:09:28.000Z</published>
    <updated>2021-11-24T11:09:56.907Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇解决云存储上重复数据删除的文章，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇解决云存储上重复数据删除的文章，&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>默克尔树</title>
    <link href="https://arthersun.github.io/2021/11/22/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/"/>
    <id>https://arthersun.github.io/2021/11/22/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/</id>
    <published>2021-11-22T14:24:43.000Z</published>
    <updated>2021-11-22T14:25:23.863Z</updated>
    
    <content type="html"><![CDATA[<h1>Merkle 树结构<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">默克尔树</a>（又叫哈希树）是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。默克尔树最早由 Merkle Ralf 在 1980 年提出，曾广泛用于文件系统和 P2P 系统中。</p><p>其主要特点为：</p><ul><li>最下面的叶节点包含存储数据或其哈希值。</li><li>非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。</li></ul><p>进一步地，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点的内容的哈希值。</p><p>默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。</p><p>目前，默克尔树的典型应用场景包括如下几种。</p><h1 id="证明某个集合中存在或不存在某个元素"><a class="markdownIt-Anchor" href="#证明某个集合中存在或不存在某个元素"></a> 证明某个集合中存在或不存在某个元素</h1><p>通过构建集合的默克尔树，并提供该元素各级兄弟节点中的 Hash 值，可以不暴露集合完整内容而证明某元素存在。</p><p>另外，对于可以进行排序的集合，可以将不存在元素的位置用空值代替，以此构建稀疏默克尔树（Sparse Merkle Tree）。该结构可以证明某个集合中不包括指定元素。</p><h1 id="快速比较大量数据"><a class="markdownIt-Anchor" href="#快速比较大量数据"></a> 快速比较大量数据</h1><p>对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着所代表的两组数据必然相同。否则，必然不同。</p><p>由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。</p><h1 id="快速定位修改"><a class="markdownIt-Anchor" href="#快速定位修改"></a> 快速定位修改</h1><p>以下图为例，基于数据 D0……D3 构造默克尔树，如果 D1 中数据被修改，会影响到 N1，N4 和 Root。</p><p><img src="https://yeasy.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-M5xTVjj6plOWgHcmTHq%2Fsync%2F01dd48b2fe29d3d5ba879d8eddfe6db037b13596.png?generation=1588030734755898&amp;alt=media" alt="img"></p><p>Merkle 树示例</p><p>因此，一旦发现某个节点如 Root 的数值发生变化，沿着 Root --&gt; N4 --&gt; N1，最多通过 O(lgN) 时间即可快速定位到实际发生改变的数据块 D1。</p><h1 id="零知识证明"><a class="markdownIt-Anchor" href="#零知识证明"></a> 零知识证明</h1><p>仍以上图为例，如何向他人证明拥有某个数据 D0 而不暴露其它信息。挑战者提供随机数据 D1，D2 和 D3，或由证明人生成（需要加入特定信息避免被人复用证明过程）。</p><p>证明人构造如图所示的默克尔树，公布 N1，N5，Root。验证者自行计算 Root 值，验证是否跟提供值一致，即可很容易检测 D0 存在。整个过程中验证者无法获知与 D0 相关的额外信息。</p></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Merkle 树结构
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot;&gt;默克尔树&lt;/a&gt;（又叫哈希树）是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。默克尔树最早由 Merkle Ralf 在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>11_20_项目组log_包括后几个月参与的任务</title>
    <link href="https://arthersun.github.io/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%BB%84log/"/>
    <id>https://arthersun.github.io/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%BB%84log/</id>
    <published>2021-11-20T02:27:34.000Z</published>
    <updated>2021-11-20T12:35:38.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间与实习时间</p></blockquote><p>4月份中期，整个项目3个月内干完</p><blockquote><p>参与的集成任务</p></blockquote><p>2月20号在corda上集成多对多拍卖<br>1月10号在corda上集成条件隐私保护<br>12月11日之前给出基本的激励智能合约机制的实现，到1月15日之前设计一个高级版的区块链的激励机制</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;时间与实习时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4月份中期，整个项目3个月内干完&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参与的集成任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2月20号在corda上集成多对多拍卖&lt;br&gt;
1月10号</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="https://arthersun.github.io/2021/11/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://arthersun.github.io/2021/11/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-11-19T13:40:08.000Z</published>
    <updated>2021-11-19T14:09:33.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>linux怎么查询端口号</p></blockquote><p>lsof -i:xxx (xxx是网络号)</p><blockquote><p>linux怎么杀死以PID为名的进程</p></blockquote><p>kill -9 PID</p><blockquote><p>linux怎么输出全局变量名</p></blockquote><p>echo $PATH</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;linux怎么查询端口号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;lsof -i:xxx (xxx是网络号)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;linux怎么杀死以PID为名的进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;kill -9 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开题要点</title>
    <link href="https://arthersun.github.io/2021/11/18/%E5%BC%80%E9%A2%98%E8%A6%81%E7%82%B9/"/>
    <id>https://arthersun.github.io/2021/11/18/%E5%BC%80%E9%A2%98%E8%A6%81%E7%82%B9/</id>
    <published>2021-11-18T02:49:42.000Z</published>
    <updated>2021-11-18T05:57:01.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开题报告</p></blockquote><p>题目：落实到方法，</p><p>解决问题 –&gt; 说人家的方法有问题<br>用人家的方法-&gt;说人家的方法好-&gt;可以为本文在xx场景下提供选择。</p><blockquote><p>问题</p></blockquote><p>干的事和问题不是同一个东西</p><p>设计算法的难点在哪</p><blockquote><p>3.1研究方法</p></blockquote><p>理论研究<br>实验<br>数据</p><blockquote><p>3.2技术路线</p></blockquote><p>针对本文的三个研究内容，分别阐述技术路线，具体如下。</p><blockquote><p>3.3可行性分析</p></blockquote><p>1.研究经验可借鉴<br>2.数据条件具备<br>3.实验环境具备<br>4.理论研究能力具备<br>5.实验能力具备<br>6.技术路线可行</p><blockquote><p>PPT</p></blockquote><p>参考文献不用写全名，写是哪个期刊上就行</p><p>研究现状能说清楚就不要贴图<br>从别人的论文中找现状的证据贴在PPT中</p><p>做case分析</p><p>根据产出主要实现哪两个难点，PPT有图放图，文档不用画。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开题报告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目：落实到方法，&lt;/p&gt;
&lt;p&gt;解决问题 –&amp;gt; 说人家的方法有问题&lt;br&gt;用人家的方法-&amp;gt;说人家的方法好-&amp;gt;可以为本文在xx场景下提供选择。&lt;/p&gt;
&lt;blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021_Yu</title>
    <link href="https://arthersun.github.io/2021/11/18/2021-Yu/"/>
    <id>https://arthersun.github.io/2021/11/18/2021-Yu/</id>
    <published>2021-11-18T02:26:35.000Z</published>
    <updated>2021-11-25T02:30:15.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p></blockquote><p>数据备份是云服务提供商(csp)为避免潜在的数据丢失风险而采取的普遍策略。因此，CSP通常在地理位置分布的服务器上为每个数据块维护多个副本，以提高可靠性。这种复制技术的一个关键问题是，存储的副本越多，用户需要支付的费用就越多。因此，需要一个审计服务来帮助用户验证不受信任的CSP是否将其所有副本存储在不同的地理位置。本文提出了一种动态多副本审计方案，该方案具有以下特点:(1)可同时验证云用户数据副本的完整性和地理位置;(2)该方案能够根据地理位置识别不同副本，降低了数据预处理、动态操作和备份恢复的复杂性;(3)通过引入索引默克尔哈希树(IMHT)，我们可以降低现有默克尔哈希树的总体成本。证明了该方案在随机oracle模型下的安全性，并与现有方案进行了全面比较。理论分析和实验评价表明，与现有方案相比，该方案降低了通信和计算成本。分析表明，该方案只需挑战90个数据块，就能实现99%的验证概率</p><blockquote><p>相关工作</p></blockquote><p>多副本云审计部分<br>Curtmola等人[22]首先提出了一种多副本可证明数据占有(MR-PDP)方案来验证云用户数据的多副本的完整性。他们的方案以及许多其他的多副本审计方案[7,23 - 25]采用对称加密方案生成不同的副本，然后为这些副本生成hvt。还有一些现有的方案[26-28]利用同态加密算法生成不同的副本。遗憾的是，所有这些方案都使用加密算法来区分多个副本，这导致在数据预处理、备份恢复和动态更新过程中加密副本的复杂性和效率低下。例如，云用户必须对其数据进行多次加密，才能生成所有加密的副本。同时，一个损坏的加密副本不能直接替换为一个完整的副本，否则将无法区分这些副本。</p><p>地理位置证明部分<br>Gondree和Peterson[31]提出了一个基于约束的数据地理定位方案，该方案利用地标来定位存储服务器。Fu等人[32]提出了[31]的补充方法，通过使用可信平台模块(TPM)来检测CSP伪造的假位置。然而，由于网络时延不稳定，这两种方案都产生了较大的测量误差。例如，Internet内的计时误差可能只有几毫秒，但即使是1毫秒的计时误差也会导致150km的距离误差[29]。</p><p>动态更新部分<br>Liu等人[7]提出了一种动态多副本云审计方案，其结构名为多副本MHT (MR-MHT)，将每个数据块的所有副本组织成一个副本子树。但是，为了防止替换攻击，他们的方案由于采用了映射到点的哈希函数，引入了MR-MHT计算叶子节点的额外开销。此外，由于提出的MHT结构的深度比普通MHT大得多，验证成本大大增加。</p><blockquote><p>多副本审计</p></blockquote><p>CSP通常在地理位置分布的服务器上为每个数据块维护多个副本，以提高可靠性。这种复制技术的一个关键问题是，存储的副本越多，用户需要支付的费用就越多。因此，需要一个审计服务来帮助用户验证不受信任的CSP是否将其所有副本存储在不同的地理位置。<br>总结：引入了地理位置来进行多副本的识别，从而降低了多副本审计数据结带来的消耗。</p><blockquote><blockquote><p>Wang的方案</p></blockquote><p>Wang et al. [18]等人提出了一个基于以太坊(Common区块链)的自动化审计架构，使用智能合约执行审计任务和薪酬相关补偿。Common区块链由于其共识节点规模大、激励机制有效，虽然可以有效地避免共谋攻击，但在大规模审计验证下难以达到可接受的执行效率。尽管Common区块链的效率更高，但仍然存在“无攻击”[19]。</p><p>没有有效的激励机制，就无法很好地抵御共谋攻击。PMAB以Common区块链为基础，通过有效的信用激励机制实现相互监督，加强了对csp审计数据的监督。[18]采用可验证延迟函数(VDF)实现自动审计;即系统自动生成安全随机源，在DOs不参与的情况下生成审计挑战，进一步降低了DOs的成本。然而，随机源的安全性来自于连续的计算功耗，这是不够有效的。因此，由于缺乏定制的审计协议区块链设计，现有的方案仍然遭受过多的开销和勾结攻击。</p><p>然而，上述公共审计方案具有集中的特性，即可信的TPA被授权审计来自数据所有者的外包数据。在实践中，很难找到像TPA这样诚实的组织。因此，去中心化审计协议更加合理</p></blockquote><blockquote><p>每个数据块更新</p></blockquote><p>每个数据块的更新将需要每个副本中相应的块的更新。如果所有副本都在各自独立的ADS中索引，客户机必须逐个验证这些更新以保持可验证性。</p><blockquote><p>双线性映射</p></blockquote><p>比如说矩阵乘法就是一种双线性映射。</p><blockquote><p>IMHT的验证算法</p></blockquote><p>​本质上利用了树形的特点，第一步先计算叶节点的哈希值，第二步利用邻接矩阵计算非叶节点哈希值，最后将新树根的哈希值和原来的比较，将新树根的索引值进行比较。</p><p>​也因此，IMHT的结构被设计成与MHT有一定差异化的样子。</p><blockquote><p>与Liu的MR-MHT进行对比</p></blockquote><ol><li><p>提高了计算效率。</p></li><li><p>由于MR-MHT将所有副本存储在树中，而IMHT只需要存储一个副本的元组，因此大大减少了存储开销。</p></li><li><p>同时降低了通信成本。H(.)的大小吧h(.)大很多。(因为引入地理位置)</p></li></ol><blockquote><p>MR_MHT的结构设计</p></blockquote><p>Liu等人[7]提出了一种动态多副本云审计方案，其结构名为多副本MHT (MR-MHT)，将每个数据块的所有副本组织成一个副本子树。但是，为了防止替换攻击，他们的方案由于采用了映射到点的哈希函数，引入了MR-MHT计算叶子节点的额外开销。此外，由于提出的MHT结构的深度比普通MHT大得多，验证成本大大增加。</p><blockquote><p>系统架构</p></blockquote><p>整个框架包含六个算法，被描述为：</p><ol><li><p>安装<br>由云用户运行，去设置整个系统，包括输出的参数、公钥Y，私钥x</p></li><li><p>标签获取<br>由云用户运行，它的输入为云用户的私钥x和文件F，输出为同态可验证标签集</p></li><li><p>质疑<br>算法由TPA运行，输入为文件Finf的信息，输出为包含质疑数据块chal的索引和系数</p></li><li><p>响应<br>该算法由CSP运行，将响应证明发送给验证者 ，输入为质疑集chal，文件F和同态可验证标签集</p></li><li><p>地理位置获取<br>该算法由验证者运行，将所有的证明传输给TPA，算法以响应证明Ps为输入，以Ps和地理证明Pv为输出</p></li><li><p>验证<br>算法由TPA运行，为了去验证被质疑数据块的完整性，它以响应证明Ps，地理证明Pv，质疑chal，公钥Y，文件信息Finf为输入，如果能通过验证则输出1，如果不能则输出0</p></li></ol><blockquote><p>动态操作的消耗成本比较</p></blockquote><p>n是一个副本的数据块数量，k是副本数量。<br>h代表通用的哈希函数。|h|代表h的输出大小。<br>H代表映射到点的哈希函数，|H|表示H的响应哈希函数</p><p>Storage:MHT树的存储开销<br>Construction:MR-MH，其中knH是节点计算H，（2kn-1）H是树的计算开销<br>AAI per block: AAI代表Ω，表示为了得到根哈希值，某一数据块节点需要的其他节点的哈希值。</p><blockquote><p>沟通开销</p></blockquote><p>上传：因为每个副本的同样可验证加密器不同，所以需要上传k倍（k为副本数）<br>备份恢复：因为每个副本的同样可验证加密器不同，所以需要多一部先解码后编码的过程。<br>动态更新：只需上传一个新的数据块及其HVT，而不必上传所有副本的新数据块和HVT。</p><blockquote><p>环境评估</p></blockquote><p>执行更多昂贵的映射到点哈希函数，并比CSP执行更多的求幂操作</p><blockquote><p>概率验证——为啥验证200个块就可以达到99%的验证率</p></blockquote><blockquote><p>定质疑时间的几个实验</p></blockquote><p>首先测试校内的RTT（往返时延）</p><p>然后测试多个校外的RTT，发现增长没有保持稳定，因此不能用于位置计算</p><p>最后定下来在校内放置验证器，实验定为最大的RTT</p><blockquote><p>同态可验证加密器</p></blockquote><p>HVA可以基于数字签名生成，如基于rsa的签名和基于bls的签名。因此，这种HVAs可以认为是同态可验证签名，利用HVA，公共审计师可以在不下载原始数据的情况下验证外包数据的完整性。</p><blockquote><p>为什么要引入验证器</p></blockquote><p>验证器是一个可信设备和CSP相同服务器的本地网络中，它是一个能够GPS，帮助TPA来向CSP发送质疑，为什么把验证器放在本地网络中是因为本地网络比Internet产生更少的延迟。</p><blockquote><p>基于位置信息的身份副本</p></blockquote><p>该方案采用距离边界协议来识别不同位置的每个唯一副本。该方案中使用的距离边界协议是可信验证者和质疑CSP两参与方之间的认证协议，验证者可以同时检查CSP的身份和地理位置。</p><p>通常情况下，验证者和CSP首先要相互通信，共享ID和秘密信息。然后，验证者需要与CSP进行多次交互。验证者发送挑战，并在每一轮启动时钟，CSP将发送相应的响应回给验证者。验证者将计算每轮往返时间∆tmax，并检查所有往返时间是否在允许的时间范围∆t≤∆tmax。如果所有的响应都是有效的，并且满足时间限制，那么就可以验证地理位置。也就是说，不同的副本可以通过其不同的地理位置来识别。</p><p>~~存疑问题：那么一个验证者是否只给一个CSP发送信息呢？<br>是<br>动态更新中，为什么云用户只用更新一个副本，其他副本是如何同步的。<br><s>只用更新一个副本，其他通信即可</s></p><p>2015_Liu中的Hash函数是如何被解密的？</p><hr><blockquote><p>对于分布式多副本公共审计的思考与探索</p></blockquote><p>这篇论文引入了地理位置，由此带来的树形数据结构的精简带来了时间复杂度的降维打击。</p><p>思考1：当地理位置相同的时候怎么处理，比如我存储在同一台电脑上，导致域名一致，无法区分？</p><p>判断一下。</p><p>If（地理位置相同） MR-MHT（2015_Liu）；</p><p>else IMHT（本文）</p><p>思考2：引入地理位置对硬件要求较高，云服务商也不一定配合，能否不引入地理位置，优化之前的方案？</p><p>提出一种改进的副本树的数据结构。不是我的研究重点。</p><p>思考3：从安全性的角度考量，能否基于区块链存储或者直接用区块链的公证节点替代TPA？</p><p>我觉得可行。审计过程产生的信息保存在链上可以保证不可篡改。TPA在其他多副本论文（2020_Li）中已经被替代了。仔细琢磨琢磨还有改进空间。</p><p>思考4：既然能引入地理位置来“降维打击”，能不能引入一个其他量来继续降维。<br>暂时没有想到。</p><p>思考5：从审计效率的考量，能否提出一种批量审计或批量更新的方法。</p><p>这方面文章看得太少，还无法考虑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据备份是云服务提供商(csp)为避免潜在的数据丢失风险而采取的普遍策略。因此，CSP通常在地理位置分布的服务器上为每个数据块维护多个副本，以提高可靠性。这种复制技术的一个关键问题是，存储的副本越多，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2019_Guo</title>
    <link href="https://arthersun.github.io/2021/11/17/2019-Guo/"/>
    <id>https://arthersun.github.io/2021/11/17/2019-Guo/</id>
    <published>2021-11-17T15:04:45.000Z</published>
    <updated>2021-11-30T02:55:29.024Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/11/17/2019-Guo/2019-Guo%5Cimage-20211117230513756.png" alt="image-20211117230513756"></p><p>(1)客户将其数据外包给CSP;</p><p>(2)客户将审计工作外包给审计师;</p><p>(3)通过依赖比特币[22]的功能，审计员定期审计CSP，检查外包数据是否完整;</p><p>(4)每次审核后，审核员创建一个日志条目，记录他在这一点上的审核工作;</p><p>(5)客户可以随时审核日志文件，以检查审核员过去是否诚实履行其审计工作;</p><p>(6)客户端将更新的哈希值发送给审计师;审核员对RBMT进行更新，并将更新证明发送给CSP进行验证;</p><p>(7)客户端也验证从CSP接收到的更新证明，并将更新后的数据块发送给CSP。</p><blockquote><p>贡献1</p></blockquote><p>提出了一种RBMT的多叶认证(multi-leaf-authenticated, MLA)解决方案，该方案能够在不存储状态值和高度值的情况下对多个叶节点及其索引进行身份验证。在MLA解决方案的基础上，提出了一种可以同时执行和验证多个更新操作的批量更新算法。每次认证/更新的摊销价格从1+log n降低到1+log (n/c)，其中是n是数据块的总数量和c是质疑/更新的数据块的数量。</p><p>(1)提出了RBMT的多叶认证(multi-leaf-authenticated, MLA)解决方案，该方案能够在不存储状态值和高度值的情况下对多个叶节点及其索引进行认证。在MLA解决方案的基础上，提出了一种可以同时执行和验证多个更新操作的批量更新算法。每次认证/更新的摊销价格从1+登录降低到1+log (n/c)，其中是数据块的总数量和挑战/更新的数据块的数量。</p><p>(2)提出了一种基于BLS签名的高效同态可验证标签(EHVT)来满足[15]的要求，该标签可以减少客户端从mo (kl)1toO(1)到log验证的次数。我们进一步提出了一种日志审计机制，通过这种机制，客户可以检查产生的日志文件由审计师以较低的频率来验证其过去是否诚实地执行了审计工作。</p><p>（3）我们描述了一个具体的ODPDP方案，该方案在改进的威胁模型中是安全的(参见第2.2节)，并且可以通过将频繁的审计工作迁移到外部审计员来减轻客户端的验证开销。我们实现了ODPDP方案的原型，实验证明了该方案的高性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/11/17/2019-Guo/2019-Guo%5Cimage-20211117230513756.png&quot; alt=&quot;image-20211117230513756&quot;&gt;&lt;/p&gt;
&lt;p&gt;(1)客户将其数据外包给CSP;&lt;/p&gt;
&lt;p&gt;(2)客</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2015_Ayad</title>
    <link href="https://arthersun.github.io/2021/11/17/2015-Ayad/"/>
    <id>https://arthersun.github.io/2021/11/17/2015-Ayad/</id>
    <published>2021-11-17T13:48:01.000Z</published>
    <updated>2021-11-17T13:48:26.023Z</updated>
    
    <content type="html"><![CDATA[<p>外包数据的核心设计原则之一是为各种应用程序提供数据的动态行为。这意味着远程存储的数据不仅可以由授权用户访问，而且还可以由数据所有者更新和缩放(通过块级操作)。[1] -[9]中提出的PDP方案只关注静态存储的数据，其中外包数据在远程服务器上保持不变。处理动态数据的PDP结构的例子是[10]-[14]。后者是数据文件的单个副本。尽管PDP方案已经给出了静态数据的多个副本，参见[15]-[17]，据我们所知，这是第一个直接处理动态数据的多个副本的PDP方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;外包数据的核心设计原则之一是为各种应用程序提供数据的动态行为。这意味着远程存储的数据不仅可以由授权用户访问，而且还可以由数据所有者更新和缩放(通过块级操作)。[1] -[9]中提出的PDP方案只关注静态存储的数据，其中外包数据在远程服务器上保持不变。处理动态数据的PDP结构</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2016_张玉清</title>
    <link href="https://arthersun.github.io/2021/11/17/2016-%E5%BC%A0%E7%8E%89%E6%B8%85/"/>
    <id>https://arthersun.github.io/2021/11/17/2016-%E5%BC%A0%E7%8E%89%E6%B8%85/</id>
    <published>2021-11-17T13:27:36.000Z</published>
    <updated>2021-11-17T13:48:08.024Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在这里摘录了一段数据所有权证明的定义和意义感觉很不错</p></blockquote><p>数据所有权的证明(provable  data  possession,简称PDP)[75]同样可以公开验证云端数据的完整性.由于验证过程中服务器的数据量和通信量较小,因此PDP模型适用于大规模分布式存储系统.当数据以多副本的方式存储于CSP时,用户需要对副本的个数与一致性进行额外的判断.为此,Barsoum等人[76]提出了相应的解决方案MB-PMDDP ,同时能够抵御服务器合谋并支持动态的数据更新.类似地,基于身份的分布式数据完整性检测模型ID-DPDP[77]针对数据存储于不同云服务器的情况,实现了私有验证、委托验证和公开验证.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在这里摘录了一段数据所有权证明的定义和意义感觉很不错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据所有权的证明(provable  data  possession,简称PDP)[75]同样可以公开验证云端数据的完整性.由于验证过程中服务器的数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文的摘录</title>
    <link href="https://arthersun.github.io/2021/11/17/%E8%AE%BA%E6%96%87%E7%9A%84%E6%91%98%E5%BD%95/"/>
    <id>https://arthersun.github.io/2021/11/17/%E8%AE%BA%E6%96%87%E7%9A%84%E6%91%98%E5%BD%95/</id>
    <published>2021-11-17T04:01:32.000Z</published>
    <updated>2021-11-17T13:27:42.748Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>历史</p></blockquote><p>Ateniese等[36]首次提出了一种可扩展、高效的PDP，支持除数据插入外的所有动态数据操作。</p><p>Erway等[37]首次提出了一种支持所有动态数据操作的完全动态可证明数据持有(DPDP)方案。</p><p>他们的方案采用基于秩的认证跳跃表来管理数据块的动态信息。</p><p>然而，他们的方案不能支持公开审计。</p><p>Wang等[38]提出了一种全动态审计方案，通过引入MHT来存储数据块的动态信息。他们利用Boneh-Lynn-Shacham  (BLS)短签名代替RSA签名构造同态可验证标签(HVTs)，以减少通信开销。</p><p>Mukundan等人[39]提出了一种动态的多副本云审计方案，通过去除hvt中的索引信息。但是[38]和[39]都不验证数据块的索引，这意味着云存储服务器可以在任何位置使用数据块通过验证。</p><p>Zhu等人[8]提出了一个与索引哈希表相关的动态审计方案。他们将BLS签名与数据片段技术相结合，以减少存储开销。</p><p>Barsoum和Hasan[25]通过引入映射版本表(MVT)提出了一种基于映射的多副本数据持有方案。MVT由序号、块号和块版本三列数据组成，用来记录每个数据块的逻辑位置和物理位置的映射关系。该方案只需要存储一个文件副本的动态信息，消除了辅助认证信息(AAI)，减少了存储和通信开销。但是，MVT必须存储在TPA中。与CSP相比，TPA并不是一个存储密集型实体。因此，为无数云用户存储mvt将消耗TPA的大量存储资源。而且方案不安全，可能会出现[8]和[40]提出的HVT伪造问题。</p><p>Zhang等[24]提出了一种动态复制数据审计方案，采用改进的MHT  (mMHT)来验证数据块及其指标的完整性。Liu等人[7]提出了一种动态多副本云审计方案，其结构为多副本MHT  (MR-MHT)，将每个数据块的所有副本组织成一个副本子树。但是，为了防止替换攻击，他们的方案由于采用了map-to-point  hash函数，引入了额外的计算MR-MHT叶节点的成本。此外，由于提出的MHT结构的深度比普通MHT大得多，验证成本大大增加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;历史&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ateniese等[36]首次提出了一种可扩展、高效的PDP，支持除数据插入外的所有动态数据操作。&lt;/p&gt;
&lt;p&gt;Erway等[37]首次提出了一种支持所有动态数据操作的完全动态可证明数据持有(DPD</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2011_Zhu</title>
    <link href="https://arthersun.github.io/2021/11/17/2011-Zhu/"/>
    <id>https://arthersun.github.io/2021/11/17/2011-Zhu/</id>
    <published>2021-11-16T16:00:00.000Z</published>
    <updated>2021-11-18T01:57:09.716Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于动态审计中的IHT的作用。</p></blockquote><p><img src="/2021/11/17/2011-Zhu/2011-Zhu%5Cimage-20211118000021010.png" alt="image-20211118000021010"></p><ol><li>标签生成阶段。客户端(DO)使用一个秘密密钥对一个文件进行预处理，该文件由n个块的集合组成，生成一组公共验证参数(PVPs)和IHT，存储在TPA中，将文件和一些验证标记（File+Flags）传输给CSP，并可以删除其本地副本(见图2a);</li><li>定期抽样审计。通过使用可检索的交互式证明协议，TPA(或其他应用程序)发出一个“随机抽样”挑战，以审核存储在TPA中的验证信息(涉及PVP和IHT)的外包数据的完整性和可用性(见图2b);和</li><li>审计动态操作。一个AA，谁持有一个DO的秘密钥匙sk，可以操纵外包数据并更新存储在TPA中的相关IHT。sk的私密性和检查算法保证了存储服务器不能欺骗AA，伪造有效的审计记录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：这张表帮我看清楚了动态审计过程中的IHT表的位置，IHT表是一张维护在TPA中的，由序列号、区块号、版本号和随机整数组成。除了记录数据的变化，每个记录Xi表被用来生成一个唯一的哈希值，这反过来是用来构造一个在秘密的钥匙sk旁边的签名标签σi。</span><br></pre></td></tr></table></figure><blockquote><p>IHT与HDFS的结合</p></blockquote><p><img src="/2021/11/17/2011-Zhu/2011-Zhu%5Cimage-20211118004818449.png" alt="image-20211118004818449"></p><p>基于这些hash值，客户端或TPA可以通过审计服务实现验证协议。在现有的HDFS中，我们的异常检测方案可以很容易地替换普通的校验和算法，而无需下载数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于动态审计中的IHT的作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2021/11/17/2011-Zhu/2011-Zhu%5Cimage-20211118000021010.png&quot; alt=&quot;image-20211</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>node与java版本的问题实录</title>
    <link href="https://arthersun.github.io/2021/11/15/nvs%E4%B8%8Enode%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98%E5%AE%9E%E5%BD%95/"/>
    <id>https://arthersun.github.io/2021/11/15/nvs%E4%B8%8Enode%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98%E5%AE%9E%E5%BD%95/</id>
    <published>2021-11-15T11:00:13.000Z</published>
    <updated>2021-11-15T12:04:20.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天使用nvs时候遇到了node版本的问题</p></blockquote><p>原因大概是有些node包（node-sass）不支持高版本的node包，这个可以到node包的官网去查看。</p><ul><li>解决方法</li></ul><p>使用nvs安装其他node版本</p><p>指令集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvs add 14</span><br><span class="line">nvs use 14</span><br><span class="line">nvs list</span><br></pre></td></tr></table></figure><blockquote><p>此外，也遇到java版本的问题</p></blockquote><p>java版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnsupportedClassVersionError: run/halo/app/<span class="function">Application has been compiled by a more recent version of the Java <span class="title">Runtime</span> <span class="params">(class file version <span class="number">55.0</span>)</span>, <span class="keyword">this</span> version of the Java Runtime only recognizes class file versions up to 52.0</span></span><br></pre></td></tr></table></figure><p>查询原因为使用了java11进行编译，但是运行时使用的是java8</p><ul><li>45 = Java 1.1</li><li>46 = Java 1.2</li><li>47 = Java 1.3</li><li>48 = Java 1.4</li><li>49 = Java 5</li><li>50 = Java 6</li><li>51 = Java 7</li><li>52 = Java 8</li><li>53 = Java 9</li><li>54 = Java 10</li><li>55 = Java 11</li><li>56 = Java 12</li><li>57 = Java 13</li></ul><p>解决方案：下载java11，然后修改系统环境变量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天使用nvs时候遇到了node版本的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因大概是有些node包（node-sass）不支持高版本的node包，这个可以到node包的官网去查看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方法&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker学习</title>
    <link href="https://arthersun.github.io/2021/11/15/docker%E5%AD%A6%E4%B9%A0/"/>
    <id>https://arthersun.github.io/2021/11/15/docker%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-15T09:24:05.000Z</published>
    <updated>2021-11-15T10:05:11.089Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> docker学习</p></blockquote><ul><li>docker概述</li><li>docker安装</li><li>docker命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…..</li></ul></li><li>docker镜像</li><li>容器数据卷</li><li>dockerFile</li><li>docker网络原理</li><li>IDEA 整合docker</li><li>docker compose</li><li>docker swarm</li><li>CI\CD Jenkins</li></ul><p>知道的越多，不知道的越多！</p><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; docker学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;docker概述&lt;/li&gt;
&lt;li&gt;docker安装&lt;/li&gt;
&lt;li&gt;docker命令&lt;ul&gt;
&lt;li&gt;镜像命令&lt;/li&gt;
&lt;li&gt;容器命令&lt;/li&gt;
&lt;li&gt;操作命令&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最新想看的一些新技术</title>
    <link href="https://arthersun.github.io/2021/11/15/%E6%9C%80%E6%96%B0%E6%83%B3%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    <id>https://arthersun.github.io/2021/11/15/%E6%9C%80%E6%96%B0%E6%83%B3%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%8A%80%E6%9C%AF/</id>
    <published>2021-11-14T17:42:50.000Z</published>
    <updated>2021-11-18T05:39:26.584Z</updated>
    
    <content type="html"><![CDATA[<ul><li><input checked disabled type="checkbox"> js关于同步异步的一些知识</li><li><input disabled type="checkbox"> yarn和大数据的知识</li><li><input disabled type="checkbox"> go语法和框架学习</li><li><input disabled type="checkbox"> 内网多人共享gitea的学习</li><li><input disabled type="checkbox"> typescript</li><li><input disabled type="checkbox"> docker: 尝试将区块链后端和代码打包成docker</li><li><input disabled type="checkbox"> mongodb</li><li><input disabled type="checkbox"> 如何内网穿透</li><li><input disabled type="checkbox"> 如何不用springboot，只用node框架实现现有的后端（Modway.js）</li><li><input disabled type="checkbox"> 数据结构和算法的学习</li><li><input disabled type="checkbox"> Redis 和 如何用Lua解释器实现Redis脚本功能</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;input checked disabled type=&quot;checkbox&quot;&gt; js关于同步异步的一些知识&lt;/li&gt;
&lt;li&gt;&lt;input disabled type=&quot;checkbox&quot;&gt; yarn和大数据的知识&lt;/li&gt;
&lt;li&gt;&lt;input disabl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何使用git进行多人协作</title>
    <link href="https://arthersun.github.io/2021/11/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E8%BF%9B%E8%A1%8C%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
    <id>https://arthersun.github.io/2021/11/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E8%BF%9B%E8%A1%8C%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/</id>
    <published>2021-11-14T07:02:32.000Z</published>
    <updated>2021-11-20T13:26:17.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>起子</p></blockquote><p>github可以建立免费快速的私有云，在github上进行项目工程的团队合作是非常高效的</p><blockquote><p>善用github的分支功能</p></blockquote><p>github的分支功能初识时十分鸡肋，但是用多了之后设计的非常成功。</p><p>对于多人合作，我们需要共有一个主分支(master or dev)</p><p>我们在主分支上进行代码合并，并作为最终版本展示。</p><p>而其他分支作为每个人个人临时的代码池，用于最后的代码合并，合并完进行删除。</p><blockquote><p>流程</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 新的开发需求下达</span><br><span class="line">2. 对主分支进行pull（设这里的主分支为dev）</span><br><span class="line">3. 切换到自己的分支`git checkout -b sun`(-b是新建分支的意思)</span><br><span class="line">4. `git rebase dev`</span><br><span class="line">5. 进行开发工作</span><br><span class="line">6. `git add .`</span><br><span class="line">7. `git commit &quot;update:xxx功能&quot;`</span><br><span class="line">8. `git push`（远程push）`git push origin master`</span><br><span class="line">使用--force可以强制覆盖远程仓库</span><br><span class="line">9. 审核员进行审核，审核完成后进行合并</span><br><span class="line">10. 然后删除该分支</span><br><span class="line">11. 删除本地分支：`git branch -D sun`</span><br><span class="line">12. 删除远程分支：`git push origin --delete sun `</span><br><span class="line"></span><br><span class="line">finished</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;起子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github可以建立免费快速的私有云，在github上进行项目工程的团队合作是非常高效的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;善用github的分支功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
