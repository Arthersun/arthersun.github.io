<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫漫白衣路，少年追光时</title>
  
  <subtitle>漫漫白衣路，少年追光时</subtitle>
  <link href="https://arthersun.github.io/atom.xml" rel="self"/>
  
  <link href="https://arthersun.github.io/"/>
  <updated>2022-11-17T03:01:00.919Z</updated>
  <id>https://arthersun.github.io/</id>
  
  <author>
    <name>arthersun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchonized锁升级流程</title>
    <link href="https://arthersun.github.io/2022/11/17/synchonized%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/"/>
    <id>https://arthersun.github.io/2022/11/17/synchonized%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/</id>
    <published>2022-11-17T02:56:53.000Z</published>
    <updated>2022-11-17T03:01:00.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized锁升级"><a class="markdownIt-Anchor" href="#synchronized锁升级"></a> synchronized锁升级</h1><p>根据上面内容可以知道，synchronized锁有四种状态：无锁，偏向锁、轻量级锁和重量级锁，下面介绍四种状态和其之间的转换。</p><p>2.1 无锁</p><p>当一个对象被创建之后，还没有线程进入，这个时候对象处于无锁状态，其Mark Word中的信息如上表所示。</p><p>2.2 偏向锁</p><p>当锁处于无锁状态时，有一个线程A访问同步块并获取锁时，会在对象头和栈帧中的锁记录记录线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来进行加锁和解锁，只需要简单的测试一下啊对象头中的线程ID和当前线程是否一致。</p><p>2.3 轻量级锁</p><p>在偏向锁的基础上，又有另外一个线程B进来，这时判断对象头中存储的线程A的ID和线程B不一致，就会使用CAS竞争锁，并且升级为轻量级锁，会在线程栈中创建一个锁记录(lock Record)，将Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头的Mark Word替换成指向锁记录的指针，如果成功，则当前线程获得锁；失败，表示其他线程竞争锁，当前线程便尝试CAS来获取锁。</p><p>2.4 重量级锁</p><p>当线程没有获得轻量级锁时，线程会CAS自旋来获取锁，当一个线程自旋10次之后，仍然未获得锁，那么就会升级成为重量级锁。</p><p>成为重量级锁之后，线程会进入阻塞队列(EntryList)，线程不再自旋获取锁，而是由CPU进行调度，线程串行执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;synchronized锁升级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#synchronized锁升级&quot;&gt;&lt;/a&gt; synchronized锁升级&lt;/h1&gt;
&lt;p&gt;根据上面内容可以知道，synchronized锁有四种状态：无锁，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mybatis八股</title>
    <link href="https://arthersun.github.io/2022/11/16/mybatis%E5%85%AB%E8%82%A1/"/>
    <id>https://arthersun.github.io/2022/11/16/mybatis%E5%85%AB%E8%82%A1/</id>
    <published>2022-11-16T13:56:54.000Z</published>
    <updated>2022-11-17T02:49:05.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis编程步骤是什么样的"><a class="markdownIt-Anchor" href="#mybatis编程步骤是什么样的"></a> MyBatis编程步骤是什么样的?</h1><p>1、创建SqlSessionFactory</p><p>2、通过SqlSessionFactory创建Sql Session</p><p>3、通过sqlsession执行数据库操作</p><p>4、调用session.commit()提交事务</p><p>5、调用session.close()关闭会话</p><h1 id="jdbc编程有哪些不足之处mybatis是如何解决这些问题的"><a class="markdownIt-Anchor" href="#jdbc编程有哪些不足之处mybatis是如何解决这些问题的"></a> JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>解决：在SqlMapConfig。xml中配置数据链接池，使用连接池管理数据库链接。</p><p>2、Sql语句写在代码中造成代码不易维护，实际应用sq！变化的可能较大，sq！变动需要改变java代码。</p><p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p><p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>解决：Mybatis自动将java对象映射至sql语句。</p><p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p>解决：Mybatis自动将Sql执行结果映射至java对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mybatis编程步骤是什么样的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mybatis编程步骤是什么样的&quot;&gt;&lt;/a&gt; MyBatis编程步骤是什么样的?&lt;/h1&gt;
&lt;p&gt;1、创建SqlSessionFactory&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PUT请求和POST请求的区别</title>
    <link href="https://arthersun.github.io/2022/11/15/PUT%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/11/15/PUT%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-15T07:47:10.000Z</published>
    <updated>2022-11-15T08:09:44.361Z</updated>
    
    <content type="html"><![CDATA[<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST <a href="http://www.forum.com/articles%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%9C%A8http://www.forum.com/articles%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E5%B8%96%E5%AD%90%EF%BC%8CHTTP%E5%93%8D%E5%BA%94%E4%B8%AD%E5%BA%94%E5%8C%85%E5%90%AB%E5%B8%96%E5%AD%90%E7%9A%84%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%B8%96%E5%AD%90%E7%9A%84URI%E3%80%82%E4%B8%A4%E6%AC%A1%E7%9B%B8%E5%90%8C%E7%9A%84POST%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%88%9B%E5%BB%BA%E4%B8%A4%E4%BB%BD%E8%B5%84%E6%BA%90%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%85%B7%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84URI%EF%BC%9B%E6%89%80%E4%BB%A5%EF%BC%8CPOST%E6%96%B9%E6%B3%95%E4%B8%8D%E5%85%B7%E5%A4%87%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%82%E8%80%8CPUT%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84URI%E6%98%AF%E8%A6%81%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0%E7%9A%84%E8%B5%84%E6%BA%90%E6%9C%AC%E8%BA%AB%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%9APUT">http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT</a> <a href="http://www.forum/articles/4231%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0ID%E4%B8%BA4231%E7%9A%84%E5%B8%96%E5%AD%90%E3%80%82%E5%AF%B9%E5%90%8C%E4%B8%80URI%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1PUT%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%80%E6%AC%A1PUT%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%9B%E5%9B%A0%E6%AD%A4%EF%BC%8CPUT%E6%96%B9%E6%B3%95%E5%85%B7%E6%9C%89%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%82">http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</a></p><p>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</p><h1 id="幂等设计"><a class="markdownIt-Anchor" href="#幂等设计"></a> 幂等设计</h1><p>分布式事务 vs 幂等设计<br>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。</p><p>这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int create_ticket()</span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST &lt;a href=&quot;http://www.forum.com/articles%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%E5%9C%A8http://www.forum</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GET请求和POST请求的区别</title>
    <link href="https://arthersun.github.io/2022/11/15/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://arthersun.github.io/2022/11/15/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-15T06:37:56.000Z</published>
    <updated>2022-11-15T06:38:52.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用上的区别"><a class="markdownIt-Anchor" href="#使用上的区别"></a> 使用上的区别：</h1><p>GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。</p><p>GET方式提交的数据有长度限制，则POST的数据则可以非常大〞，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</p><p>POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</p><h1 id="本质区别"><a class="markdownIt-Anchor" href="#本质区别"></a> 本质区别</h1><p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。</p><p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用上的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用上的区别&quot;&gt;&lt;/a&gt; 使用上的区别：&lt;/h1&gt;
&lt;p&gt;GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP常用的请求方式</title>
    <link href="https://arthersun.github.io/2022/11/15/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
    <id>https://arthersun.github.io/2022/11/15/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</id>
    <published>2022-11-15T06:34:48.000Z</published>
    <updated>2022-11-15T07:43:03.779Z</updated>
    
    <content type="html"><![CDATA[<p>GET 获取资源</p><p>POST 传输实体主体</p><p>PUT 上传文件</p><p>DELETE 删除文件</p><p>HEAD 和GET方法类似，但只返回报文首部，不返回报文实体主体部分</p><p>PATCH 对资源进行部分修改</p><p>OPTIONS 查询指定的URL支持的方法</p><p>CONNECT 要求用隧道协议进行代理</p><p>TRACE 服务器会将通信路径返回给客户端</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GET 获取资源&lt;/p&gt;
&lt;p&gt;POST 传输实体主体&lt;/p&gt;
&lt;p&gt;PUT 上传文件&lt;/p&gt;
&lt;p&gt;DELETE 删除文件&lt;/p&gt;
&lt;p&gt;HEAD 和GET方法类似，但只返回报文首部，不返回报文实体主体部分&lt;/p&gt;
&lt;p&gt;PATCH 对资源进行部分修改&lt;/p&gt;
&lt;p&gt;OP</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="https://arthersun.github.io/2022/11/15/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://arthersun.github.io/2022/11/15/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2022-11-15T06:28:48.000Z</published>
    <updated>2022-11-15T06:34:11.248Z</updated>
    
    <content type="html"><![CDATA[<p>常见状态码：</p><p>200：服务器正确处理了请求。</p><p>301：（永久移动）请求的网页已永久移动到新位置。服务器返回该响应（对GET或HEAD请求的相应）时，会自动将请求者转到新位置。</p><p>302：（临时移动）服务器目前从不同位置的网页相应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>400：客户端请求有语法错误，不能被服务器所理解。</p><p>403：服务器收到请求，但是拒绝提供服务。</p><p>404：（未找到）服务器找不到请求的网页。</p><p>500：（服务器内部错误）服务器遇到错误，无法完成请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见状态码：&lt;/p&gt;
&lt;p&gt;200：服务器正确处理了请求。&lt;/p&gt;
&lt;p&gt;301：（永久移动）请求的网页已永久移动到新位置。服务器返回该响应（对GET或HEAD请求的相应）时，会自动将请求者转到新位置。&lt;/p&gt;
&lt;p&gt;302：（临时移动）服务器目前从不同位置的网页相应请求，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AOP和拦截器</title>
    <link href="https://arthersun.github.io/2022/11/14/AOP%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://arthersun.github.io/2022/11/14/AOP%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2022-11-14T13:45:17.000Z</published>
    <updated>2022-11-15T06:28:39.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="aop原理"><a class="markdownIt-Anchor" href="#aop原理"></a> AOP原理</h1><ol><li>创建代理对象阶段</li></ol><p>在Spring中，创建Bean实例都是从getBean()方法开始的，在实例创建之后，Spring容器将根据AOP的配置去匹配目标类的类名，看目标类的类名是否满足切面规则。</p><p>如果满足切面规则，就会调用ProxyFactory创建代理Bean并缓存到IOC容器中。根据目标对象的自动选择不同的代理策略。如果目标类实现了接口，Spring会默认选择JDK Proxy，如果目标类没有实现接口，Spring会默认选择Cglib Proxy。</p><ol start="2"><li>拦截目标对象阶段</li></ol><p>当用户调用目标对象的某个方法时，将会被一个叫做AopProxy的对象拦截，Spring将所有的调用策略封装到了这个对象中，它默认实现了InvocationHandler接口，也就是调用代理对象的外层拦截器。在这个接口的invoke()方法中，会出发MethodInvocation的proceed()方法。在这个方法中会按顺序执行符合所有AOP拦截规则的拦截器链。</p><ol start="3"><li>调用代理对象阶段</li></ol><p>Spring AOP拦截器链中的每个元素被命名为MethodInterceptor，其实就是切面配置中的Advice通知。这个回调可以简单地理解为是新生成的代理Bean中的方法。也就是我们常说的被织入的代码片段，这些被织入的代码片段会在这个阶段执行。</p><ol start="4"><li>调用目标对象阶段</li></ol><p>MethodInterceptor接口也有一个invoke()方法，在MethodInterceptor的invoke()方法中会触发对目标对象方法的调用，也就是反射调用目标对象的方法。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>流程：</p><ol><li><p>代理对象：就是由Spring代理策略生成的对象；</p></li><li><p>目标对象：就是我们自己写的业务代码；</p></li><li><p>织入代码：就是要在我们自己写的业务代码增加的代码片段；</p></li><li><p>切面通知：就是封装织入代码片段的回调方法；</p></li><li><p>MethodInvocation：负责执行拦截器链，在proceed()方法中执行；</p></li><li><p>MethodInterceptor：负责执行织入的代码片段，在invoke()方法中执行。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;aop原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#aop原理&quot;&gt;&lt;/a&gt; AOP原理&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;创建代理对象阶段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Spring中，创建Bean实例都是从getBean()方法开始的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://arthersun.github.io/2022/11/14/%E6%AD%BB%E9%94%81/"/>
    <id>https://arthersun.github.io/2022/11/14/%E6%AD%BB%E9%94%81/</id>
    <published>2022-11-14T10:57:35.000Z</published>
    <updated>2022-11-14T11:25:03.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><p>死锁，就是说两个或两个以上的线程在执行的过程中，去争夺同一个共享资源导致相互等待的现象。如果没有外部干预，线程会一直处于阻塞状态，无法往下执行。这样一直等待处于阻塞状态的线程，被称为死锁线程。</p><h1 id="产生死锁的原因"><a class="markdownIt-Anchor" href="#产生死锁的原因"></a> 产生死锁的原因</h1><p>产生死锁需要同时满足以下四个条件：</p><ol><li>互斥条件，共享资源a和b只能被一个线程占用</li><li>请求和保持条件，线程T1已经获取共享资源a，在等待共享资源b的时候，不释放共享资源a</li><li>不可抢占条件，其他线程不能强行抢占线程T1占有的资源</li><li>循环等待条件，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，这形成了循环等待</li></ol><h1 id="如何避免死锁"><a class="markdownIt-Anchor" href="#如何避免死锁"></a> 如何避免死锁</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#死锁&quot;&gt;&lt;/a&gt; 死锁&lt;/h1&gt;
&lt;p&gt;死锁，就是说两个或两个以上的线程在执行的过程中，去争夺同一个共享资源导致相互等待的现象。如果没有外部干预，线程会一直处于阻塞状态，无法往下执行。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内存溢出和内存泄漏</title>
    <link href="https://arthersun.github.io/2022/11/14/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://arthersun.github.io/2022/11/14/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2022-11-14T10:48:49.000Z</published>
    <updated>2022-11-14T10:57:27.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存溢出"><a class="markdownIt-Anchor" href="#内存溢出"></a> 内存溢出</h1><p>JVM中可用内存空间存不下了，比如只有3M，但现在要创建一个5M的对象，新创建的就放不进去了。</p><h1 id="内存泄漏"><a class="markdownIt-Anchor" href="#内存泄漏"></a> 内存泄漏</h1><p>在业务代码执行过程中，有些对象它应该被回收，但是又有其他对象引用它，因此，GC不能自动回收。最终会导致内存泄漏。</p><h1 id="如何避免"><a class="markdownIt-Anchor" href="#如何避免"></a> 如何避免</h1><p>特别是一些流对象，比如OutputStream，Reader，BitMap，Document，很容易忘掉close。最麻烦的是要顺序回收，顺序错了还会产生空指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存溢出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存溢出&quot;&gt;&lt;/a&gt; 内存溢出&lt;/h1&gt;
&lt;p&gt;JVM中可用内存空间存不下了，比如只有3M，但现在要创建一个5M的对象，新创建的就放不进去了。&lt;/p&gt;
&lt;h1 id=&quot;内存泄漏&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>逐层排序二叉树所需的最少操作数目</title>
    <link href="https://arthersun.github.io/2022/11/14/%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE/"/>
    <id>https://arthersun.github.io/2022/11/14/%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE/</id>
    <published>2022-11-14T04:41:42.000Z</published>
    <updated>2022-11-14T05:45:02.185Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><p>给你一个 值互不相同 的二叉树的根节点 root 。</p><p>在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。</p><p>返回每一层按 严格递增顺序 排序所需的最少操作数目。</p><p>节点的 层数 是该节点和根节点之间的路径的边数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 4 和 3 。第 2 层变为 [3,4] 。</span><br><span class="line">- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。</span><br><span class="line">- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。</span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure><p>思路：</p><p>使用置换环算法得到数组排序需要的最小交换次数。</p><p>具体实现思想：</p><ol><li>使用Map记录每个节点值及其应该放到的位置</li><li>从头到尾遍历初始数组，使用flag[]数组标记当前元素是否已经参与过（即已经被加入环中），对已经参与过的数组则不再需要遍历。每次成环结束，记录成环个数loop。</li><li>最终最小交换次数为：数组长度-成环个数 nums.size()-loop</li></ol><p><img src="/2022/11/14/%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE/%E7%BD%AE%E6%8D%A2%E7%8E%AF.jpg" alt="置换环"></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    // 返回使得 nums 递增需要的最小交换元素次数</span><br><span class="line">    public int minChanges(int[] nums)&#123;</span><br><span class="line">        int[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;copy.length; i++)&#123;</span><br><span class="line">            map.put(copy[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] flag = new boolean[nums.length];  // 用于标记 nums[i] 是否已经被加入环中</span><br><span class="line">        int loop = 0; // 环的个数</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(!flag[i])&#123;</span><br><span class="line">                int j = i;</span><br><span class="line">                while(!flag[j])&#123; // 画环</span><br><span class="line">                    int index = map.get(nums[j]); // 当前节点指向的位置，画环过程</span><br><span class="line">                    flag[j] = true; // 将 j 加入环中</span><br><span class="line">                    j = index; // 将当前节点移动到环上下个节点</span><br><span class="line">                &#125;</span><br><span class="line">                loop++; // 环数递增</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.length - loop; // 最小交换次数为 ： 数组长度 - 环数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：晚晴🌤</span><br><span class="line">链接：https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/solutions/1965867/by-liu-wan-qing-zjlj/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;给你一个 值互不相同 的二叉树的根节点 root 。&lt;/p&gt;
&lt;p&gt;在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。&lt;/p&gt;
&lt;p&gt;返回每一层按 严格递增顺序 排序所需的最少操作数目。&lt;/p&gt;
&lt;p&gt;节点的 层数 是该节点和根节点</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最小公倍数为K的子数组数目</title>
    <link href="https://arthersun.github.io/2022/11/14/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://arthersun.github.io/2022/11/14/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</id>
    <published>2022-11-14T04:11:37.000Z</published>
    <updated>2022-11-14T04:41:10.827Z</updated>
    
    <content type="html"><![CDATA[<p>辗转相除法：</p><p>用大数对小数求余，若余数为0，则除数为最大公约数。若余数不为0，将此余数作为除数，小数作为被除数，重新求余，直到余数为0为止。此时的最大公约数为余数。</p><p>例如：27和6.  27%6=3.  6%3=0.  所以最大公约数为3.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int gcd(int a, int b)&#123;</span><br><span class="line">        while (b != 0)&#123;</span><br><span class="line">            int tmp = a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最大公约数和最小公倍数的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个数的乘积等于这两个数的最大公约数与最小公倍数的乘积。假设有两个数是a、b，它</span><br><span class="line">们的最大公约数是B，最小公倍数是q。那么存在这样的关系式：ab=pg。</span><br></pre></td></tr></table></figure><p>于是代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int subarrayLCM(int[] nums, int k) &#123;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int cur = nums[i];</span><br><span class="line">            for(int j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">                cur = cur*nums[j]/gcd(cur,nums[j]);</span><br><span class="line">                if(cur==k)&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;else if(cur&gt;k)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用辗转相除法写gcd</span><br><span class="line">    public int gcd(int a, int b)&#123;</span><br><span class="line">        while(b!=0)&#123;</span><br><span class="line">            int temp = a%b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;辗转相除法：&lt;/p&gt;
&lt;p&gt;用大数对小数求余，若余数为0，则除数为最大公约数。若余数不为0，将此余数作为除数，小数作为被除数，重新求余，直到余数为0为止。此时的最大公约数为余数。&lt;/p&gt;
&lt;p&gt;例如：27和6.  27%6=3.  6%3=0.  所以最大公约数为3.&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>吾日三省吾身</title>
    <link href="https://arthersun.github.io/2022/11/13/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    <id>https://arthersun.github.io/2022/11/13/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/</id>
    <published>2022-11-13T06:54:16.000Z</published>
    <updated>2022-11-13T06:54:39.014Z</updated>
    
    <content type="html"><![CDATA[<p>越来越谦逊低调</p><p>不想说任何谎言</p><p>对别人也越来越宽容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;越来越谦逊低调&lt;/p&gt;
&lt;p&gt;不想说任何谎言&lt;/p&gt;
&lt;p&gt;对别人也越来越宽容&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>复习加密算法</title>
    <link href="https://arthersun.github.io/2022/11/13/%E5%A4%8D%E4%B9%A0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://arthersun.github.io/2022/11/13/%E5%A4%8D%E4%B9%A0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-11-13T03:51:02.000Z</published>
    <updated>2022-11-13T06:54:03.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复习加密算法"><a class="markdownIt-Anchor" href="#复习加密算法"></a> 复习加密算法</h1><h3 id="ecc椭圆曲线加密算法"><a class="markdownIt-Anchor" href="#ecc椭圆曲线加密算法"></a> ECC椭圆曲线加密算法</h3><p>椭圆曲线加密算法是基于椭圆曲线数学理论实现的一种非对称加密算法。</p><p>相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。</p><p>160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。</p><p>比特币使用了secp256k1这条特殊的椭圆曲线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y^2 = x^3 + 7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复习加密算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#复习加密算法&quot;&gt;&lt;/a&gt; 复习加密算法&lt;/h1&gt;
&lt;h3 id=&quot;ecc椭圆曲线加密算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ecc椭圆曲</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>便捷版快排</title>
    <link href="https://arthersun.github.io/2022/11/12/%E4%BE%BF%E6%8D%B7%E7%89%88%E5%BF%AB%E6%8E%92/"/>
    <id>https://arthersun.github.io/2022/11/12/%E4%BE%BF%E6%8D%B7%E7%89%88%E5%BF%AB%E6%8E%92/</id>
    <published>2022-11-12T13:16:52.000Z</published>
    <updated>2022-11-12T13:17:39.952Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line">private void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">int temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line">if (start &gt;= end)</span><br><span class="line">return;</span><br><span class="line">int k = arr[start];</span><br><span class="line">int i = start, j = end;</span><br><span class="line">while (i != j) &#123;</span><br><span class="line">while (i &lt; j &amp;&amp; arr[j] &gt;= k)</span><br><span class="line">--j;</span><br><span class="line">swap(arr, i, j);</span><br><span class="line">while (i &lt; j &amp;&amp; arr[i] &lt;= k)</span><br><span class="line">++i;</span><br><span class="line">swap(arr, i, j);</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr, start, i - 1);</span><br><span class="line">quickSort(arr, i + 1, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;5, 2, 6, 9, 1, 3, 4, 8, 7, 10&#125;;</span><br><span class="line">new QuickSort().quickSort(arr, 0, arr.length - 1);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>判断是不是二叉搜索树的后序遍历</title>
    <link href="https://arthersun.github.io/2022/11/12/%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://arthersun.github.io/2022/11/12/%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-11-12T12:53:34.000Z</published>
    <updated>2022-11-12T13:05:31.749Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>输入: [1,6,3,2,5]<br>输出: false</p><p>输入: [1,3,2,6,5]<br>输出: true</p><p>单调栈解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean verifyPostorder(int[] postorder) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int root = Integer.MAX_VALUE;</span><br><span class="line">        for(int i = postorder.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(postorder[i] &gt; root) return false;</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            stack.add(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Krahets</span><br><span class="line">链接：https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solutions/150225/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归+检查的写法:注意，检查指针最后能不能移动到最后面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean verifyPostorder(int[] postorder) &#123;</span><br><span class="line">        return recur(postorder, 0, postorder.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean recur(int[] postorder, int i, int j) &#123;</span><br><span class="line">        if(i &gt;= j) return true;</span><br><span class="line">        int p = i;</span><br><span class="line">        while(postorder[p] &lt; postorder[j]) p++;</span><br><span class="line">        int m = p;</span><br><span class="line">        while(postorder[p] &gt; postorder[j]) p++;</span><br><span class="line">        return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。&lt;/p&gt;
&lt;p&gt;输入: [1,6,3,2,5]&lt;br&gt;
输出: false&lt;/p&gt;
&lt;p&gt;输入: [1,3,2,6,5]&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mac配置vim</title>
    <link href="https://arthersun.github.io/2022/11/12/mac%E9%85%8D%E7%BD%AEvim/"/>
    <id>https://arthersun.github.io/2022/11/12/mac%E9%85%8D%E7%BD%AEvim/</id>
    <published>2022-11-12T02:06:48.000Z</published>
    <updated>2022-11-12T02:10:08.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac如何配置vim"><a class="markdownIt-Anchor" href="#mac如何配置vim"></a> mac如何配置vim</h1><ol><li>由于/usr/share/vim没有权限修改，且chmod +w也显示无法操作，需要将其复制到用户主目录下，这样修改的就是一个用户的vim配置。</li></ol><p>复制的命令行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将全局版vimrc文件复制到用户主目录下做为用户版vimrc：</span><br><span class="line">cp /usr/share/vim/vimrc ~/.vimrc</span><br></pre></td></tr></table></figure><ol start="2"><li>打开~/.vimrc</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&quot;********************************基本设置******************************&quot;</span><br><span class="line">set tabstop=4                &quot; 设置tab键的宽度</span><br><span class="line">set shiftwidth=4             &quot; 换行时行间交错使用4个空格</span><br><span class="line">set autoindent               &quot; 自动对齐</span><br><span class="line">set backspace=2              &quot; 设置退格键可用</span><br><span class="line">set shiftwidth=4      &quot; 自动缩进4空格</span><br><span class="line">set smartindent              &quot; 智能自动缩进</span><br><span class="line">set number                   &quot; 在每一行最前面显示行号</span><br><span class="line">set showmatch                &quot; 高亮显示对应的括号</span><br><span class="line">set mouse=a                  &quot; 启用鼠标</span><br><span class="line">set ruler                    &quot; 在编辑过程中，在右下角显示光标位置的状态行</span><br><span class="line">set cursorline               &quot; 突出显示当前行</span><br><span class="line">set noswapfile               &quot; 设置无交换区文件&quot;</span><br><span class="line">set writebackup              &quot; 设置无备份文件</span><br><span class="line">set nobackup                 &quot; 设置无备份文件</span><br><span class="line">set autochdir                &quot; 设定文件浏览器目录为当前目录</span><br><span class="line">set foldmethod=syntax        &quot; 选择代码折叠类型</span><br><span class="line">set laststatus=2             &quot; 开启状态栏信息</span><br><span class="line">set cmdheight=2              &quot; 命令行的高度，默认为1，这里设为2</span><br><span class="line">set autoread                 &quot; 当文件在外部被修改，自动更新该文件</span><br><span class="line">set autoread                 &quot; 自动检测并加载外部对文件的修改</span><br><span class="line">set autowrite                &quot; 自动检测并加载外部对文件的修改</span><br><span class="line">set showcmd                  &quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来</span><br><span class="line">syntax enable                &quot; 打开语法高亮</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if has(&quot;gui_running&quot;)</span><br><span class="line">    set guioptions+=b        &quot; 显示底部滚动条</span><br><span class="line">    set nowrap               &quot; 设置不自动换行</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot;********************************设置编码*******************************&quot;</span><br><span class="line">&quot; 设置换行编码</span><br><span class="line">set fileformats=unix,dos,mac</span><br><span class="line">&quot; 设置Vim 内部使用的字符编码方式</span><br><span class="line">set encoding=utf-8</span><br><span class="line">&quot; 设置文件编码</span><br><span class="line">if has(&quot;win32&quot;)</span><br><span class="line">set fileencoding=chinese</span><br><span class="line">else</span><br><span class="line">set fileencoding=utf-8</span><br><span class="line">endif</span><br><span class="line">&quot; 解决consle输出乱码</span><br><span class="line">language messages zh_CN.utf-8</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>重启item2或者terminal</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mac如何配置vim&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mac如何配置vim&quot;&gt;&lt;/a&gt; mac如何配置vim&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;由于/usr/share/vim没有权限修改，且chmod +w也显示无法操作，需要</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习linux命令行</title>
    <link href="https://arthersun.github.io/2022/11/12/%E5%AD%A6%E4%B9%A0linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://arthersun.github.io/2022/11/12/%E5%AD%A6%E4%B9%A0linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2022-11-12T01:49:09.000Z</published>
    <updated>2022-11-12T10:00:21.173Z</updated>
    
    <content type="html"><![CDATA[<p>怎么创建一个文件（非目录）？</p><blockquote><p>号可以创建，如果同时创建多个文件，可以使用多个&gt;号。</p></blockquote><hr><p>复制文件：cp 本文件 新文件/路径</p><hr><p>命令行可以用分号隔开写多条命令</p><p>mkdir text1;cd …;mkdir text2</p><hr><p>移动文件：mv 文件 路径</p><hr><p>删除文件：rm 文件</p><hr><p>vim撤销和取消撤销：u Ctrl+r</p><hr><p>创建硬链接:ln 文件名 链接名</p><p>优点：除非删掉所有硬链接和文件，不然不会删掉</p><p>缺点：不能跨磁盘链接</p><hr><p>使用通配符查看文件：ls -l ???.???</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;怎么创建一个文件（非目录）？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;号可以创建，如果同时创建多个文件，可以使用多个&amp;gt;号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;复制文件：cp 本文件 新文件/路径&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;命令行可以用分号隔开写多条命令</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于测开职业生涯规划的一些想法</title>
    <link href="https://arthersun.github.io/2022/11/10/%E5%85%B3%E4%BA%8E%E6%B5%8B%E5%BC%80%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>https://arthersun.github.io/2022/11/10/%E5%85%B3%E4%BA%8E%E6%B5%8B%E5%BC%80%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2022-11-10T12:27:56.000Z</published>
    <updated>2022-11-10T12:31:00.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a class="markdownIt-Anchor" href="#关于"></a> 关于</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于&quot;&gt;&lt;/a&gt; 关于&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重学jvm</title>
    <link href="https://arthersun.github.io/2022/11/10/%E9%87%8D%E5%AD%A6jvm/"/>
    <id>https://arthersun.github.io/2022/11/10/%E9%87%8D%E5%AD%A6jvm/</id>
    <published>2022-11-10T12:27:30.000Z</published>
    <updated>2022-11-17T05:05:39.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重学jvm"><a class="markdownIt-Anchor" href="#重学jvm"></a> 重学jvm</h1><p>Java的类存在哪里？</p><p>误区：常规认为基本数据类型存放在栈中，引用类型存放在堆中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Text&#123;</span><br><span class="line">  int a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的a是存在堆里面的。</p><p>而方法：<br>public void text(){<br>int b = 1;<br>}</p><p>在text局部方法中基本数据类型的变量b是存储在栈中的</p><p>如果你将一个实例变量放在栈内，那么就不存在多个线程访问同一个对象资源了，这显然是不对的，所以实例变量要在堆上创建，但是对于局部变量，是在栈上创建的，调用一次方法创建一个帧，独享一份内存区域，其他的线程是不会访问到该线程的资源，在栈上创建也会减轻GC的压力，随着该方法的结束，帧出栈，相对应的内存消除，这种局部变量占用的内存自然就消失了。</p><hr><p>java中静态方法的作用是什么？</p><ol><li>声明为static的变量实质上是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。</li><li>只会分配一块存储空间，所有此类的对象都可以操控此块存储空间。</li><li>没有创建对象时也可以利用类使用该方法。静态方法可以调用静态方法、静态成员，但不能调用成员方法。</li></ol><hr><p>java静态变量存放在堆还是方法区？</p><ol><li>静态变量是被对象共享的，随着类加载而产生（不用实例化即可访问）</li><li>java8之前存放在方法区</li><li>java8及以后：存放在堆中反射的class对象的尾部</li></ol><hr><p>java栈空间包括哪些内容？</p><p>由一个个栈帧组成</p><ol><li><p>局部变量表：主要存放编译器可知的各种数据类型、对象引用（可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</p></li><li><p>操作数栈：主要是存放方法运行过程中产生的中间变量。</p></li><li><p>动态链接：主要服务一个方法需要调用其他方法的场景。</p></li><li><p>返回地址。</p></li></ol><hr><p>final、finally、finalize的区别？</p><ol><li>修饰变量：</li></ol><p>修饰基本数据类型：这个数据的值在初始化后将不能被改变。</p><p>修饰引用数据类型：引用在初始化后将永远指向一个内存地址，不可修改。里面的值是可以修改的</p><ol start="2"><li><p>final修饰的常量在编译阶段会被放入常量池中。</p></li><li><p>final类：被修饰的类不能被继承，所有方法不能被重写。</p></li></ol><p>try-catch-finally</p><p>finally里面的语句是否一定会被执行？</p><p>如果在try或catch中停止了jvm，则finally不会执行，例如停电。或者使用System.exit(0)可以阻断finally执行。</p><p>finally中的代码会执行，流程为：</p><ol><li><p>先计算返回值，并将返回值存储起来，等待返回</p></li><li><p>执行finally代码块</p></li><li><p>将存储的返回值，返回出去</p></li></ol><p>注：返回值是在finally运算之前就确定了，并且缓存（副本）了，不管finally对该值做任何的改变，返回的值都不会改变(不在finally中return)</p><p>finalize是在java.lang.Object里定义的方法，也就是说每一个对象都有这么一个方法，这个方法在gc启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize了，进而产生问题，因此不推荐使用 finalize 方法。</p><hr><p>java静态变量、代码块、和静态方法的执行顺序是什么？</p><ol><li><p>静态代码块-&gt;构造代码块-&gt;构造函数-&gt;普通代码块(构造代码块是每次执行构造函数之前执行)</p></li><li><p>父类-&gt;子类</p></li></ol><hr><p>java多态：</p><p>编译时多态：重载，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法</p><p>运行时多态：继承、重写和向上转型</p><p>继承：在多态中必须存在有继承关系的子类和父类</p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能调用父类的方法，又能调用子类的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重学jvm&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重学jvm&quot;&gt;&lt;/a&gt; 重学jvm&lt;/h1&gt;
&lt;p&gt;Java的类存在哪里？&lt;/p&gt;
&lt;p&gt;误区：常规认为基本数据类型存放在栈中，引用类型存放在堆中&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文中期梳理</title>
    <link href="https://arthersun.github.io/2022/11/07/%E8%AE%BA%E6%96%87%E4%B8%AD%E6%9C%9F%E6%A2%B3%E7%90%86/"/>
    <id>https://arthersun.github.io/2022/11/07/%E8%AE%BA%E6%96%87%E4%B8%AD%E6%9C%9F%E6%A2%B3%E7%90%86/</id>
    <published>2022-11-07T08:08:04.000Z</published>
    <updated>2022-11-09T13:40:43.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中期的任务"><a class="markdownIt-Anchor" href="#中期的任务"></a> 中期的任务</h1><ol><li>弄出一个方案创新点，做一部分实验，论文第三章写完</li><li>完成PPT制作</li><li>准备答辩问题</li></ol><p>ps：需要注意的：</p><ol><li>由于论文和答辩的特殊性，需要导师指导，需要预留时间给导师，提前计划给老师</li><li>一定要实事求是，不能操之过急，做了多少说多少，瞎说容易露出马脚</li></ol><h1 id="一些进展的timeline"><a class="markdownIt-Anchor" href="#一些进展的timeline"></a> 一些进展的timeline</h1><p>16:12<br>读一篇区块链云审计的中文论文，弄清楚云审计的过程，大约3小时</p><p>[1]谷天龙. 基于区块链的隐私保护云审计研究[D].天津大学,2020.DOI:10.27356/d.cnki.gtjdu.2020.003033.</p><p>涉及到的比较模糊的概念：<br>云计算、云审计</p><p>云计算</p><p>云计算分为IaaS、PaaS、SaaS<br><img src="/2022/11/07/%E8%AE%BA%E6%96%87%E4%B8%AD%E6%9C%9F%E6%A2%B3%E7%90%86/yun.png" alt="云计算"></p><p>IaaS:硬件、网络<br>PaaS:操作系统 Linux<br>SaaS:一些软件服务</p><p>云审计</p><p>云审计是一种监控通过控制台进行的操作、通过OpenAPI触发的操作、事件下载及转储、事件分析、追踪、告警等的行为</p><p>ps:例如腾讯云的云审计：使用腾讯云云审计（CloudAudit），可以获取您腾讯云账号下 API 调用历史记录，包括通过腾讯云管理控制台，腾讯云 SDK，命令行工具和其他腾讯云服务进行的API调用，监控腾讯云中的任何部署行为。可以确定哪些子用户、协作者使用腾讯云 API 时，从哪个源 IP 地址进行调用，以及何时发生调用。您可以设置多个不同的跟踪集用以跟踪不同的日志，随时控制何时打开和关闭 CloudAudit 日志记录。</p><h4 id="云存储审计和云审计果然不是一个东西老师批评的对"><a class="markdownIt-Anchor" href="#云存储审计和云审计果然不是一个东西老师批评的对"></a> 云存储审计和云审计果然不是一个东西，老师批评的对</h4><hr><p>读一篇云存储审计的论文</p><p>摸鱼了半天</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中期的任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#中期的任务&quot;&gt;&lt;/a&gt; 中期的任务&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;弄出一个方案创新点，做一部分实验，论文第三章写完&lt;/li&gt;
&lt;li&gt;完成PPT制作&lt;/li&gt;
&lt;li&gt;准备答辩问题</summary>
      
    
    
    
    
  </entry>
  
</feed>
